/*
Deployment script for DataEstateMeta

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar DatabaseName "DataEstateMeta"
:setvar DefaultFilePrefix "DataEstateMeta"
:setvar DefaultDataPath ""
:setvar DefaultLogPath ""

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [sys].[databases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE SCOPED CONFIGURATION SET MAXDOP = 0;
    END


GO
/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

-- Truncate tables before deployment to save time
PRINT 'Truncating tables before deployment';

IF OBJECT_ID('meta.[PreDeploymentCleanup]', 'P') IS NOT NULL
BEGIN 
	EXEC [meta].[PreDeploymentCleanup];
	PRINT 'Tables truncated';
END
ELSE
	PRINT 'Tables NOT truncated, as SPROC is not deployed yet';
GO

GO
PRINT N'Creating [bridge]...';


GO
CREATE SCHEMA [bridge]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [bridgeView]...';


GO
CREATE SCHEMA [bridgeView]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [dim]...';


GO
CREATE SCHEMA [dim]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [dimView]...';


GO
CREATE SCHEMA [dimView]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [fact]...';


GO
CREATE SCHEMA [fact]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [factView]...';


GO
CREATE SCHEMA [factView]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [meta]...';


GO
CREATE SCHEMA [meta]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [stage]...';


GO
CREATE SCHEMA [stage]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [stage_temp]...';


GO
CREATE SCHEMA [stage_temp]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [dim].[Time]...';


GO
CREATE TABLE [dim].[Time] (
    [TimeID]         INT           IDENTITY (1, 1) NOT NULL,
    [TimeHourKey]    INT           NULL,
    [TimeMinuteKey]  INT           NULL,
    [Time]           TIME (0)      NULL,
    [TimeDayPart]    NVARCHAR (10) NULL,
    [TimeHourFromTo] NVARCHAR (13) NULL,
    [TimeNotation]   NVARCHAR (10) NULL
);


GO
PRINT N'Creating [dim].[Calendar]...';


GO
CREATE TABLE [dim].[Calendar] (
    [CalendarID]           INT           NOT NULL,
    [CalendarKey]          DATE          NULL,
    [CalendarDate]         DATE          NULL,
    [DayNumber]            INT           NULL,
    [WeekCode]             INT           NULL,
    [WeekNumber]           INT           NULL,
    [WeekName]             NVARCHAR (20) NULL,
    [WeekYear]             INT           NULL,
    [WeekDayNumber]        SMALLINT      NULL,
    [WeekDayName]          NVARCHAR (10) NULL,
    [MonthCode]            INT           NULL,
    [MonthNumber]          INT           NULL,
    [MonthName]            NVARCHAR (20) NULL,
    [MonthShort]           NVARCHAR (3)  NULL,
    [MonthLong]            NVARCHAR (12) NULL,
    [QuarterCode]          INT           NULL,
    [QuarterNumber]        INT           NULL,
    [QuarterName]          NVARCHAR (20) NULL,
    [Quarter]              NVARCHAR (2)  NULL,
    [Year]                 INT           NULL,
    [FiscalMonthCode]      INT           NULL,
    [FiscalMonthNumber]    INT           NULL,
    [FiscalMonthName]      NVARCHAR (20) NULL,
    [FiscalQuarterCode]    INT           NULL,
    [FiscalQuarterNumber]  INT           NULL,
    [FiscalQuarterName]    NVARCHAR (20) NULL,
    [FiscalYear]           INT           NULL,
    [FiscalYearName]       VARCHAR (10)  NULL,
    [FirstDateofYear]      DATE          NULL,
    [LastDateofYear]       DATE          NULL,
    [FirstDateofQuarter]   DATE          NULL,
    [LastDateofQuarter]    DATE          NULL,
    [FirstDateofMonth]     DATE          NULL,
    [LastDateofMonth]      DATE          NULL,
    [FirstDateofWeek]      DATE          NULL,
    [LastDateofWeek]       DATE          NULL,
    [CurrentYear]          SMALLINT      NULL,
    [CurrentQuarter]       SMALLINT      NULL,
    [CurrentMonth]         SMALLINT      NULL,
    [CurrentWeek]          SMALLINT      NULL,
    [CurrentDay]           INT           NULL,
    [IsToday]              BIT           NULL,
    [IsWeekend]            BIT           NULL,
    [IsHoliday]            BIT           NULL,
    [HolidayName]          VARCHAR (20)  NULL,
    [SpecialDays]          VARCHAR (20)  NULL,
    [CalendarIsFutureFlag] BIT           NULL,
    [DWModifiedDate]       DATETIME      NULL,
    PRIMARY KEY CLUSTERED ([CalendarID] ASC)
);


GO
PRINT N'Creating [meta].[Environments]...';


GO
CREATE TABLE [meta].[Environments] (
    [ID]                                       INT            IDENTITY (0, 1) NOT NULL,
    [EnvironmentName]                          NVARCHAR (20)  NULL,
    [DatabaseInstance]                         NVARCHAR (200) NULL,
    [IntegrationServicesInstance]              NVARCHAR (200) NULL,
    [AnalysisServicesMultidimensionalInstance] NVARCHAR (200) NULL,
    [AnalysisServicesTabularInstance]          NVARCHAR (200) NULL
);


GO
PRINT N'Creating [meta].[FrameworkMetaData]...';


GO
CREATE TABLE [meta].[FrameworkMetaData] (
    [ID]                   INT            IDENTITY (1, 1) NOT NULL,
    [SourceObjectID]       INT            NULL,
    [BusinessMatrixID]     INT            NULL,
    [TargetObjectID]       INT            NULL,
    [AverageDuration]      INT            NULL,
    [SQLScript]            NVARCHAR (MAX) NULL,
    [PartitionSQLScript]   NVARCHAR (MAX) NULL,
    [ConnectionSQLScript]  NVARCHAR (MAX) NULL,
    [DropTableSQLScript]   NVARCHAR (MAX) NULL,
    [CreateTableSQLScript] NVARCHAR (MAX) NULL,
    [AzureDWSQLScript]     NVARCHAR (MAX) NULL,
    CONSTRAINT [PK__Framewor__3214EC27261AF711] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [meta].[BusinessMatrix]...';


GO
CREATE TABLE [meta].[BusinessMatrix] (
    [ID]                           INT            IDENTITY (1, 1) NOT NULL,
    [DestinationSchema]            NVARCHAR (20)  NULL,
    [TableName]                    NVARCHAR (250) NULL,
    [LoadPattern]                  NVARCHAR (100) NULL,
    [FactAndBridgeIncrementalFlag] BIT            NULL,
    [SCD2DimensionFlag]            BIT            NULL,
    [PackageDependencyFlag]        BIT            NULL,
    [TruncateBeforeDeployFlag]     BIT            NULL,
    [TransformExcludeFlag]         BIT            NULL,
    [DWExcludeFlag]                BIT            NULL,
    [ControllerExcludeFlag]        BIT            NULL,
    CONSTRAINT [PK_BusinessMatrix] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [meta].[BusinessMatrixPackageDependency]...';


GO
CREATE TABLE [meta].[BusinessMatrixPackageDependency] (
    [ID]                     INT IDENTITY (1, 1) NOT NULL,
    [ChildBusinessMatrixID]  INT NULL,
    [ParentBusinessMatrixID] INT NULL,
    CONSTRAINT [PK__Business__3214EC27E8DE0D08] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [meta].[SourceConnections]...';


GO
CREATE TABLE [meta].[SourceConnections] (
    [ID]                              INT            IDENTITY (1, 1) NOT NULL,
    [ConnectionType]                  NVARCHAR (250) NOT NULL,
    [Name]                            NVARCHAR (250) NOT NULL,
    [Provider]                        NVARCHAR (200) NOT NULL,
    [DataSource]                      NVARCHAR (100) NOT NULL,
    [InitialCatalog]                  NVARCHAR (100) NOT NULL,
    [ConnectionString]                NVARCHAR (500) NOT NULL,
    [ConnectionStringCustomComponent] NVARCHAR (500) NOT NULL,
    [ExtractSchemaName]               NVARCHAR (100) NOT NULL,
    [NavisionFlag]                    BIT            NOT NULL,
    [RemoveBracketsFlag]              BIT            NOT NULL,
    [ExcludeFlag]                     BIT            NOT NULL,
    CONSTRAINT [AK_SourceConnections_Name] UNIQUE NONCLUSTERED ([Name] ASC)
);


GO
PRINT N'Creating [meta].[SourceObjects]...';


GO
CREATE TABLE [meta].[SourceObjects] (
    [ID]                       INT            IDENTITY (1, 1) NOT NULL,
    [SourceConnectionID]       INT            NOT NULL,
    [SchemaName]               NVARCHAR (200) NOT NULL,
    [ObjectName]               NVARCHAR (200) NOT NULL,
    [ExtractPattern]           NVARCHAR (100) NOT NULL,
    [ExtractSQLFilter]         NVARCHAR (MAX) NOT NULL,
    [PreserveHistoryFlag]      BIT            NOT NULL,
    [FileExtractFlag]          BIT            NOT NULL,
    [IncrementalFlag]          BIT            NOT NULL,
    [PartitionFlag]            BIT            NOT NULL,
    [SCD2ExtractFlag]          BIT            NOT NULL,
    [KeyColumnFlag]            BIT            NOT NULL,
    [TruncateBeforeDeployFlag] BIT            NOT NULL,
    [ControllerExcludeFlag]    BIT            NOT NULL,
    [TargetDestinationFlag]    BIT            NOT NULL,
    [DWDestinationFlag]        BIT            NOT NULL,
    [ExcludeFlag]              BIT            NOT NULL,
    CONSTRAINT [PK_SourceObjects] PRIMARY KEY CLUSTERED ([ID] ASC),
    CONSTRAINT [AK_SourceObjects_SourceConnectionID_SchemaName_ObjectName] UNIQUE NONCLUSTERED ([SourceConnectionID] ASC, [SchemaName] ASC, [ObjectName] ASC)
);


GO
PRINT N'Creating [meta].[DWRelations]...';


GO
CREATE TABLE [meta].[DWRelations] (
    [TableName]                       NVARCHAR (128) NULL,
    [DimensionName]                   NVARCHAR (128) NULL,
    [TableColumnName]                 NVARCHAR (128) NULL,
    [DimensionColumnMappingName]      NVARCHAR (128) NULL,
    [RolePlayingDimensionName]        NVARCHAR (128) NULL,
    [IsSCD2DimensionFlag]             NVARCHAR (10)  NULL,
    [IsSCD2CompositeKeyDimensionFlag] NVARCHAR (10)  NULL,
    [ColumnOrdinalPosition]           INT            NULL,
    [IsNewDimensionFlag]              NVARCHAR (128) NULL,
    [DefaultErrorValue]               NVARCHAR (128) NULL
);


GO
PRINT N'Creating [meta].[SourceObjectSCD2Setup]...';


GO
CREATE TABLE [meta].[SourceObjectSCD2Setup] (
    [Id]             INT            IDENTITY (1, 1) NOT NULL,
    [SourceObjectID] INT            NOT NULL,
    [SCD2ColumnName] NVARCHAR (500) NOT NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [meta].[SourceColumns]...';


GO
CREATE TABLE [meta].[SourceColumns] (
    [ID]             INT            IDENTITY (1, 1) NOT NULL,
    [SourceObjectID] INT            NULL,
    [ColumnName]     NVARCHAR (200) NULL
);


GO
PRINT N'Creating [meta].[SourceConnectionNavisionSetup]...';


GO
CREATE TABLE [meta].[SourceConnectionNavisionSetup] (
    [ID]                 INT            IDENTITY (1, 1) NOT NULL,
    [SourceConnectionID] INT            NOT NULL,
    [CompanyName]        NVARCHAR (200) NOT NULL,
    [ExtractFlag]        BIT            NOT NULL
);


GO
PRINT N'Creating [meta].[SourceObjectFileSetup]...';


GO
CREATE TABLE [meta].[SourceObjectFileSetup] (
    [ID]                INT            IDENTITY (1, 1) NOT NULL,
    [SourceObjectID]    INT            NOT NULL,
    [LoopFileFlag]      TINYINT        NOT NULL,
    [FileSystem]        NVARCHAR (250) NOT NULL,
    [Folder]            NVARCHAR (250) NOT NULL,
    [FileName]          NVARCHAR (250) NOT NULL,
    [FileExtension]     NVARCHAR (250) NOT NULL,
    [FileSpecification] NVARCHAR (250) NOT NULL,
    [RowSeparator]      NVARCHAR (250) NOT NULL,
    [ColumnDelimiter]   NVARCHAR (250) NOT NULL,
    [TextQualifier]     NVARCHAR (250) NOT NULL,
    [IsHeaderPresent]   BIT            NOT NULL,
    [CompressionCodec]  NVARCHAR (250) NULL,
    [EscapeCharacter]   NVARCHAR (250) NULL,
    [Encoding]          NVARCHAR (250) NULL
);


GO
PRINT N'Creating [meta].[SourceObjectIncrementalSetup]...';


GO
CREATE TABLE [meta].[SourceObjectIncrementalSetup] (
    [ID]                                        INT            IDENTITY (1, 1) NOT NULL,
    [SourceObjectID]                            INT            NOT NULL,
    [IncrementalValueColumnDefinition]          NVARCHAR (500) NOT NULL,
    [IncrementalValueColumnDefinitionInExtract] NVARCHAR (500) NOT NULL,
    [IsDateFlag]                                BIT            NOT NULL,
    [LastValueLoaded]                           NVARCHAR (500) NOT NULL,
    [RollingWindowDays]                         INT            NULL,
    CONSTRAINT [AK_SourceObjectIncrementalSetup_ID] UNIQUE NONCLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [meta].[SourceObjectKeyColumns]...';


GO
CREATE TABLE [meta].[SourceObjectKeyColumns] (
    [ID]                        INT            IDENTITY (1, 1) NOT NULL,
    [SourceObjectID]            INT            NOT NULL,
    [SourceObjectKeyColumnName] NVARCHAR (250) NOT NULL,
    PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [meta].[ExtractInformationSchema]...';


GO
CREATE TABLE [meta].[ExtractInformationSchema] (
    [SourceObjectID]           INT            NULL,
    [SourceSystemTypeName]     NVARCHAR (128) NULL,
    [TableCatalogName]         NVARCHAR (128) NULL,
    [SchemaName]               NVARCHAR (128) NULL,
    [TableName]                NVARCHAR (128) NULL,
    [ColumnName]               NVARCHAR (128) NULL,
    [OrdinalPositionNumber]    INT            NULL,
    [FullDataTypeName]         NVARCHAR (128) NULL,
    [NullableName]             NVARCHAR (128) NULL,
    [DataTypeName]             NVARCHAR (128) NULL,
    [MaximumLenghtNumber]      NVARCHAR (38)  NULL,
    [NumericPrecisionNumber]   INT            NULL,
    [NumericScaleNumber]       INT            NULL,
    [KeySequenceNumber]        INT            NULL,
    [ExtractSchemaName]        NVARCHAR (128) NULL,
    [ADFDataType]              NVARCHAR (128) NULL,
    [SourceConnectionID]       INT            NULL,
    [OriginalDataTypeName]     NVARCHAR (128) NULL,
    [CreateTableFlag]          BIT            NULL,
    [TruncateBeforeDeployFlag] BIT            NULL,
    [PreserveHistoryFlag]      BIT            NULL,
    [NavisionFlag]             BIT            NULL
);


GO
PRINT N'Creating [meta].[BusinessMatrixIncrementalSetup]...';


GO
CREATE TABLE [meta].[BusinessMatrixIncrementalSetup] (
    [ID]                   INT            IDENTITY (1, 1) NOT NULL,
    [BusinessMatrixID]     INT            NULL,
    [PrimaryKeyColumnName] NVARCHAR (200) NULL,
    CONSTRAINT [PK__Business__3214EC271402B3B8] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [meta].[BusinessMatrixSCD2Setup]...';


GO
CREATE TABLE [meta].[BusinessMatrixSCD2Setup] (
    [Id]               INT            IDENTITY (1, 1) NOT NULL,
    [BusinessMatrixID] INT            NOT NULL,
    [SCD2ColumnName]   NVARCHAR (500) NOT NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [meta].[TargetAzureSQLDWSetup]...';


GO
CREATE TABLE [meta].[TargetAzureSQLDWSetup] (
    [ID]                 INT IDENTITY (1, 1) NOT NULL,
    [TargetObjectID]     INT NOT NULL,
    [TargetConnectionID] INT NOT NULL
);


GO
PRINT N'Creating [meta].[TargetConnections]...';


GO
CREATE TABLE [meta].[TargetConnections] (
    [ID]             INT            IDENTITY (1, 1) NOT NULL,
    [ConnectionType] NVARCHAR (250) NOT NULL,
    [Name]           NVARCHAR (250) NOT NULL,
    [ExcludeFlag]    BIT            NOT NULL
);


GO
PRINT N'Creating [meta].[TargetObjectFileSetup]...';


GO
CREATE TABLE [meta].[TargetObjectFileSetup] (
    [ID]                             INT            IDENTITY (1, 1) NOT NULL,
    [TargetObjectID]                 INT            NOT NULL,
    [FileSystemName]                 NVARCHAR (250) NOT NULL,
    [FolderName]                     NVARCHAR (250) NOT NULL,
    [FileDynamicExtensionDefinition] NVARCHAR (250) NOT NULL,
    [AzureFileTypeName]              NVARCHAR (50)  NOT NULL,
    [AppendDataFlag]                 BIT            NOT NULL
);


GO
PRINT N'Creating [meta].[TargetObjectFileSetup].[PK_TargetObjectFileSetup]...';


GO
CREATE UNIQUE CLUSTERED INDEX [PK_TargetObjectFileSetup]
    ON [meta].[TargetObjectFileSetup]([TargetObjectID] ASC);


GO
PRINT N'Creating [meta].[TargetObjects]...';


GO
CREATE TABLE [meta].[TargetObjects] (
    [ID]                    INT            IDENTITY (1, 1) NOT NULL,
    [SourceObjectID]        INT            NOT NULL,
    [TargetConnectionID]    INT            NOT NULL,
    [ExtractPattern]        NVARCHAR (100) NOT NULL,
    [ExtractSQLFilter]      NVARCHAR (MAX) NOT NULL,
    [PreserveHistoryFlag]   BIT            NOT NULL,
    [IncrementalFlag]       BIT            NOT NULL,
    [SCD2ExtractFlag]       BIT            NOT NULL,
    [FileTargetFlag]        BIT            NOT NULL,
    [AzureSqlDWFlag]        BIT            NOT NULL,
    [ExcludeFlag]           BIT            NOT NULL,
    [ControllerExcludeFlag] BIT            NOT NULL,
    CONSTRAINT [PK_TargetObjects] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [meta].[TargetObjectSCD2Setup]...';


GO
CREATE TABLE [meta].[TargetObjectSCD2Setup] (
    [Id]             INT            IDENTITY (1, 1) NOT NULL,
    [TargetObjectID] INT            NOT NULL,
    [SCD2ColumnName] NVARCHAR (500) NOT NULL,
    PRIMARY KEY CLUSTERED ([Id] ASC)
);


GO
PRINT N'Creating [meta].[SourceObjectPartition]...';


GO
CREATE TABLE [meta].[SourceObjectPartition] (
    [ID]                             INT            IDENTITY (1, 1) NOT NULL,
    [SourceObjectID]                 INT            NOT NULL,
    [PartitionValueColumnDefinition] NVARCHAR (MAX) NOT NULL,
    [UseModulusFlag]                 BIT            NULL,
    [PartitionLowerBound]            NVARCHAR (200) NOT NULL,
    [PartitionUpperBound]            NVARCHAR (200) NOT NULL,
    CONSTRAINT [PK_SourceObjectPartition] PRIMARY KEY CLUSTERED ([ID] ASC)
);


GO
PRINT N'Creating [meta].[DF_FrameworkMetaData_AverageDuration]...';


GO
ALTER TABLE [meta].[FrameworkMetaData]
    ADD CONSTRAINT [DF_FrameworkMetaData_AverageDuration] DEFAULT ((1)) FOR [AverageDuration];


GO
PRINT N'Creating [meta].[DF_BusinessMatrix_LoadPattern]...';


GO
ALTER TABLE [meta].[BusinessMatrix]
    ADD CONSTRAINT [DF_BusinessMatrix_LoadPattern] DEFAULT (N'Standard') FOR [LoadPattern];


GO
PRINT N'Creating [meta].[DF_BusinessMatrix_FactAndBridgeIncrementalFlag]...';


GO
ALTER TABLE [meta].[BusinessMatrix]
    ADD CONSTRAINT [DF_BusinessMatrix_FactAndBridgeIncrementalFlag] DEFAULT ((0)) FOR [FactAndBridgeIncrementalFlag];


GO
PRINT N'Creating [meta].[DF_BusinessMatrix_SCD2DimensionFlag]...';


GO
ALTER TABLE [meta].[BusinessMatrix]
    ADD CONSTRAINT [DF_BusinessMatrix_SCD2DimensionFlag] DEFAULT ((0)) FOR [SCD2DimensionFlag];


GO
PRINT N'Creating [meta].[DF_BusinessMatrix_PackageDependencyFlag]...';


GO
ALTER TABLE [meta].[BusinessMatrix]
    ADD CONSTRAINT [DF_BusinessMatrix_PackageDependencyFlag] DEFAULT ((0)) FOR [PackageDependencyFlag];


GO
PRINT N'Creating [meta].[DF_BusinessMatrix_TruncateBeforeDeployFlag]...';


GO
ALTER TABLE [meta].[BusinessMatrix]
    ADD CONSTRAINT [DF_BusinessMatrix_TruncateBeforeDeployFlag] DEFAULT ((0)) FOR [TruncateBeforeDeployFlag];


GO
PRINT N'Creating [meta].[DF__BusinessM__Enabl__5CD6CB2B]...';


GO
ALTER TABLE [meta].[BusinessMatrix]
    ADD CONSTRAINT [DF__BusinessM__Enabl__5CD6CB2B] DEFAULT ((0)) FOR [TransformExcludeFlag];


GO
PRINT N'Creating [meta].[DF_BusinessMatrix_DWExcludeFlag]...';


GO
ALTER TABLE [meta].[BusinessMatrix]
    ADD CONSTRAINT [DF_BusinessMatrix_DWExcludeFlag] DEFAULT ((0)) FOR [DWExcludeFlag];


GO
PRINT N'Creating [meta].[DF_BusinessMatrix_ControllerExcludeFlag]...';


GO
ALTER TABLE [meta].[BusinessMatrix]
    ADD CONSTRAINT [DF_BusinessMatrix_ControllerExcludeFlag] DEFAULT ((0)) FOR [ControllerExcludeFlag];


GO
PRINT N'Creating [meta].[DF_SourceConnections_ConnectionType]...';


GO
ALTER TABLE [meta].[SourceConnections]
    ADD CONSTRAINT [DF_SourceConnections_ConnectionType] DEFAULT ('') FOR [ConnectionType];


GO
PRINT N'Creating [meta].[DF_SourceConnections_Name]...';


GO
ALTER TABLE [meta].[SourceConnections]
    ADD CONSTRAINT [DF_SourceConnections_Name] DEFAULT ('') FOR [Name];


GO
PRINT N'Creating [meta].[DF_SourceConnections_Provider]...';


GO
ALTER TABLE [meta].[SourceConnections]
    ADD CONSTRAINT [DF_SourceConnections_Provider] DEFAULT ('') FOR [Provider];


GO
PRINT N'Creating [meta].[DF_SourceConnections_DataSource]...';


GO
ALTER TABLE [meta].[SourceConnections]
    ADD CONSTRAINT [DF_SourceConnections_DataSource] DEFAULT ('') FOR [DataSource];


GO
PRINT N'Creating [meta].[DF_SourceConnections_InitialCatalog]...';


GO
ALTER TABLE [meta].[SourceConnections]
    ADD CONSTRAINT [DF_SourceConnections_InitialCatalog] DEFAULT ('') FOR [InitialCatalog];


GO
PRINT N'Creating [meta].[DF_SourceConnections_ConnectionString]...';


GO
ALTER TABLE [meta].[SourceConnections]
    ADD CONSTRAINT [DF_SourceConnections_ConnectionString] DEFAULT ('') FOR [ConnectionString];


GO
PRINT N'Creating [meta].[DF_SourceConnections_ConnectionStringCustomComponent]...';


GO
ALTER TABLE [meta].[SourceConnections]
    ADD CONSTRAINT [DF_SourceConnections_ConnectionStringCustomComponent] DEFAULT ('') FOR [ConnectionStringCustomComponent];


GO
PRINT N'Creating [meta].[DF_SourceConnections_ExtractSchemaName]...';


GO
ALTER TABLE [meta].[SourceConnections]
    ADD CONSTRAINT [DF_SourceConnections_ExtractSchemaName] DEFAULT ('') FOR [ExtractSchemaName];


GO
PRINT N'Creating [meta].[DF_SourceConnections_NavisionFlag]...';


GO
ALTER TABLE [meta].[SourceConnections]
    ADD CONSTRAINT [DF_SourceConnections_NavisionFlag] DEFAULT ((0)) FOR [NavisionFlag];


GO
PRINT N'Creating [meta].[DF_SourceConnections_RemoveBracketsFlag]...';


GO
ALTER TABLE [meta].[SourceConnections]
    ADD CONSTRAINT [DF_SourceConnections_RemoveBracketsFlag] DEFAULT ((0)) FOR [RemoveBracketsFlag];


GO
PRINT N'Creating [meta].[DF_SourceConnections_ExcludeFlag]...';


GO
ALTER TABLE [meta].[SourceConnections]
    ADD CONSTRAINT [DF_SourceConnections_ExcludeFlag] DEFAULT ((0)) FOR [ExcludeFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjects_ExtractPattern]...';


GO
ALTER TABLE [meta].[SourceObjects]
    ADD CONSTRAINT [DF_SourceObjects_ExtractPattern] DEFAULT (N'Standard') FOR [ExtractPattern];


GO
PRINT N'Creating [meta].[DF_SourceObjects_ExtractSQLFilter]...';


GO
ALTER TABLE [meta].[SourceObjects]
    ADD CONSTRAINT [DF_SourceObjects_ExtractSQLFilter] DEFAULT ('') FOR [ExtractSQLFilter];


GO
PRINT N'Creating [meta].[DF_SourceObjects_PreserveHistoryFlag]...';


GO
ALTER TABLE [meta].[SourceObjects]
    ADD CONSTRAINT [DF_SourceObjects_PreserveHistoryFlag] DEFAULT ((0)) FOR [PreserveHistoryFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjects_FileExtractFlag]...';


GO
ALTER TABLE [meta].[SourceObjects]
    ADD CONSTRAINT [DF_SourceObjects_FileExtractFlag] DEFAULT ((0)) FOR [FileExtractFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjects_IncrementalFlag]...';


GO
ALTER TABLE [meta].[SourceObjects]
    ADD CONSTRAINT [DF_SourceObjects_IncrementalFlag] DEFAULT ((0)) FOR [IncrementalFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjects_ParallelizationFlag]...';


GO
ALTER TABLE [meta].[SourceObjects]
    ADD CONSTRAINT [DF_SourceObjects_ParallelizationFlag] DEFAULT ((0)) FOR [PartitionFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjects_SCD2ExtractFlag]...';


GO
ALTER TABLE [meta].[SourceObjects]
    ADD CONSTRAINT [DF_SourceObjects_SCD2ExtractFlag] DEFAULT ((0)) FOR [SCD2ExtractFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjects_KeyColumnFlag]...';


GO
ALTER TABLE [meta].[SourceObjects]
    ADD CONSTRAINT [DF_SourceObjects_KeyColumnFlag] DEFAULT ((0)) FOR [KeyColumnFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjects_TruncateBeforeDeployFlag]...';


GO
ALTER TABLE [meta].[SourceObjects]
    ADD CONSTRAINT [DF_SourceObjects_TruncateBeforeDeployFlag] DEFAULT ((1)) FOR [TruncateBeforeDeployFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjects_ControllerExcludeFlag]...';


GO
ALTER TABLE [meta].[SourceObjects]
    ADD CONSTRAINT [DF_SourceObjects_ControllerExcludeFlag] DEFAULT ((1)) FOR [ControllerExcludeFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjects_TargetDestinationFlag]...';


GO
ALTER TABLE [meta].[SourceObjects]
    ADD CONSTRAINT [DF_SourceObjects_TargetDestinationFlag] DEFAULT ((0)) FOR [TargetDestinationFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjects_DWDestinationFlag]...';


GO
ALTER TABLE [meta].[SourceObjects]
    ADD CONSTRAINT [DF_SourceObjects_DWDestinationFlag] DEFAULT ((1)) FOR [DWDestinationFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjects_ExcludeFlag]...';


GO
ALTER TABLE [meta].[SourceObjects]
    ADD CONSTRAINT [DF_SourceObjects_ExcludeFlag] DEFAULT ((0)) FOR [ExcludeFlag];


GO
PRINT N'Creating [meta].[DF_SourceConnectionNavisionSetup_SourceConnectionID]...';


GO
ALTER TABLE [meta].[SourceConnectionNavisionSetup]
    ADD CONSTRAINT [DF_SourceConnectionNavisionSetup_SourceConnectionID] DEFAULT ((0)) FOR [SourceConnectionID];


GO
PRINT N'Creating [meta].[DF_SourceObjectNavisionSetup_CompanyName]...';


GO
ALTER TABLE [meta].[SourceConnectionNavisionSetup]
    ADD CONSTRAINT [DF_SourceObjectNavisionSetup_CompanyName] DEFAULT ('') FOR [CompanyName];


GO
PRINT N'Creating [meta].[DF_SourceObjectNavisionSetup_ExtractFlag]...';


GO
ALTER TABLE [meta].[SourceConnectionNavisionSetup]
    ADD CONSTRAINT [DF_SourceObjectNavisionSetup_ExtractFlag] DEFAULT ((0)) FOR [ExtractFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjectFileSetup_LoopFileFlag]...';


GO
ALTER TABLE [meta].[SourceObjectFileSetup]
    ADD CONSTRAINT [DF_SourceObjectFileSetup_LoopFileFlag] DEFAULT ((0)) FOR [LoopFileFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjectFileSetup_FileSystemName]...';


GO
ALTER TABLE [meta].[SourceObjectFileSetup]
    ADD CONSTRAINT [DF_SourceObjectFileSetup_FileSystemName] DEFAULT ('') FOR [FileSystem];


GO
PRINT N'Creating [meta].[DF_SourceObjectFileSetup_Folder]...';


GO
ALTER TABLE [meta].[SourceObjectFileSetup]
    ADD CONSTRAINT [DF_SourceObjectFileSetup_Folder] DEFAULT ('') FOR [Folder];


GO
PRINT N'Creating [meta].[DF_SourceObjectFileSetup_FileName]...';


GO
ALTER TABLE [meta].[SourceObjectFileSetup]
    ADD CONSTRAINT [DF_SourceObjectFileSetup_FileName] DEFAULT ('') FOR [FileName];


GO
PRINT N'Creating [meta].[DF_SourceObjectFileSetup_FileExtension]...';


GO
ALTER TABLE [meta].[SourceObjectFileSetup]
    ADD CONSTRAINT [DF_SourceObjectFileSetup_FileExtension] DEFAULT ('') FOR [FileExtension];


GO
PRINT N'Creating [meta].[DF_SourceObjectFileSetup_FileSpecification]...';


GO
ALTER TABLE [meta].[SourceObjectFileSetup]
    ADD CONSTRAINT [DF_SourceObjectFileSetup_FileSpecification] DEFAULT ('') FOR [FileSpecification];


GO
PRINT N'Creating [meta].[DF_SourceObjectIncrementalSetup_IncrementalValueColumnName]...';


GO
ALTER TABLE [meta].[SourceObjectIncrementalSetup]
    ADD CONSTRAINT [DF_SourceObjectIncrementalSetup_IncrementalValueColumnName] DEFAULT ('') FOR [IncrementalValueColumnDefinition];


GO
PRINT N'Creating [meta].[DF_SourceObjectIncrementalSetup_IncrementalValueColumnDefinitionInExtract]...';


GO
ALTER TABLE [meta].[SourceObjectIncrementalSetup]
    ADD CONSTRAINT [DF_SourceObjectIncrementalSetup_IncrementalValueColumnDefinitionInExtract] DEFAULT ('') FOR [IncrementalValueColumnDefinitionInExtract];


GO
PRINT N'Creating [meta].[DF_SourceObjectIncrementalSetup_IsDateFlag]...';


GO
ALTER TABLE [meta].[SourceObjectIncrementalSetup]
    ADD CONSTRAINT [DF_SourceObjectIncrementalSetup_IsDateFlag] DEFAULT ((0)) FOR [IsDateFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjectIncrementalSetup_RollingWindowNumber]...';


GO
ALTER TABLE [meta].[SourceObjectIncrementalSetup]
    ADD CONSTRAINT [DF_SourceObjectIncrementalSetup_RollingWindowNumber] DEFAULT ((0)) FOR [RollingWindowDays];


GO
PRINT N'Creating [meta].[DF_TargetConnections_ConnectionType]...';


GO
ALTER TABLE [meta].[TargetConnections]
    ADD CONSTRAINT [DF_TargetConnections_ConnectionType] DEFAULT ('') FOR [ConnectionType];


GO
PRINT N'Creating [meta].[DF_TargetConnections_Name]...';


GO
ALTER TABLE [meta].[TargetConnections]
    ADD CONSTRAINT [DF_TargetConnections_Name] DEFAULT ('') FOR [Name];


GO
PRINT N'Creating [meta].[DF_TargetConnections_ExcludeFlag]...';


GO
ALTER TABLE [meta].[TargetConnections]
    ADD CONSTRAINT [DF_TargetConnections_ExcludeFlag] DEFAULT ((0)) FOR [ExcludeFlag];


GO
PRINT N'Creating [meta].[DF__TargetObj__FileS__531856C7]...';


GO
ALTER TABLE [meta].[TargetObjectFileSetup]
    ADD CONSTRAINT [DF__TargetObj__FileS__531856C7] DEFAULT ('') FOR [FileSystemName];


GO
PRINT N'Creating [meta].[DF__TargetObj__Folde__540C7B00]...';


GO
ALTER TABLE [meta].[TargetObjectFileSetup]
    ADD CONSTRAINT [DF__TargetObj__Folde__540C7B00] DEFAULT ('') FOR [FolderName];


GO
PRINT N'Creating [meta].[DF__TargetObj__FileD__55F4C372]...';


GO
ALTER TABLE [meta].[TargetObjectFileSetup]
    ADD CONSTRAINT [DF__TargetObj__FileD__55F4C372] DEFAULT ('') FOR [FileDynamicExtensionDefinition];


GO
PRINT N'Creating [meta].[DF_TargetObjectFileSetup_AppendDataFlag]...';


GO
ALTER TABLE [meta].[TargetObjectFileSetup]
    ADD CONSTRAINT [DF_TargetObjectFileSetup_AppendDataFlag] DEFAULT ((0)) FOR [AppendDataFlag];


GO
PRINT N'Creating [meta].[DF_TargetObjects_ExtractPattern]...';


GO
ALTER TABLE [meta].[TargetObjects]
    ADD CONSTRAINT [DF_TargetObjects_ExtractPattern] DEFAULT (N'Standard') FOR [ExtractPattern];


GO
PRINT N'Creating [meta].[DF_TargetObjects_ExtractSQLFilter]...';


GO
ALTER TABLE [meta].[TargetObjects]
    ADD CONSTRAINT [DF_TargetObjects_ExtractSQLFilter] DEFAULT ('') FOR [ExtractSQLFilter];


GO
PRINT N'Creating [meta].[DF_TargetObjects_PreserveHistoryFlag]...';


GO
ALTER TABLE [meta].[TargetObjects]
    ADD CONSTRAINT [DF_TargetObjects_PreserveHistoryFlag] DEFAULT ((0)) FOR [PreserveHistoryFlag];


GO
PRINT N'Creating [meta].[DF_TargetObjects_IncrementalFlag]...';


GO
ALTER TABLE [meta].[TargetObjects]
    ADD CONSTRAINT [DF_TargetObjects_IncrementalFlag] DEFAULT ((0)) FOR [IncrementalFlag];


GO
PRINT N'Creating [meta].[DF_TargetObjects_SCD2ExtractFlag]...';


GO
ALTER TABLE [meta].[TargetObjects]
    ADD CONSTRAINT [DF_TargetObjects_SCD2ExtractFlag] DEFAULT ((0)) FOR [SCD2ExtractFlag];


GO
PRINT N'Creating [meta].[DF_TargetObjects_FileExtractFlag]...';


GO
ALTER TABLE [meta].[TargetObjects]
    ADD CONSTRAINT [DF_TargetObjects_FileExtractFlag] DEFAULT ((0)) FOR [FileTargetFlag];


GO
PRINT N'Creating [meta].[DF_TargetObjects_AzureSqlDWFlag]...';


GO
ALTER TABLE [meta].[TargetObjects]
    ADD CONSTRAINT [DF_TargetObjects_AzureSqlDWFlag] DEFAULT ((0)) FOR [AzureSqlDWFlag];


GO
PRINT N'Creating [meta].[DF_TargetObjects_ExcludeFlag]...';


GO
ALTER TABLE [meta].[TargetObjects]
    ADD CONSTRAINT [DF_TargetObjects_ExcludeFlag] DEFAULT ((0)) FOR [ExcludeFlag];


GO
PRINT N'Creating [meta].[DF_TargetObjects_ControllerExcludeFlag]...';


GO
ALTER TABLE [meta].[TargetObjects]
    ADD CONSTRAINT [DF_TargetObjects_ControllerExcludeFlag] DEFAULT ((0)) FOR [ControllerExcludeFlag];


GO
PRINT N'Creating [meta].[DF_SourceObjectPartition_UseModulusFlag]...';


GO
ALTER TABLE [meta].[SourceObjectPartition]
    ADD CONSTRAINT [DF_SourceObjectPartition_UseModulusFlag] DEFAULT ((0)) FOR [UseModulusFlag];


GO
PRINT N'Creating [meta].[chk_DWTableType]...';


GO
ALTER TABLE [meta].[BusinessMatrix] WITH NOCHECK
    ADD CONSTRAINT [chk_DWTableType] CHECK ([DestinationSchema]='bridge' OR [DestinationSchema]='fact' OR [DestinationSchema]='dim' OR [DestinationSchema]='temp');


GO
PRINT N'Creating [dimView].[Time]...';


GO
Create View dimView.Time AS
					SELECT * FROM dim.Time
GO
PRINT N'Creating [dimView].[Calendar]...';


GO
CREATE VIEW dimView.Calendar AS

SELECT
	[CalendarID]
      ,[CalendarKey]
      ,[CalendarDate]
      ,[DayNumber]
      ,[WeekCode]
      ,[WeekNumber]
      ,[WeekName]
      ,[WeekYear]
      ,[WeekDayNumber]
      ,[WeekDayName]
      ,[MonthCode]
      ,[MonthNumber]
      ,[MonthName]
      ,[MonthShort]
      ,[MonthLong]
      ,[QuarterCode]
      ,[QuarterNumber]
      ,[QuarterName]
      ,[Quarter]
      ,[Year]
      ,[FiscalMonthCode]
      ,[FiscalMonthNumber]
      ,[FiscalMonthName]
      ,[FiscalQuarterCode]
      ,[FiscalQuarterNumber]
      ,[FiscalQuarterName]
      ,[FiscalYear]
      ,[FiscalYearName]
      ,[FirstDateofYear]
      ,[LastDateofYear]
      ,[FirstDateofQuarter]
      ,[LastDateofQuarter]
      ,[FirstDateofMonth]
      ,[LastDateofMonth]
      ,[FirstDateofWeek]
      ,[LastDateofWeek]
      ,[CurrentYear]
      ,[CurrentQuarter]
      ,[CurrentMonth]
      ,[CurrentWeek]
      ,[CurrentDay]
      ,[IsToday]
      ,[IsWeekend]
      ,[IsHoliday]
      ,[HolidayName]
      ,[SpecialDays]
      ,[CalendarIsFutureFlag]
	FROM dim.Calendar
GO
PRINT N'Creating [meta].[DWRelationDefinitions]...';


GO


CREATE VIEW [meta].[DWRelationDefinitions]

AS

SELECT TableName
      ,DimensionName
      ,TableColumnName
      ,DimensionColumnMappingName
      ,RolePlayingDimensionName
      ,IsSCD2DimensionFlag
      ,IsSCD2CompositeKeyDimensionFlag
      ,ColumnOrdinalPosition
      ,IsNewDimensionFlag
      ,DefaultErrorValue
FROM 
	meta.DWRelations
GO
PRINT N'Creating [meta].[ExtractInformationSchemaDefinitions]...';


GO

















CREATE VIEW [meta].[ExtractInformationSchemaDefinitions] AS


WITH ExtractSchema AS
(
SELECT 
	   ExtractInformationSchema.SourceObjectID
	  ,ExtractInformationSchema.SourceSystemTypeName
      ,TableCatalogName 
      ,ExtractInformationSchema.SchemaName
      ,TableName
      ,ColumnName
      ,OrdinalPositionNumber
	  ,IIF(SourceObjects.FileExtractFlag = 1, 
			  CASE DataTypeName
				WHEN 'STRING' THEN 'nvarchar'
				WHEN 'SINGLE' THEN 'tinyint'
				WHEN 'INT16' THEN 'tinyint'
				WHEN 'INT32' THEN 'int'
				WHEN 'INT64' THEN 'bigint'
				WHEN 'BOOLEAN' THEN 'bit'
				WHEN 'DOUBLE' THEN 'decimal'
				WHEN 'DECIMAL' THEN 'decimal'
				WHEN 'GUID' THEN 'uniqueidentifier'
				WHEN 'DATETIME' THEN 'datetime'
				WHEN 'DATETIMEOFFSET' THEN 'datetimeoffset'
				WHEN 'TIMESPAN' THEN 'bigint'
				WHEN 'BYTE[]' THEN 'varbinary'
				ELSE 'nvarchar'
			  END,
			  CASE 
			    WHEN DataTypeName = 'VARCHAR' THEN 'NVARCHAR'
				WHEN DataTypeName = 'CHAR' THEN 'NVARCHAR'
				WHEN DataTypeName = 'NCHAR' THEN 'NVARCHAR'
				WHEN DataTypeName = 'MONEY' THEN 'DECIMAL'
				WHEN DataTypeName = 'NUMBER' THEN 'DECIMAL'
				WHEN DataTypeName = 'FLOAT' THEN 'DECIMAL'
				WHEN DataTypeName = 'DATE' AND ExtractInformationSchema.SourceSystemTypeName = 'Oracle' THEN 'DATETIME2'
				WHEN DataTypeName = 'VARCHAR2' THEN 'NVARCHAR'
				WHEN DataTypeName = 'ORDIMAGE' THEN 'NVARCHAR'
				WHEN DataTypeName = 'NVARCHAR2' THEN 'NVARCHAR'
				WHEN DataTypeName = 'TIMESTAMP' THEN 'BIGINT'
				WHEN DataTypeName = 'IMAGE' THEN 'NVARCHAR'
				ELSE DataTypeName
			  END
		) AS DataTypeName
	  ,[ExtractInformationSchema].MaximumLenghtNumber
	  ,CASE
		WHEN DataTypeName = 'FLOAT' AND [ExtractInformationSchema].NumericPrecisionNumber > 36 THEN 36
		ELSE [ExtractInformationSchema].NumericPrecisionNumber 
	   END AS NumericPrecisionNumber
	  ,[ExtractInformationSchema].NumericScaleNumber
	  ,COALESCE(IIF(SourceObjectKeyColumns.ID IS NULL,NULL,ROW_NUMBER() OVER (PARTITION BY [ExtractInformationSchema].SourceObjectID  ORDER BY SourceObjectKeyColumns.ID desc)), KeySequenceNumber) AS KeySequenceNumber	 
 	  ,DataTypeName AS OriginalDataTypeName
	  ,COALESCE([ExtractInformationSchema].CreateTableFlag,SourceObjects.DWDestinationFlag) AS CreateTableFlag
	  ,COALESCE([ExtractInformationSchema].TruncateBeforeDeployFlag,SourceObjects.TruncateBeforeDeployFlag) AS TruncateBeforeDeployFlag
	  ,COALESCE([ExtractInformationSchema].PreserveHistoryFlag,SourceObjects.PreserveHistoryFlag) AS PreserveHistoryFlag
	  ,COALESCE([ExtractInformationSchema].NavisionFlag,SourceConnections.NavisionFlag) AS NavisionFlag
	  ,SourceObjects.FileExtractFlag
  FROM 
	[meta].[ExtractInformationSchema]   
  LEFT JOIN
		meta.SourceObjects
			ON SourceObjects.ID = [ExtractInformationSchema].SourceObjectID
  LEFT JOIN 
		meta.SourceConnections
			ON SourceConnections.ID = SourceObjects.SourceConnectionID
  LEFT JOIN
		meta.SourceObjectKeyColumns
			ON SourceObjectKeyColumns.SourceObjectID = [ExtractInformationSchema].SourceObjectID
			AND SourceObjectKeyColumns.SourceObjectKeyColumnName = [ExtractInformationSchema].ColumnName
		)

	,PrepareData AS
	(
	SELECT DISTINCT 
		   SourceSystemTypeName
		  ,TableCatalogName
		  ,ExtractSchema.SchemaName
		  ,SourceObjects.ObjectName AS TableName
		  ,ExtractSchema.ColumnName
		  ,OrdinalPositionNumber
		  ,IIF(KeySequenceNumber IS NOT NULL,' NOT NULL',' NULL') NullableName
		  ,DataTypeName
	      ,IIF(ExtractSchema.FileExtractFlag = 1 AND UPPER(DataTypeName) = 'NVARCHAR', 
			'500', 
			IIF(DataTypeName = 'NVARCHAR' AND ISNULL(ExtractSchema.MaximumLenghtNumber,4001) >= 4000,'4000',ExtractSchema.MaximumLenghtNumber)
		   ) AS MaximumLenghtNumber
		  ,IIF(ExtractSchema.FileExtractFlag = 1 AND UPPER(DataTypeName) = 'DECIMAL',
			'36',
			IIF(DataTypeName = 'DECIMAL' AND NumericPrecisionNumber IS NULL,'36',NumericPrecisionNumber) 
		   ) AS NumericPrecisionNumber
		  ,IIF(ExtractSchema.FileExtractFlag = 1 AND UPPER(DataTypeName) = 'DECIMAL',
			'12',
			IIF(DataTypeName = 'DECIMAL' AND NumericScaleNumber IS NULL,'12',NumericScaleNumber)
	       ) AS NumericScaleNumber
		  ,KeySequenceNumber
		  ,SourceConnections.ExtractSchemaName 
		  ,ExtractSchema.SourceObjectID 
		  ,SourceObjects.SourceConnectionID
		  ,CASE DataTypeName
				WHEN 'bigint' THEN 'Int64'
				WHEN 'char' THEN 'String'
				WHEN 'datetime' THEN 'Datetime'
				WHEN 'datetimeoffset' THEN 'Datetimeoffset'
				WHEN 'decimal' THEN 'Decimal'
				WHEN 'float' THEN 'Double'
				WHEN 'real' THEN 'Double'
				WHEN 'int' THEN 'Int32'
				WHEN 'money' THEN 'Decimal'
				WHEN 'nchar' THEN 'String'
				WHEN 'numeric' THEN 'Decimal'
				WHEN 'nvarchar' THEN 'String'
				WHEN 'smallint' then 'Int16'
				WHEN 'tinyint' THEN 'Int16'
				WHEN 'uniqueidentifier' THEN 'Guid'
				WHEN 'varbinary' THEN 'Byte[]'
				ELSE 'String'
			END 'ADFDataType'
		 ,IIF(SourceColumns.ColumnName IS NULL,0,1) AS TableHasColumnFilterFlag
		 ,IIF(SourceColumns2.ColumnName IS NULL,0,1) AS ColumnFilterFlag
		 ,OriginalDataTypeName
		 ,CreateTableFlag
	     ,ExtractSchema.TruncateBeforeDeployFlag
	     ,ExtractSchema.PreserveHistoryFlag
		 ,ExtractSchema.NavisionFlag
	FROM
		ExtractSchema
	LEFT JOIN
		meta.SourceObjects
			ON SourceObjects.ID = ExtractSchema.SourceObjectID
	LEFT JOIN 
		meta.SourceConnections
			ON SourceConnections.ID = SourceObjects.SourceConnectionID
	LEFT JOIN
		meta.SourceColumns
			ON SourceObjects.ID = SourceColumns.SourceObjectID
	LEFT JOIN
		meta.SourceColumns AS SourceColumns2
			ON ExtractSchema.ColumnName = SourceColumns2.ColumnName
			AND SourceObjects.ID = SourceColumns2.SourceObjectID
	)

	,SourceData AS 
	(
	SELECT 
		   SourceSystemTypeName
		  ,TableCatalogName
		  ,SchemaName
		  ,TableName
		  ,ColumnName
		  ,OrdinalPositionNumber
		  ,IIF(DataTypeName IN ('nvarchar'), 'NVARCHAR',UPPER(DataTypeName)) +  
			CASE 
				WHEN DataTypeName in ('object','float','real') OR DataTypeName like '%int%' OR DataTypeName like'%date%'
					THEN ''
				WHEN DataTypeName IN ('nvarchar') AND MaximumLenghtNumber = -1 
					THEN '(MAX)'
				WHEN DataTypeName IN ('varbinary')
					THEN '(MAX)'
				WHEN NumericPrecisionNumber IS NOT NULL 
					THEN ' (' + CAST(NumericPrecisionNumber AS VARCHAR(50)) + ', ' + CAST(NumericScaleNumber AS VARCHAR(50))+ ')'
				WHEN MaximumLenghtNumber IS NOT NULL 
					THEN ' (' + CAST(MaximumLenghtNumber AS VARCHAR(50)) + ')'																											
				ELSE '' 
			END AS FullDataTypeName
		  ,NullableName
		  ,DataTypeName
	      ,MaximumLenghtNumber
		  ,NumericPrecisionNumber
		  ,NumericScaleNumber
		  ,KeySequenceNumber
		  ,ExtractSchemaName 
		  ,SourceObjectID 
		  ,SourceConnectionID
		  ,ADFDataType
		 ,TableHasColumnFilterFlag
		 ,ColumnFilterFlag
		 ,OriginalDataTypeName
		 ,CreateTableFlag
	     ,TruncateBeforeDeployFlag
	     ,PreserveHistoryFlag
		 ,NavisionFlag
	FROM
		PrepareData
	)

		SELECT 
			 COALESCE(SourceData.SourceSystemTypeName, SourceTable.SourceSystemTypeName) AS SourceSystemTypeName
			,COALESCE(SourceData.TableCatalogName, SourceTable.TableCatalogName) AS TableCatalogName
			,COALESCE(SourceData.SchemaName, SourceTable.SchemaName) AS SchemaName
			,COALESCE(SourceData.TableName, SourceTable.TableName) AS TableName
			,COALESCE(SourceData.ColumnName, SourceTable.ColumnName) AS ColumnName
			,COALESCE(SourceData.OrdinalPositionNumber, SourceTable.OrdinalPositionNumber) AS OrdinalPositionNumber
			,COALESCE(SourceData.FullDataTypeName, SourceTable.FullDataTypeName) AS FullDataTypeName
			,COALESCE(SourceData.NullableName, SourceTable.NullableName) AS NullableName
			,COALESCE(SourceData.DataTypeName, SourceTable.DataTypeName) AS DataTypeName
			,COALESCE(SourceData.MaximumLenghtNumber, SourceTable.MaximumLenghtNumber) AS MaximumLenghtNumber
			,COALESCE(SourceData.NumericPrecisionNumber, SourceTable.NumericPrecisionNumber) AS NumericPrecisionNumber
			,COALESCE(SourceData.NumericScaleNumber, SourceTable.NumericScaleNumber) AS NumericScaleNumber
			,COALESCE(SourceData.KeySequenceNumber, SourceTable.KeySequenceNumber) AS KeySequenceNumber
			,COALESCE(SourceData.ExtractSchemaName, SourceTable.ExtractSchemaName) AS ExtractSchemaName
			,COALESCE(SourceData.ADFDataType, SourceTable.ADFDataType) AS ADFDataType
			,COALESCE(SourceData.SourceObjectID, SourceTable.SourceObjectID) AS SourceObjectID
			,COALESCE(SourceData.SourceConnectionID, SourceTable.SourceConnectionID) AS SourceConnectionID
			,COALESCE(SourceData.OriginalDataTypeName, SourceTable.OriginalDataTypeName) AS OriginalDataTypeName
			,SourceData.CreateTableFlag
			,SourceData.TruncateBeforeDeployFlag
			,SourceData.PreserveHistoryFlag
			,SourceData.NavisionFlag
		FROM SourceData
		LEFT JOIN [meta].[ExtractInformationSchema] SourceTable
			ON SourceData.SourceObjectID = SourceTable.SourceObjectID
				AND SourceData.ColumnName = SourceTable.ColumnName

		WHERE TableHasColumnFilterFlag = ColumnFilterFlag
GO
PRINT N'Creating [meta].[Variables]...';


GO
CREATE VIEW [meta].[Variables] AS

SELECT 
	 CONVERT(NVARCHAR(128),Name) AS VariableName
	,CONVERT(NVARCHAR(128),value) AS VariableValue
	,'EXEC sp_updateextendedproperty @name = N''' + CONVERT(NVARCHAR(128),Name) + ''', @value = N''' + CONVERT(NVARCHAR(128),value) + '''' AS UpdateVariableSQL
FROM 
	sys.extended_properties 
WHERE 
	class_desc = 'DATABASE'
GO
PRINT N'Creating [meta].[ApplicationConnections]...';


GO


CREATE view [meta].[ApplicationConnections] as
select 
	(case 
		when ConnectionName = 'Cube'
		then N'SSAS'
		else N'OleDb'
	end) as ConnectionType, 
	ConnectionName as Name, 
	(case
		when ConnectionName = 'Cube'
		then N'MSOLAP.5'
		else N'SQLNCLI11.1'
	end) as Provider, 
	DatabaseInstance as DataSource,
	DBSuffix as InitialCatalog,
	(case 
		when ConnectionName = 'Cube'
		then N'Data Source=' + [AnalysisServicesMultidimensionalInstance] + ';Initial Catalog=' + DBSuffix +';Provider=MSOLAP.7;Integrated Security=SSPI;'
		when ConnectionName = 'Tabular'
		then N'Data Source=' + [AnalysisServicesTabularInstance] + ';Initial Catalog=' + DBSuffix +';Provider=MSOLAP.7;Integrated Security=SSPI;'
		else N'Data Source=' + DatabaseInstance + ';Initial Catalog=' + DBSuffix + ';Provider=SQLNCLI11.1;Integrated Security=SSPI;Auto Translate=False;' 
	end) as ConnectionString
from 
	meta.[Environments] as environments,
	meta.[Variables] as variables,
	(
		select (select VariableValue from meta.[Variables] where VariableName = 'DatabaseNameMeta') as DBSuffix, 'Meta' as ConnectionName union all 
		select (select VariableValue from meta.[Variables] where VariableName = 'DatabaseNameExtract'), 'Extract' union all 
		select (select VariableValue from meta.[Variables] where VariableName = 'DatabaseNameStage'), 'Stage' union all 
		select (select VariableValue from meta.[Variables] where VariableName = 'DatabaseNameDW'), 'DW' union all 
		select (select VariableValue from meta.[Variables] where VariableName = 'DatabaseNameCube'), 'Cube' union all
		select (select VariableValue from meta.[Variables] where VariableName = 'DatabaseNameTabular'), 'Tabular'
	) as DBSuffixes
where
	EnvironmentName = 'Development' and
	VariableName = 'DatabaseNameExtract'
GO
PRINT N'Creating [meta].[BusinessMatrixDefinitions]...';


GO

 

 
 CREATE VIEW [meta].[BusinessMatrixDefinitions]

 AS
 
 

	SELECT
		 BusinessMatrix.ID
		,DestinationSchema
		,TableName
		,IIF((SELECT VariableValue FROM meta.Variables WHERE VariableName = 'FactLoadEngine') = 'SQL' AND DestinationSchema IN ('fact','bridge'),'SQL',LoadPattern) AS LoadPattern
		,IIF((SELECT VariableValue FROM meta.Variables WHERE VariableName = 'IsCloudFlag') = '1','SQL',LoadPattern) AS TransformPattern
		,LoadPattern AS ExecutionPattern
		,FactAndBridgeIncrementalFlag
		,SCD2DimensionFlag
		,PackageDependencyFlag
		,TransformExcludeFlag
		,DWExcludeFlag
		,ControllerExcludeFlag
		,UPPER(LEFT(BusinessMatrix.[DestinationSchema],1)) + SUBSTRING(BusinessMatrix.[DestinationSchema],2,LEN(BusinessMatrix.[DestinationSchema])-1) AS CapitalisedDestinationSchema
		,FrameworkMetaData.SQLScript
		,(SELECT VariableValue FROM meta.Variables WHERE VariableName = 'FactInMemoryFlag') AS FactInMemoryFlag
		,(SELECT VariableValue FROM meta.Variables WHERE VariableName = 'FactLoadEngine') AS LoadEngine
	    ,(SELECT VariableValue FROM meta.Variables WHERE VariableName = 'IsCloudFlag') AS IsCloudFlag
		,(SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameMeta') AS DatabaseName
	FROM
		meta.BusinessMatrix
	LEFT JOIN
		meta.FrameworkMetaData
			ON FrameworkMetaData.BusinessMatrixID = BusinessMatrix.ID
GO
PRINT N'Creating [meta].[ControllerDefinitions]...';


GO












CREATE VIEW [meta].[ControllerDefinitions] AS

WITH ParentChildData AS
 (
SELECT TableName
	  ,DestinationSchema
	  ,CASE 
			WHEN Child.ChildBusinessMatrixID IS NULL AND Parent.ChildBusinessMatrixID IS NOT NULL THEN BusinessMatrix.ID
			WHEN Child.ChildBusinessMatrixID IS NOT NULL AND Parent.ChildBusinessMatrixID IS NOT NULL THEN Child.ChildBusinessMatrixID
			WHEN Child.ChildBusinessMatrixID IS NOT NULL AND Parent.ChildBusinessMatrixID IS NULL THEN Child.ChildBusinessMatrixID
			ELSE BusinessMatrix.ID
	   END AS ChildBusinessMatrixID
	  ,CASE 
			WHEN Child.ChildBusinessMatrixID IS NULL AND Parent.ChildBusinessMatrixID IS NOT NULL THEN NULL
			WHEN Child.ChildBusinessMatrixID IS NOT NULL AND Parent.ChildBusinessMatrixID IS NOT NULL THEN Child.ParentBusinessMatrixID
			WHEN Child.ChildBusinessMatrixID IS NOT NULL AND Parent.ChildBusinessMatrixID IS NULL THEN Child.ParentBusinessMatrixID
			ELSE BusinessMatrix.ID
	   END AS ParentBusinessMatrixID
    
  FROM 
		meta.BusinessMatrix
  LEFT JOIN 
		meta.BusinessMatrixPackageDependency AS Child
			ON Child.ChildBusinessMatrixID = BusinessMatrix.ID
  LEFT JOIN 
		meta.BusinessMatrixPackageDependency AS Parent
			ON Parent.ParentBusinessMatrixID = BusinessMatrix.ID
  WHERE 
	BusinessMatrix.PackageDependencyFlag = 1
	AND ControllerExcludeFlag = 0

							)

, RecursiveHierarchy
AS
(
 SELECT 
		ChildBusinessMatrixID AS BusinessMatrixID
	   ,DestinationSchema
	   ,TableName
	   ,1 AS Generation
	   ,ParentBusinessMatrixID AS ParentID
 FROM 
	ParentChildData AS FirtGeneration
 WHERE 
	ParentBusinessMatrixID IS NULL 
	       
 UNION ALL

 SELECT 
		NextGeneration.ChildBusinessMatrixID
	   ,NextGeneration.DestinationSchema
	   ,NextGeneration.TableName
	   ,Parent.Generation + 1
	   ,Parent.BusinessMatrixID
 FROM 
	ParentChildData AS NextGeneration
 INNER JOIN 
	RecursiveHierarchy AS Parent 
		ON NextGeneration.ParentBusinessMatrixID = Parent.BusinessMatrixID     
)

, DistinctHierarchyData AS
(
SELECT DISTINCT  *
FROM 
	RecursiveHierarchy
	)

,TopLevelParent AS
(
SELECT 
	   BusinessMatrixID
	  ,DestinationSchema
	  ,TableName
	  ,Generation
	  ,ParentID
	  ,BusinessMatrixID AS TopLevelParent
	FROM 
		DistinctHierarchyData
	WHERE 
		ParentID IS NULL

  UNION ALL

SELECT DistinctHierarchyData.*
	  ,TopLevelParent.TopLevelParent 
FROM 
	DistinctHierarchyData
INNER JOIN
	TopLevelParent 
		ON TopLevelParent.BusinessMatrixID = DistinctHierarchyData.ParentID
WHERE 
	DistinctHierarchyData.BusinessMatrixID <> DistinctHierarchyData.ParentID
)

, PackageDependencies AS

(

SELECT DISTINCT
	    TopLevelParent.BusinessMatrixID
	   ,TopLevelParent.DestinationSchema
	   ,TopLevelParent.TableName
	   ,CAST(TopLevelParent.Generation AS NVARCHAR(10)) AS Generation
	   ,N'Dependencies' AS TopLevelName

FROM
	TopLevelParent
INNER JOIN
	meta.BusinessMatrix
		ON BusinessMatrix.ID = TopLevelParent.TopLevelParent
LEFT JOIN
	meta.BusinessMatrix AS Parent
		ON Parent.ID = TopLevelParent.ParentID


UNION ALL

SELECT	
	   ID
	  ,DestinationSchema
	  ,TableName
	  ,N'0'
	  ,'NoDependencies'


FROM 
	meta.BusinessMatrix
WHERE 
	ID NOT IN (SELECT BusinessMatrixID FROM RecursiveHierarchy)
	AND ControllerExcludeFlag = 0
	)


,ControllerData AS
(
SELECT 
	  SourceObjects.ID
	, 'Controller_Extract' + (CASE WHEN ConnectionType in ('Excel','FlatFile') THEN ConnectionType ELSE [Name] END) AS ControllerName
	, ExtractSchemaName AS SchemaName
	, N'Extract' AS ControllerArea
	, SourceObjects.ObjectName AS TableName
	, 'Extract' + ExtractSchemaName + '_' + ObjectName AS PackageName
	, ControllerExcludeFlag
	, '0' AS Generation
	, 'Extract' AS TopLevelName
	, FrameworkMetaData.AverageDuration
	, NULL AS ParentPackageDependencyName
	, NULL AS ParentPackageDependencyPackageName
	, 0 AS PackageDependencyFlag
		
FROM 
	meta.SourceConnections
INNER JOIN
	meta.SourceObjects
		ON SourceObjects.SourceConnectionID = SourceConnections.ID
LEFT JOIN
	meta.FrameworkMetaData
		ON FrameworkMetaData.SourceObjectID = SourceObjects.ID
WHERE
	DWDestinationFlag = 1
	AND SourceConnections.ExcludeFlag = 0

UNION

SELECT 
	  TargetObjects.ID
	, 'Controller_Extract_' + SourceConnections.[Name] + '_' + (CASE WHEN TargetConnections.ConnectionType in ('Excel','FlatFile') THEN TargetConnections.ConnectionType ELSE TargetConnections.[Name] END) AS ControllerName
	, ExtractSchemaName AS SchemaName
	, N'Extract' AS ControllerArea
	, SourceObjects.ObjectName AS TableName
	, 'Extract' + SourceConnections.Name + '_'+ TargetConnections.Name + '_' +  IIF(TargetObjects.FileTargetFlag = 1, TargetObjectFileSetup.FileSystemName + '_' + REPLACE(TargetObjectFileSetup.FolderName, '/', '') + '_','') + SourceObjects.ObjectName AS PackageName
	, TargetObjects.ControllerExcludeFlag
	, '0' AS Generation
	, 'Target' AS TopLevelName
	, NULL AS AverageDuration
	, NULL AS ParentPackageDependencyName
	, NULL AS ParentPackageDependencyPackageName
	, 0 AS PackageDependencyFlag
		
FROM 
	meta.TargetConnections
INNER JOIN
	meta.TargetObjects
		ON TargetObjects.TargetConnectionID = TargetConnections.ID
INNER JOIN
	meta.SourceObjects
		ON SourceObjects.ID = TargetObjects.SourceObjectID
INNER JOIN
	meta.SourceConnections
		ON SourceConnections.ID = SourceObjects.SourceConnectionID
LEFT JOIN
	meta.TargetObjectFileSetup
		ON TargetObjectFileSetup.TargetObjectID = TargetObjects.ID
WHERE
	TargetConnections.ExcludeFlag = 0

UNION 

SELECT 
	  BusinessMatrix.ID
	, 'Controller_Load' + CASE BusinessMatrix.DestinationSchema
								WHEN 'dim' THEN 'Dimensions'
								WHEN 'bridge' THEN 'Bridges'
								WHEN 'fact' THEN 'Facts'
								WHEN 'temp' THEN 'Temp'
								ELSE ''
						 END
	, BusinessMatrix.DestinationSchema
	, CASE BusinessMatrix.DestinationSchema
								WHEN 'dim' THEN 'Dimensions'
								WHEN 'bridge' THEN 'Bridges'
								WHEN 'fact' THEN 'Facts'
								WHEN 'temp' THEN 'Temp'
								ELSE ''
	  END
	, IIF(BusinessMatrix.DestinationSchema = 'temp','Temp_','') + BusinessMatrix.TableName
	, CASE BusinessMatrix.DestinationSchema
								WHEN 'dim' THEN 'LoadDimension_'
								WHEN 'bridge' THEN 'LoadBridge_'
								WHEN 'fact' THEN 'LoadFact_'
								ELSE 'Transform_'
			   END + BusinessMatrix.TableName
	, BusinessMatrix.ControllerExcludeFlag
	, PackageDependencies.Generation
	, PackageDependencies.TopLevelName
	, FrameworkMetaData.AverageDuration
	, Parent.TableName
	, CASE BusinessMatrix.DestinationSchema
								WHEN 'dim' THEN 'LoadDimension_'
								WHEN 'bridge' THEN 'LoadBridge_'
								WHEN 'fact' THEN 'LoadFact_'
								ELSE 'Transform_'
      END + Parent.TableName
	, BusinessMatrix.PackageDependencyFlag
FROM
	meta.BusinessMatrix
INNER JOIN
	PackageDependencies
		ON PackageDependencies.BusinessMatrixID = BusinessMatrix.ID
LEFT JOIN
	meta.FrameworkMetaData
		ON FrameworkMetaData.BusinessMatrixID = BusinessMatrix.ID
LEFT JOIN
	meta.BusinessMatrixPackageDependency
		ON BusinessMatrix.ID = BusinessMatrixPackageDependency.ChildBusinessMatrixID
LEFT JOIN
	meta.BusinessMatrix AS Parent
		ON Parent.ID = BusinessMatrixPackageDependency.ParentBusinessMatrixID

)

, Controller AS
(
SELECT 
	  ID
	, ControllerName
	, SchemaName
	, ControllerArea
	, TableName
	, PackageName
	, ControllerData.ControllerExcludeFlag
	, Generation
	, CAST(Generation - 1 AS NVARCHAR(10)) AS PrevGeneration
	, TopLevelName
	, CAST(PackageDependencyFlag AS NVARCHAR(1)) AS HasDependencyFlag
	, IIF(PackageDependencyFlag = 0,NULL,ParentPackageDependencyName) AS ParentPackageDependencyName
	, IIF(PackageDependencyFlag = 0,NULL,ParentPackageDependencyPackageName) AS ParentPackageDependencyPackageName
	, ISNULL(AverageDuration,1) AS AverageDuration
	, CAST(ROW_NUMBER() OVER (PARTITION BY ControllerName,Generation,ISNULL( IIF(PackageDependencyFlag = 0,NULL,ParentPackageDependencyName),'') ORDER BY ControllerData.ID) AS NVARCHAR(4000)) AS RowNo
	, CAST(ROW_NUMBER() OVER (PARTITION BY ControllerName,Generation,ISNULL( IIF(PackageDependencyFlag = 0,NULL,ParentPackageDependencyName),'') ORDER BY ControllerData.ID) - 1 AS NVARCHAR(4000)) AS PrevRowNo
	, CAST(ROW_NUMBER() OVER (PARTITION BY ControllerName,Generation,ISNULL( IIF(PackageDependencyFlag = 0,NULL,ParentPackageDependencyName),'') ORDER BY ControllerData.ID) - 2 AS NVARCHAR(4000)) AS PrevPrevRowNo
	--, IIF((ROW_NUMBER() OVER (PARTITION BY ControllerName,Generation,ISNULL( IIF(PackageDependencyFlag = 0,NULL,ParentPackageDependencyName),'') ORDER BY ControllerData.ID) % 2) = 0,'1','0') AS IsEvenFlag
	, IIF(SchemaName IN ('dim','bridge','fact'),'1','0') AS IsLoadFlag 
	, CASE 
		   WHEN ControllerArea = 'Extract' THEN (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'ExtractControllerPattern')
		   ELSE (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'LoadControllerPattern')
	  END AS ControllerPattern
	, (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameMeta') AS DatabaseName
	, 0 AS IsTransformFlag
FROM 
	ControllerData
WHERE
	ControllerExcludeFlag = 0
	

UNION

SELECT 
	  ID
	, ControllerName
	, SchemaName
	, ControllerArea
	, TableName
	, 'Transform_' + TableName AS PackageName
	, ControllerData.ControllerExcludeFlag
	, Generation
	, CAST(Generation - 1 AS NVARCHAR(10)) AS PrevGeneration
	, TopLevelName
	, CAST(PackageDependencyFlag AS NVARCHAR(1)) AS HasDependencyFlag
	, IIF(PackageDependencyFlag = 0,NULL,ParentPackageDependencyName) AS ParentPackageDependencyName
	, IIF(PackageDependencyFlag = 0,NULL,ParentPackageDependencyPackageName) AS ParentPackageDependencyPackageName
	, ISNULL(AverageDuration,1) AS AverageDuration
	, CAST(ROW_NUMBER() OVER (PARTITION BY ControllerName,Generation,ISNULL( IIF(PackageDependencyFlag = 0,NULL,ParentPackageDependencyName),'') ORDER BY ControllerData.ID) AS NVARCHAR(4000)) AS RowNo
	, CAST(ROW_NUMBER() OVER (PARTITION BY ControllerName,Generation,ISNULL( IIF(PackageDependencyFlag = 0,NULL,ParentPackageDependencyName),'') ORDER BY ControllerData.ID) - 1 AS NVARCHAR(4000)) AS PrevRowNo
	, CAST(ROW_NUMBER() OVER (PARTITION BY ControllerName,Generation,ISNULL( IIF(PackageDependencyFlag = 0,NULL,ParentPackageDependencyName),'') ORDER BY ControllerData.ID) - 2 AS NVARCHAR(4000)) AS PrevPrevRowNo
	--, IIF((ROW_NUMBER() OVER (PARTITION BY ControllerName,Generation,ISNULL( IIF(PackageDependencyFlag = 0,NULL,ParentPackageDependencyName),'') ORDER BY ControllerData.ID) % 2) = 0,'1','0') AS IsEvenFlag
	, 0 AS IsLoadFlag 
	, CASE 
		   WHEN ControllerArea = 'Extract' THEN (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'ExtractControllerPattern')
		   ELSE (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'LoadControllerPattern')
	  END AS ControllerPattern
	, (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameMeta') AS DatabaseName
	, 1 AS IsTransformFlag
FROM 
	ControllerData
WHERE
	ControllerExcludeFlag = 0
	AND SchemaName IN ('dim','bridge','fact')
	AND TableName NOT IN ('Calendar','Time')
	)


SELECT  *
	   ,ControllerName + CASE
							WHEN ControllerArea NOT IN ('Extract','Temp') THEN 
																				CASE
																					WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName, Generation) <= 20 THEN ''
																					WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName, Generation) BETWEEN 21 AND 40 THEN '1'
																					WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName, Generation) BETWEEN 41 AND 60 THEN '2'
																					WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName, Generation) BETWEEN 61 AND 80 THEN '3'
																					WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName, Generation) BETWEEN 81 AND 100 THEN '4'
																					WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName, Generation) BETWEEN 101 AND 120 THEN '5'
																					WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName, Generation) BETWEEN 121 AND 140 THEN '6'
																					WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName, Generation) BETWEEN 141 AND 160 THEN '7'
																					WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName, Generation) BETWEEN 161 AND 180 THEN '8'
																					WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName, Generation) BETWEEN 181 AND 200 THEN '9'
																					ELSE '10'
																				END
							ELSE CASE
									WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName) <= 40 THEN ''
									WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName) BETWEEN 41 AND 80 THEN '1'
									WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName) BETWEEN 81 AND 120 THEN '2'
									WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName) BETWEEN 121 AND 160 THEN '3'
									WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName) BETWEEN 161 AND 200 THEN '4'
									WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName) BETWEEN 201 AND 240 THEN '5'
									WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName) BETWEEN 241 AND 280 THEN '6'
									WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName) BETWEEN 281 AND 320 THEN '7'
									WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName) BETWEEN 321 AND 360 THEN '8'
									WHEN DENSE_RANK() OVER (PARTITION BY ControllerName ORDER BY TableName) BETWEEN 361 AND 400 THEN '9'
									ELSE '10'
								END
						   END AS CloudControllerName
		
FROM Controller
GO
PRINT N'Creating [meta].[TargetObjectDefinitions]...';


GO



















CREATE VIEW [meta].[TargetObjectDefinitions] AS

select 
	flaf.SourceObjectID,
	flaf.SourceConnectionID,
	flaf.SourceConnectionName,
	'templates\Template_Pipeline_' + IIF(TargetIsSqlObject = 1,'Extract_','Target_') 
								   + IIF(TargetAppendDataFlag = 1 OR TargetIncrementalFlag = 1,'Incremental_','Full_') 
								   + IIF(TargetDynamicExtensionDefinition <> '' AND TargetIsFileObject = 1 AND TargetAppendDataFlag = 0 AND TargetAzureSqlDWFlag = 0,'Expression_','')
								   + IIF(TargetIsSqlObject = 1 AND TargetPreserveHistoryFlag = 1,'History_','')
								   + IIF(TargetIsSqlObject = 1 AND IIF(((OneKeyColumnFlag = 1 AND KeyColumnIsNumericFlag = 1 AND EnableAutoParallelizationFlag = 1) OR PartitionFlag = 1) AND SourceNavisionFlag = 0 AND SourceFileExtractFlag = 0, 1,0) = 1,'Parallel_','')
								   + IIF(SourceIsSqlObject = 1 AND TargetIsSqlObject = 0,'Standard_','')
								   + IIF(TargetIsSqlObject = 1,'Standard_','')
								   + IIF(SourceIsFileObject = 1 AND TargetIsSqlObject = 0,'FlatFile_','')
								   + IIF(TargetIsFileObject = 1 AND TargetAzureSqlDWFlag = 1 AND TargetAzureFileTypeName <> 'Avro','SQLDW_','') AS TemplateName,
	flaf.SourceSchemaName,
	IIF(flaf.SourceFileExtractFlag = 1,'FlatFile',flaf.SourceExtractPattern) AS SourceExtractPattern,
	SourceIsFileObject,
	(case when SourceNavisionFlag = 1 then NavisionCompany + '$' + SourceObjectName else SourceObjectName end) as SourceObjectName,
    SourceObjectName AS SourceTableName,
	flaf.SourceFileSystem,
	flaf.SourceFileFolder,
	flaf.SourceFileName,
	flaf.SourceFileExtension,
	flaf.TargetExtractPattern,
	--IIF(flaf.TargetFileExtractFlag = 1 OR flaf.SourceFileExtractFlag = 1,'FlatFile',flaf.TargetExtractPattern) AS TargetExtractPattern,
	flaf.TargetObjectID,
	flaf.TargetExtractSQLFilter,
	flaf.TargetExtractSchemaName,
	flaf.TargetConnectionName,
	flaf.TargetConnectionType,
	flaf.TargetSCD2ExtractFlag,
	'Controller_Extract_' + SourceConnectionName + '_' + (CASE WHEN TargetConnectionType in ('Excel','FlatFile') THEN TargetConnectionType ELSE TargetConnectionName END) as ControllerName,
	isnull(StringColumnFilter + 'Flaf', '*,Flaf') as StringColumnFilter,
	(case when StringColumnFilter is null then 1 else ExtractAllColumnsFlag end) as ExtractAllColumnsFlag,
	lower(TargetFolderName) AS TargetFolderName,
	IIF(TargetAzureFileTypeName = 'DelimitedText','csv',lower(TargetAzureFileTypeName)) AS TargetFileExtension,
	TargetDynamicExtensionDefinition,
	lower(TargetFileSystemName) AS TargetFileSystemName,
	TargetAzureFileTypeName,
	TargetAppendDataFlag,
	TargetFileExtractFlag,
	TargetFileExtensionName,
	SourceObjectName + '_Append_' + REPLACE(TargetFolderName, '/', '') + TargetFileExtensionName AS TargetAppendFileName,
	SourceObjectName + '_Dummy_' + REPLACE(TargetFolderName, '/', '') + TargetFileExtensionName AS TargetDummyFileName,
	IIF(ISNULL(TargetDynamicExtensionDefinition,'') = '' OR TargetAppendDataFlag = 1 OR TargetAzureSqlDWFlag = 1,SourceObjectName + TargetFileExtensionName,CONCAT('@concat(''',SourceObjectName,''',''_'',',TargetDynamicExtensionDefinition,',''',TargetFileExtensionName,''')')) AS TargetFileName,
	SourceNavisionFlag,
	SourceRemoveBracketsFlag,
	NavisionCompany,
	SourceObjectName as NavisionTableName,
	SourceExtractSchemaName + '.' + SourceObjectName as SourceExtractTableName,	
	'[' + SourceExtractSchemaName + '].[' + SourceObjectName + ']' as SourceExtractTableNameWithBrackets,
	'Extract' + SourceConnectionName + '_'+ TargetConnectionName + '_' +  IIF(TargetFileExtractFlag = 1, TargetFileSystemName + '_' + REPLACE(TargetFolderName, '/', '') + '_','') + SourceObjectName as ExtractPackageName,
	TargetIncrementalValueColumnDefinition,
	IIF(TargetIncrementalValueColumnDefinitionInExtract = '',TargetIncrementalValueColumnDefinition,TargetIncrementalValueColumnDefinitionInExtract) AS TargetIncrementalValueColumnDefinitionInExtract,
	TargetIncrementalFlag,	
	TargetRollingWindowDays,
	TargetPreserveHistoryFlag,
	IIF((select VariableValue from meta.[Variables] where VariableName = 'ExtractCCIFlag') = 1, N'1', N'0') as ColumnStoreFlag,
    IIF((select VariableValue from meta.[Variables] where VariableName = 'ExtractCCIHistoryFlag') = 1, N'1', N'0') as ColumnStoreHistoryFlag,
	ISNULL(SQLScript,'') AS SQLScript,
	ISNULL(ConnectionSQLScript,'') AS ConnectionSQLScript,
	ISNULL(CreateTableSQLScript,'') AS CreateTableSQLScript,
	ISNULL(DropTableSQLScript,'') AS DropTableSQLScript,
	ISNULL(AzureDWSQLScript,'') AS AzureDWSQLScript,
	ISNULL(PartitionSQLScript,'') AS PartitionSQLScript,
	TargetIsDateFlag,
	TargetAzureSQLDWName,
	ISNULL(SCD2Columns,'''''') AS SCD2Columns,
	IIF(ISNULL(NavisionCompany,'') = '',NULL,LEFT(NavisionCompanies,LEN(NavisionCompanies) -1)) AS NavisionCompanies,
	(case when SourceNavisionFlag = 1 then '[' + SourceSchemaName + '].[' + NavisionCompany + '$' + SourceObjectName + ']' else SourceSchemaName + '.' + SourceObjectName end) AS SourceTable,
    SourceConnectionName + IIF(SourceFileExtractFlag = 1,'_' + IIF(SourceFileExtension = 'csv','DelimitedText',SourceFileExtension),'') + '_DynamicDataset' AS SourceDatasetName,
    TargetConnectionName + IIF(TargetFileExtractFlag = 1,'_' + TargetAzureFileTypeName,'') + '_DynamicDataset' AS TargetDatasetName,
	(SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameMeta') AS DatabaseName,
	CASE 
		WHEN SourceConnectionType = 'Oracle' THEN 'OracleSource'
		WHEN SourceConnectionType = 'SqlServer' THEN 'SqlSource'
		WHEN SourceConnectionType = 'AzureSqlDatabase' THEN 'SqlSource'
		WHEN SourceConnectionType = 'MySQL' THEN 'RelationalSource'
		WHEN SourceFileExtension = 'csv' THEN 'DelimitedTextSource'
		WHEN SourceFileExtension = 'parquet' THEN 'ParquetSource'
		WHEN SourceFileExtension = 'avro' THEN 'AvroSource'
		WHEN SourceFileExtension = 'orc' THEN 'OrcSource'
		ELSE ''
	END AS ADFCopySourceType,
	CASE TargetConnectionType
		WHEN 'SqlServer' THEN 'SqlSink'
		WHEN 'AzureSqlDatabase' THEN 'SqlSink'
		WHEN 'AzureSqlDW' THEN 'SqlDWSink'
		WHEN 'AzureBlobFS' THEN TargetAzureFileTypeName + 'Sink'
		ELSE ''
	END AS ADFCopyTargetType,
	CASE SourceConnectionType
				WHEN 'AzureSqlDatabase'		THEN 'AzureSqlTable'
				WHEN 'AzureBlobStorage'		THEN 'AzureBlobStorageLocation'
				WHEN 'AzureDataLakeStore'	THEN 'AzureDataLakeStoreLocation'
				WHEN 'AzureBlobFS'			THEN 'AzureBlobFSLocation'
				WHEN 'AzureMySql'			THEN 'AzureMySqlTable'
				WHEN 'AzureFileStorage'		THEN 'AzureFileStorageLocation'
				WHEN 'AzurePostgreSql'		THEN 'AzurePostgreSqlTable'
				WHEN 'SqlServer'			THEN 'SqlServerTable'
				WHEN 'AzureSqlDW'			THEN 'AzureSQLDWDataset'
				WHEN 'AzureSearch'			THEN 'AzureSearchIndex'
				WHEN 'AzureTableStorage'	THEN 'AzureTable'
				WHEN 'AmazonRedshift'		THEN 'RelationalTable'
				WHEN 'Db2'					THEN 'RelationalTable'
				WHEN 'Drill'				THEN 'DrillTable'
				WHEN 'GoogleBigQuery'		THEN 'GoogleBigQueryObject'
				WHEN 'Greenplum'			THEN 'GreenplumTable'
				WHEN 'HBase'				THEN 'HBaseObject'
				WHEN 'Hive'					THEN 'HiveObject'
				WHEN 'Impala'				THEN 'ImpalaObject'
				WHEN 'Odbc'					THEN 'RelationalTable'
				WHEN 'MariaDB'				THEN 'MariaDBTable'
				WHEN 'MySQL'				THEN 'RelationalTable'
				WHEN 'Netezza'				THEN 'NetezzaTable'
				WHEN 'Oracle'				THEN 'OracleTable'
				WHEN 'Phoenix'				THEN 'PhoenixObject'
				WHEN 'PostgreSql'			THEN 'RelationalTable'
				WHEN 'Presto'				THEN 'PrestoObject'
				WHEN 'SapBw'				THEN 'RelationalTable'
				WHEN 'SapHana'				THEN 'RelationalTable'
				WHEN 'Spark'				THEN 'SparkObject'
				WHEN 'Sybase'				THEN 'RelationalTable'
				WHEN 'Teradata'				THEN 'RelationalTable'
				WHEN 'Vertica'				THEN 'VerticaTable'
				WHEN 'Cassandra'			THEN 'CassandraTable'
				WHEN 'Couchbase'			THEN 'CouchbaseTable'
				WHEN 'MongoDb'				THEN 'MongoDbCollection'
				WHEN 'AmazonS3'				THEN 'AmazonS3Location'
				WHEN 'FileServer'			THEN 'FileServerLocation'
				WHEN 'FtpServer'			THEN 'FtpServerLocation'
				WHEN 'Hdfs'					THEN 'HdfsLocation'
				WHEN 'Sftp'					THEN 'SftpLocation'
				WHEN 'HttpServer'			THEN 'HttpServerLocation'
				WHEN 'Odata'				THEN 'ODataResource'
				WHEN 'Odbc'					THEN 'RelationalTable'
				ELSE ''
		END AS SourceObjectType,
	CASE TargetConnectionType
				WHEN 'AzureSqlDatabase'		THEN 'AzureSqlTable'
				WHEN 'AzureBlobFS'			THEN 'AzureBlobFSLocation'
				WHEN 'AzureSqlDW'			THEN 'AzureSQLDWDataset'
				ELSE ''
		END AS TargetObjectType,
	CASE SourceConnectionType
				WHEN 'AzureSqlDatabase'		THEN 'sqlReaderQuery'
				WHEN 'AzureBlobStorage'		THEN 'AzureBlob'
				WHEN 'AzureDataLakeStore'	THEN 'AzureDataLakeStoreFile'
				WHEN 'AzureBlobFS'			THEN 'AzureBlobFSFile'
				WHEN 'AzureMySql'			THEN 'query'
				WHEN 'AzurePostgreSql'		THEN 'query'
				WHEN 'SqlServer'			THEN 'sqlReaderQuery'
				WHEN 'AzureSqlDW'			THEN 'sqlReaderQuery'
				WHEN 'AzureSearch'			THEN 'AzureSearchIndex'
				WHEN 'AzureTableStorage'	THEN 'azureTableSourceQuery'
				WHEN 'AmazonRedshift'		THEN 'query'
				WHEN 'Db2'					THEN 'query'
				WHEN 'Drill'				THEN 'query'
				WHEN 'GoogleBigQuery'		THEN 'query'
				WHEN 'Greenplum'			THEN 'query'
				WHEN 'HBase'				THEN 'query'
				WHEN 'Hive'					THEN 'query'
				WHEN 'Impala'				THEN 'query'
				WHEN 'Odbc'					THEN 'query'
				WHEN 'MariaDB'				THEN 'query'
				WHEN 'MySQL'				THEN 'query'
				WHEN 'Netezza'				THEN 'query'
				WHEN 'Oracle'				THEN 'oracleReaderQuery'
				WHEN 'Phoenix'				THEN 'query'
				WHEN 'PostgreSql'			THEN 'query'
				WHEN 'Presto'				THEN 'query'
				WHEN 'SapBw'				THEN 'query'
				WHEN 'SapHana'				THEN 'query'
				WHEN 'Spark'				THEN 'query'
				WHEN 'Sybase'				THEN 'query'
				WHEN 'Teradata'				THEN 'query'
				WHEN 'Vertica'				THEN 'query'
				WHEN 'Cassandra'			THEN 'query'
				WHEN 'Couchbase'			THEN 'query'
				WHEN 'MongoDb'				THEN 'query'
				WHEN 'AmazonS3'				THEN 'AmazonS3Object'
				WHEN 'FileServer'			THEN 'FileShare'
				WHEN 'FtpServer'			THEN 'FileShare'
				WHEN 'Hdfs'					THEN 'FileShare'
				WHEN 'Sftp'					THEN 'FileShare'
				WHEN 'HttpServer'			THEN 'HttpFile'
				WHEN 'Odata'				THEN 'query'
				WHEN 'Odbc'					THEN 'query'
				ELSE ''
		END AS SourceAzureSQLType,
	TargetAzureSqlDWFlag,
	IIF(SourceConnectionType IN ('AzureBlobStorage','AzureDataLakeStore','AzureBlobFS','AzureFileStorage'),'FlatFile','Standard') AS SourceDatasetPattern,
	IIF(TargetConnectionType IN ('AzureBlobStorage','AzureDataLakeStore','AzureBlobFS'),'FlatFile','Standard') AS TargetDatasetPattern,
	IIF(((OneKeyColumnFlag = 1 AND KeyColumnIsNumericFlag = 1 AND EnableAutoParallelizationFlag = 1) OR PartitionFlag = 1) AND SourceNavisionFlag = 0, 1,0) AS ParallelizationFlag,
	PartitionFlag,
	UseModulusFlag,
	PartitionValueColumnDefinition
from 
	(
		select
			TargetObjects.*,
			IIF(SourceConnectionType IN (
			'FileServer'
			,'FtpServer'
			,'Hdfs'
			,'Sftp'
			,'AzureBlobStorage'
			,'AzureDataLakeStore'
			,'AzureBlobFS'
			,'AzureFileStorage'
			), 1, 0) AS SourceIsFileObject,
			IIF(SourceConnectionType IN (
			'AzureSqlDatabase'
			,'SqlServer'
			,'Oracle'
			,'AzureMySql'			
			,'AzurePostgreSql'		
			,'SqlServer'
			,'Db2'					
			), 1, 0) AS SourceIsSqlObject,
		   IIF(TargetConnectionType IN ('AzureBlobStorage' 
				,'AzureDataLakeStore'
				,'AzureBlobFS'),1,0) AS TargetIsFileObject,
		   IIF(TargetConnectionType IN ('AzureSqlDatabase'),1,0) AS TargetIsSqlObject,		
			NavisionCompany.CompanyName AS NavisionCompany,
			NavisionCompany.NavisionCompanies,
			StringColumnFilter = stuff(
				(
					select 
						'' + ltrim(rtrim(ColumnName)) + ',' 
					from 
						meta.SourceColumns
					where 
						SourceObjectID = TargetObjects.SourceObjectID
					for XML PATH(''), TYPE
				).value('.[1]', 'nvarchar(max)'), 
				1, 
				0, 
				''
			),
			SCD2Columns = stuff(
				(
					select 
						'' + ltrim(rtrim(SCD2ColumnName)) + ',' 
					from 
						meta.TargetObjectSCD2Setup
					where 
						TargetObjectID = TargetObjects.TargetObjectID
					for XML PATH(''), TYPE
				).value('.[1]', 'nvarchar(max)'), 
				1, 
				0, 
				''
			),
			(case when AllColumns.SourceObjectID is not null then 1 else 0 end) as ExtractAllColumnsFlag,
			(SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DefaultMaxDop') AS DefaultMaxDop,
			(SELECT VariableValue FROM meta.Variables WHERE VariableName = 'EnableAutoPartitionFlag') AS EnableAutoParallelizationFlag
		
		from 
			(
				select 
					sourceobj.ID AS SourceObjectID,
					sourceobj.SourceConnectionID,
					sourcecon.ConnectionType AS SourceConnectionType,
					sourcecon.Name AS SourceConnectionName,
					sourcecon.ExtractSchemaName AS SourceExtractSchemaName,
					sourceobj.ObjectName AS SourceObjectName,
					sourceobj.SchemaName AS SourceSchemaName,
					sourceobj.ExtractPattern AS SourceExtractPattern,
					sourceobj.ExtractSQLFilter AS SourceExtractFilter,
					sourceobj.FileExtractFlag AS SourceFileExtractFlag,
					sourcecon.NavisionFlag,
					isnull(sourcefilesetup.FileSystem,'') AS SourceFileSystem,
					isnull(sourcefilesetup.Folder,'') AS SourceFileFolder,
					isnull(sourcefilesetup.FileName,'') AS SourceFileName,
					isnull(sourcefilesetup.FileExtension,'') AS SourceFileExtension,
					targetobj.ID AS TargetObjectID,
					targetobj.TargetConnectionID,
					targetobj.ExtractPattern AS TargetExtractPattern,
					targetobj.ExtractSQLFilter AS TargetExtractSQLFilter,
					targetobj.PreserveHistoryFlag AS TargetPreserveHistoryFlag,
					targetobj.IncrementalFlag AS TargetIncrementalFlag,
					targetobj.SCD2ExtractFlag AS TargetSCD2ExtractFlag,
					targetobj.FileTargetFlag AS TargetFileExtractFlag,
					targetobj.AzureSqlDWFlag AS TargetAzureSqlDWFlag,
					targetobj.ControllerExcludeFlag AS TargetControllerExcludeFlag,
					targetfilesetup.FolderName AS TargetFolderName,
					targetfilesetup.FileSystemName AS TargetFileSystemName,
					targetfilesetup.FileDynamicExtensionDefinition AS TargetDynamicExtensionDefinition,					
					targetfilesetup.AzureFileTypeName AS TargetAzureFileTypeName,
					CASE targetfilesetup.AzureFileTypeName
						WHEN 'DelimitedText' THEN '.csv'
						WHEN 'Parquet'		 THEN '.parquet'
						WHEN 'Json'			 THEN '.json'
						WHEN 'Avro'			 THEN '.avro'
						WHEN 'Orc'			 THEN '.orc'
						ELSE ''
					END	AS TargetFileExtensionName,
					targetfilesetup.AppendDataFlag AS TargetAppendDataFlag,
					IIF(targetobj.AzureSqlDWFlag = 1, 'extadl' + lower(targetfilesetup.FileSystemName) + lower(replace(targetfilesetup.FolderName,'/','_')),sourcecon.ExtractSchemaName) AS TargetExtractSchemaName,
					targetcon.[Name] AS TargetConnectionName,
					targetcon.ConnectionType AS TargetConnectionType,
					ISNULL(sourcecon.NavisionFlag,0) AS SourceNavisionFlag,
					targetincrementalsetup.IncrementalValueColumnDefinition AS TargetIncrementalValueColumnDefinition,
					targetincrementalsetup.IncrementalValueColumnDefinitionInExtract AS TargetIncrementalValueColumnDefinitionInExtract,
					targetincrementalsetup.IsDateFlag AS TargetIsDateFlag,			
					targetincrementalsetup.RollingWindowDays AS TargetRollingWindowDays,					
					ISNULL(sourcecon.RemoveBracketsFlag,0) AS SourceRemoveBracketsFlag,
					biml.SQLScript,
					biml.ConnectionSQLScript,
					biml.CreateTableSQLScript,
					biml.DropTableSQLScript,
					biml.AzureDWSQLScript,
					SourceBiml.PartitionSQLScript,
					sourceobj.PartitionFlag,
					AzureSqlDW.Name AS TargetAzureSqlDWName,
					ISNULL((SELECT TOP 1 UseModulusFlag FROM meta.SourceObjectPartition WHERE SourceObjectPartition.SourceObjectID = targetobj.SourceObjectID ORDER BY UseModulusFlag DESC),0) AS UseModulusFlag,
					(SELECT TOP 1 PartitionValueColumnDefinition FROM meta.SourceObjectPartition WHERE SourceObjectPartition.SourceObjectID = targetobj.SourceObjectID ORDER BY UseModulusFlag DESC) AS PartitionValueColumnDefinition,
					IIF((SELECT SUM(KeySequenceNumber) AS KeySequenceNumber FROM meta.ExtractInformationSchemaDefinitions WHERE KeySequenceNumber = 1 AND SourceObjectID = sourceobj.ID AND ColumnName NOT IN ('DWNavisionCompany')) = 1,1,0) AS OneKeyColumnFlag,
					IIF((SELECT DataTypeName FROM meta.ExtractInformationSchemaDefinitions WHERE KeySequenceNumber = 1 AND SourceObjectID = sourceobj.ID) in ('int','tinyint','decimal','numeric'),1,0) AS KeyColumnIsNumericFlag

					
				from 
					meta.[SourceObjects] as sourceobj inner join
					meta.TargetObjects as targetobj on
						targetobj.SourceObjectID = sourceobj.ID left join
					meta.SourceObjectFileSetup as sourcefilesetup on
						sourceobj.ID = sourcefilesetup.SourceObjectID left join 
					meta.[TargetObjectFileSetup] as targetfilesetup on 
						targetobj.ID = targetfilesetup.TargetObjectID left join
					meta.[SourceObjectIncrementalSetup] as targetincrementalsetup on 
						targetobj.SourceObjectID = targetincrementalsetup.SourceObjectID join
					meta.TargetConnections as targetcon on 
						targetobj.TargetConnectionID = targetcon.ID inner join
					meta.SourceConnections as sourcecon on
						sourcecon.ID = sourceobj.SourceConnectionID left join
					meta.FrameworkMetaData as Biml on
						biml.TargetObjectID = targetobj.ID left join		
					meta.FrameworkMetaData as SourceBiml on
						SourceBiml.SourceObjectID = targetobj.SourceObjectID left join
					meta.TargetAzureSQLDWSetup as AzureSqlDWSetup on
						targetobj.ID = AzureSqlDWSetup.TargetObjectID left join
					meta.TargetConnections as AzureSqlDW on
						AzureSqlDW.ID = AzureSqlDWSetup.TargetConnectionID 				
				where
					targetobj.ExcludeFlag = 0 and
					targetcon.ExcludeFlag = 0 -- and
					--obj.ID = (select distinct SourceObjectID from etl.SourceColumns where SourceObjectID = obj.ID) /* Exclude items that have not been entered in SourceColumns */

			) as TargetObjects left join

			-- Source objects where all columns are wanted - *
			(
				select 
					distinct 
					SourceObjectID
				from 
					meta.SourceColumns as col
				where
					[ColumnName] = '*'
			) as AllColumns on 
				TargetObjects.SourceObjectID = AllColumns.SourceObjectID left join

			-- If any Navision tables present
			(
				select 
					SourceConnectionID,
					CompanyName, 
					row_number() over (partition by SourceConnectionID order by SourceConnectionNavisionSetup.ID asc) as rnk,
					NavisionCompanies = stuff(
										(
											select 
												'' + ltrim(rtrim(CompanyName)) + ','  
											from 
												meta.SourceConnectionNavisionSetup scn 
											inner join 
												meta.SourceConnections sc 
													on scn.SourceConnectionID = sc.ID 
											where 
												ExtractFlag = 1 
												and sc.Name = SourceConnections.Name
											for XML PATH(''), TYPE
										).value('.[1]', 'nvarchar(max)'), 
										1, 
										0, 
										''
									   )
				from 
					meta.SourceConnectionNavisionSetup
				inner join
					meta.SourceConnections
						ON SourceConnections.ID = SourceConnectionNavisionSetup.SourceConnectionID
				where
					ExtractFlag = 1
			) as NavisionCompany on 
				TargetObjects.SourceConnectionID = NavisionCompany.SourceConnectionID and
				TargetObjects.SourceNavisionFlag = 1 and 
				NavisionCompany.rnk = 1 



	) as flaf
GO
PRINT N'Creating [meta].[SourceObjectDefinitions]...';


GO















CREATE VIEW [meta].[SourceObjectDefinitions] AS

select 
	SourceObjectID,
	SourceConnectionID,
	flaf.SchemaName,
	'templates\Template_Pipeline_Extract_' + IIF(IncrementalFlag = 1,'Incremental_','Full_') 
										   + IIF(PreserveHistoryFlag = 1,'History_','')
										   + IIF(((OneKeyColumnFlag = 1 AND KeyColumnIsNumericFlag = 1 AND EnableAutoParallelizationFlag = 1) OR PartitionFlag = 1) AND NavisionFlag = 0 AND FileExtractFlag = 0,'Parallel_','')
										   + 'Standard_' AS TemplateName,
	(case when NavisionFlag = 1 then NavisionCompany + '$' + ObjectName else ObjectName end) as ObjectName,
	ObjectName as Name,
	flaf.ExtractPattern,
	flaf.ExtractSQLFilter,
	flaf.KeyColumnFlag,
	flaf.InitialCatalog,
	flaf.ConnectionString,
	flaf.ExtractSchemaName,
	flaf.ConnectionName,
	flaf.ConnectionType,
    SourceIsFileObject, 
	IIF(ConnectionType IN ('AzureBlobStorage','AzureDataLakeStore','AzureBlobFS','AzureFileStorage'
	),'FlatFile','Standard') AS SourceDatasetPattern,
	'Controller_Extract' + (case when flaf.ConnectionType IN ('Excel','FlatFile') then flaf.ConnectionType else flaf.ConnectionName end) as ControllerName,
	isnull(StringColumnFilter + 'Flaf', '*,Flaf') as StringColumnFilter,
	(case when StringColumnFilter is null then 1 else ExtractAllColumnsFlag end) as ExtractAllColumnsFlag,
	LoopFileFlag as LoopFile,
	FileSystem,
	FileName,
	Folder,
	FileExtension,
	FileSpecification,
	FileName + '.' + FileExtension AS FullFileName,
	RowSeparator,
	ColumnDelimiter,
	ISNULL(TextQualifier,'') AS TextQualifier,
	IsHeaderPresent,
	Encoding,
	PreserveHistoryFlag,
	DataSource,
	NavisionFlag,
	RemoveBracketsFlag,
	NavisionCompany,
	ObjectName as NavisionTableName,
	ExtractSchemaName + '.' + ObjectName as ExtractTableName,	
	'[' + ExtractSchemaName + '].[' + ObjectName + ']' as ExtractTableNameWithBrackets,
	'Extract' + ExtractSchemaName + '_' + ObjectName as ExtractPackageName,
	IncrementalValueColumnDefinition,
	IIF(IncrementalValueColumnDefinitionInExtract = '',IncrementalValueColumnDefinition,IncrementalValueColumnDefinitionInExtract) AS IncrementalValueColumnDefinitionInExtract,
	IncrementalFlag,	
	iif((Select compatibility_level from sys.databases where name COLLATE DANISH_NORWEGIAN_CI_AS = (select VariableValue from meta.[Variables] where VariableName = 'DatabaseNameExtract')) > 120
		AND (select VariableValue from meta.[Variables] where VariableName = 'ExtractCCIFlag') = 1, N'1', N'0') as ColumnStoreFlag,
	iif((Select compatibility_level from sys.databases where name  COLLATE DANISH_NORWEGIAN_CI_AS = (select VariableValue from meta.[Variables] where VariableName = 'DatabaseNameExtract')) > 120
		AND (select VariableValue from meta.[Variables] where VariableName = 'ExtractCCIHistoryFlag') = 1, N'1', N'0') as ColumnStoreHistoryFlag,
	SQLScript,
	PartitionSQLScript,
	IsDateFlag,
	RollingWindowDays,
	FileExtractFlag,
	ISNULL(SCD2Columns,'''''') AS SCD2Columns,
	IIF(ISNULL(NavisionCompany,'') = '',NULL,LEFT(NavisionCompanies,LEN(NavisionCompanies) -1)) AS NavisionCompanies,
    (case when NavisionFlag = 1 then '[' + SchemaName + '].[' + NavisionCompany + '$' + ObjectName + ']' else SchemaName + '.' + ObjectName end) AS SourceTable,
	ConnectionName + IIF(FileExtractFlag = 1,'_' + CASE FileExtension 
														WHEN 'csv' THEN 'DelimitedText'
														WHEN 'orc' THEN 'Orc'
														WHEN 'avro' THEN 'Avro'
														WHEN 'parquet' THEN 'Parquet'
												   END ,'') + '_DynamicDataset' AS SourceDatasetName,
    (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameMeta') + '_DynamicDataset' AS DestinationDatasetName,
	(SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameMeta') AS DatabaseName,
	CASE 
		WHEN ConnectionType = 'Oracle' THEN 'OracleSource'
		WHEN ConnectionType = 'SqlServer' THEN 'SqlSource'
		WHEN ConnectionType = 'AzureSqlDatabase' THEN 'SqlSource'
		WHEN ConnectionType = 'MySQL' THEN 'RelationalSource'
		WHEN FileExtension = 'csv' THEN 'DelimitedTextSource'
		WHEN FileExtension = 'parquet' THEN 'ParquetSource'
		WHEN FileExtension = 'avro' THEN 'AvroSource'
		WHEN FileExtension = 'orc' THEN 'OrcSource'
		ELSE ''
	END AS ADFCopySourceType,
	CASE ConnectionType
				WHEN 'AzureSqlDatabase'		THEN 'AzureSqlTable'
				WHEN 'AzureBlobStorage'		THEN 'AzureBlobStorageLocation'
				WHEN 'AzureDataLakeStore'	THEN 'AzureDataLakeStoreLocation'
				WHEN 'AzureBlobFS'			THEN 'AzureBlobFSLocation'
				WHEN 'AzureMySql'			THEN 'AzureMySqlTable'
				WHEN 'AzureFileStorage'     THEN 'AzureFileStorageLocation'
				WHEN 'AzurePostgreSql'		THEN 'AzurePostgreSqlTable'
				WHEN 'SqlServer'			THEN 'SqlServerTable'
				WHEN 'AzureSqlDW'			THEN 'AzureSQLDWDataset'
				WHEN 'AzureSearch'			THEN 'AzureSearchIndex'
				WHEN 'AzureTableStorage'	THEN 'AzureTable'
				WHEN 'AmazonRedshift'		THEN 'RelationalTable'
				WHEN 'Db2'					THEN 'RelationalTable'
				WHEN 'Drill'				THEN 'DrillTable'
				WHEN 'GoogleBigQuery'		THEN 'GoogleBigQueryObject'
				WHEN 'Greenplum'			THEN 'GreenplumTable'
				WHEN 'HBase'				THEN 'HBaseObject'
				WHEN 'Hive'					THEN 'HiveObject'
				WHEN 'Impala'				THEN 'ImpalaObject'
				WHEN 'Odbc'					THEN 'RelationalTable'
				WHEN 'MariaDB'				THEN 'MariaDBTable'
				WHEN 'MySQL'				THEN 'RelationalTable'
				WHEN 'Netezza'				THEN 'NetezzaTable'
				WHEN 'Oracle'				THEN 'OracleTable'
				WHEN 'Phoenix'				THEN 'PhoenixObject'
				WHEN 'PostgreSql'			THEN 'RelationalTable'
				WHEN 'Presto'				THEN 'PrestoObject'
				WHEN 'SapBw'				THEN 'RelationalTable'
				WHEN 'SapHana'				THEN 'RelationalTable'
				WHEN 'Spark'				THEN 'SparkObject'
				WHEN 'Sybase'				THEN 'RelationalTable'
				WHEN 'Teradata'				THEN 'RelationalTable'
				WHEN 'Vertica'				THEN 'VerticaTable'
				WHEN 'Cassandra'			THEN 'CassandraTable'
				WHEN 'Couchbase'			THEN 'CouchbaseTable'
				WHEN 'MongoDb'				THEN 'MongoDbCollection'
				WHEN 'AmazonS3'				THEN 'AmazonS3Location'
				WHEN 'FileServer'			THEN 'FileServerLocation'
				WHEN 'FtpServer'			THEN 'FtpServerLocation'
				WHEN 'Hdfs'					THEN 'HdfsLocation'
				WHEN 'Sftp'					THEN 'SftpLocation'
				WHEN 'HttpServer'			THEN 'HttpServerLocation'
				WHEN 'Odata'				THEN 'ODataResource'
				WHEN 'Odbc'					THEN 'RelationalTable'
				ELSE ''
		END AS ObjectType,
	CASE ConnectionType
				WHEN 'AzureSqlDatabase'		THEN 'sqlReaderQuery'
				WHEN 'AzureBlobStorage'		THEN 'AzureBlob'
				WHEN 'AzureDataLakeStore'	THEN 'AzureDataLakeStoreFile'
				WHEN 'AzureBlobFS'			THEN 'AzureBlobFSFile'
				WHEN 'AzureMySql'			THEN 'query'
				WHEN 'AzurePostgreSql'		THEN 'query'
				WHEN 'SqlServer'			THEN 'sqlReaderQuery'
				WHEN 'AzureSqlDW'			THEN 'sqlReaderQuery'
				WHEN 'AzureSearch'			THEN 'AzureSearchIndex'
				WHEN 'AzureTableStorage'	THEN 'azureTableSourceQuery'
				WHEN 'AmazonRedshift'		THEN 'query'
				WHEN 'Db2'					THEN 'query'
				WHEN 'Drill'				THEN 'query'
				WHEN 'GoogleBigQuery'		THEN 'query'
				WHEN 'Greenplum'			THEN 'query'
				WHEN 'HBase'				THEN 'query'
				WHEN 'Hive'					THEN 'query'
				WHEN 'Impala'				THEN 'query'
				WHEN 'Odbc'					THEN 'query'
				WHEN 'MariaDB'				THEN 'query'
				WHEN 'MySQL'				THEN 'query'
				WHEN 'Netezza'				THEN 'query'
				WHEN 'Oracle'				THEN 'oracleReaderQuery'
				WHEN 'Phoenix'				THEN 'query'
				WHEN 'PostgreSql'			THEN 'query'
				WHEN 'Presto'				THEN 'query'
				WHEN 'SapBw'				THEN 'query'
				WHEN 'SapHana'				THEN 'query'
				WHEN 'Spark'				THEN 'query'
				WHEN 'Sybase'				THEN 'query'
				WHEN 'Teradata'				THEN 'query'
				WHEN 'Vertica'				THEN 'query'
				WHEN 'Cassandra'			THEN 'query'
				WHEN 'Couchbase'			THEN 'query'
				WHEN 'MongoDb'				THEN 'query'
				WHEN 'AmazonS3'				THEN 'AmazonS3Object'
				WHEN 'FileServer'			THEN 'FileShare'
				WHEN 'FtpServer'			THEN 'FileShare'
				WHEN 'Hdfs'					THEN 'FileShare'
				WHEN 'Sftp'					THEN 'FileShare'
				WHEN 'HttpServer'			THEN 'HttpFile'
				WHEN 'Odata'				THEN 'query'
				WHEN 'Odbc'					THEN 'query'
				ELSE ''
		END AS AzureSQLType,
	TruncateBeforeDeployFlag,
	IIF(((OneKeyColumnFlag = 1 AND KeyColumnIsNumericFlag = 1 AND EnableAutoParallelizationFlag = 1) OR PartitionFlag = 1) AND NavisionFlag = 0, 1,0) AS ParallelizationFlag,
	PartitionFlag,
	UseModulusFlag,
	PartitionValueColumnDefinition,
	DWDestinationFlag,
	TargetDestinationFlag
from 
	(
		select
			ID as SourceObjectID,
			SchemaName, 
			ObjectName, 
			ExtractPattern,
			IIF(ConnectionType IN (
			'FileServer'
			,'FtpServer'
			,'Hdfs'
			,'Sftp'
			,'AzureBlobStorage'
			,'AzureDataLakeStore'
			,'AzureBlobFS'
			,'AzureFileStorage'
			), 1, 0) AS SourceIsFileObject,
			IIF(ConnectionType IN (
			'AzureSqlDatabase'
			,'SqlServer'
			,'Oracle'
			,'AzureMySql'			
			,'AzurePostgreSql'		
			,'SqlServer'
			,'Db2'					
			), 1, 0) AS SourceIsSqlObject,
			InitialCatalog,
			ConnectionString,
			ExtractSchemaName,
			DWDestinationFlag,
			TargetDestinationFlag,
			KeyColumnFlag,
			FileExtractFlag,
			ConnectionName,
			ConnectionType,
			ExtractSQLFilter,
			LoopFileFlag,
			FileSystem,
			Folder,
			FileName,
			FileExtension,
			FileSpecification,
			RowSeparator,
			ColumnDelimiter,
			TextQualifier,
			IsHeaderPresent,	
			Encoding,
			PreserveHistoryFlag,
			DataSource,
			StringColumnFilter = stuff(
				(
					select 
						'' + ltrim(rtrim(ColumnName)) + ',' 
					from 
						meta.SourceColumns
					where 
						SourceObjectID = SourceObjects.ID
					for XML PATH(''), TYPE
				).value('.[1]', 'nvarchar(max)'), 
				1, 
				0, 
				''
			),
			SCD2Columns = stuff(
				(
					select 
						'' + ltrim(rtrim(SCD2ColumnName)) + ',' 
					from 
						meta.SourceObjectSCD2Setup
					where 
						SourceObjectID = SourceObjects.ID
					for XML PATH(''), TYPE
				).value('.[1]', 'nvarchar(max)'), 
				1, 
				0, 
				''
			),
			(case when AllColumns.SourceObjectID is not null then 1 else 0 end) as ExtractAllColumnsFlag,
			isnull(NavisionFlag, 0) as NavisionFlag,
			isnull(RemoveBracketsFlag, 0) as RemoveBracketsFlag,
			isnull(CompanyName, '') as NavisionCompany,
			isnull(IncrementalValueColumnDefinition, '') as IncrementalValueColumnDefinition,
			isnull(IncrementalValueColumnDefinitionInExtract, '') as IncrementalValueColumnDefinitionInExtract,
			RollingWindowDays,
			isnull(IncrementalFlag, 0) as IncrementalFlag,
			SQLScript,
			PartitionSQLScript,
			IsDateFlag,
			NavisionCompanies,
			SourceObjects.SourceConnectionID,
			TruncateBeforeDeployFlag,
			OneKeyColumnFlag,
			KeyColumnIsNumericFlag,
			PartitionFlag,
			ISNULL(UseModulusFlag,0) AS UseModulusFlag,
			PartitionValueColumnDefinition,
			(SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DefaultMaxDop') AS DefaultMaxDop,
			(SELECT VariableValue FROM meta.Variables WHERE VariableName = 'EnableAutoPartitionFlag') AS EnableAutoParallelizationFlag
		from 
			(
				select 
					obj.ID,
					obj.SourceConnectionID,
					obj.ObjectName,
					obj.SchemaName,
					obj.ExtractPattern,
					obj.ExtractSQLFilter,
					obj.DWDestinationFlag,
					obj.TargetDestinationFlag,
					obj.KeyColumnFlag,
					obj.FileExtractFlag,
					file_setup.LoopFileFlag,
					file_setup.FileSystem,
					file_setup.Folder,
					file_setup.FileName,
					file_setup.FileExtension,
					file_setup.FileSpecification,
					file_setup.RowSeparator,
					file_setup.ColumnDelimiter,
					file_setup.TextQualifier,
					file_setup.IsHeaderPresent,	
					file_setup.Encoding,	
					obj.PreserveHistoryFlag,
					con.InitialCatalog,
					con.ConnectionString,
					con.ExtractSchemaName,
					con.[Name] as ConnectionName,
					con.ConnectionType,
					con.DataSource,
					con.NavisionFlag,
					incremental_setup.IncrementalValueColumnDefinition,
					incremental_setup.IncrementalValueColumnDefinitionInExtract,
					incremental_setup.RollingWindowDays,
					obj.IncrementalFlag,
					con.RemoveBracketsFlag,
					biml.SQLScript,
					biml.PartitionSQLScript,
					incremental_setup.IsDateFlag,
					obj.TruncateBeforeDeployFlag,
					obj.PartitionFlag,
					(SELECT TOP 1 UseModulusFlag FROM meta.SourceObjectPartition WHERE SourceObjectPartition.SourceObjectID = obj.ID ORDER BY UseModulusFlag DESC) AS UseModulusFlag,
					(SELECT TOP 1 PartitionValueColumnDefinition FROM meta.SourceObjectPartition WHERE SourceObjectPartition.SourceObjectID = obj.ID ORDER BY UseModulusFlag DESC) AS PartitionValueColumnDefinition,
					IIF((SELECT SUM(KEY_COLUMN_USAGE.ORDINAL_POSITION) AS KeySequenceNumber FROM INFORMATION_SCHEMA.COLUMNS INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS ON TABLE_CONSTRAINTS.TABLE_CATALOG = COLUMNS.TABLE_CATALOG  AND TABLE_CONSTRAINTS.TABLE_SCHEMA = COLUMNS.TABLE_SCHEMA	AND TABLE_CONSTRAINTS.TABLE_NAME = COLUMNS.TABLE_NAME AND TABLE_CONSTRAINTS.CONSTRAINT_TYPE = 'PRIMARY KEY' INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE ON KEY_COLUMN_USAGE.CONSTRAINT_NAME = TABLE_CONSTRAINTS.CONSTRAINT_NAME AND KEY_COLUMN_USAGE.COLUMN_NAME = COLUMNS.COLUMN_NAME AND KEY_COLUMN_USAGE.TABLE_SCHEMA = COLUMNS.TABLE_SCHEMA WHERE COLUMNS.TABLE_SCHEMA  COLLATE DANISH_NORWEGIAN_CI_AS = con.ExtractSchemaName AND COLUMNS.TABLE_NAME  COLLATE DANISH_NORWEGIAN_CI_AS = obj.[ObjectName] AND TABLE_CONSTRAINTS.CONSTRAINT_TYPE = 'PRIMARY KEY' AND COLUMNS.COLUMN_NAME NOT IN ('DWNavisionCompany')) = 1,1,0) AS OneKeyColumnFlag,
					IIF((SELECT COLUMNS.[DATA_TYPE] FROM INFORMATION_SCHEMA.COLUMNS INNER JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS ON TABLE_CONSTRAINTS.TABLE_CATALOG = COLUMNS.TABLE_CATALOG  AND TABLE_CONSTRAINTS.TABLE_SCHEMA = COLUMNS.TABLE_SCHEMA	AND TABLE_CONSTRAINTS.TABLE_NAME = COLUMNS.TABLE_NAME AND TABLE_CONSTRAINTS.CONSTRAINT_TYPE = 'PRIMARY KEY' INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE ON KEY_COLUMN_USAGE.CONSTRAINT_NAME = TABLE_CONSTRAINTS.CONSTRAINT_NAME AND KEY_COLUMN_USAGE.COLUMN_NAME = COLUMNS.COLUMN_NAME AND KEY_COLUMN_USAGE.TABLE_SCHEMA = COLUMNS.TABLE_SCHEMA WHERE COLUMNS.TABLE_SCHEMA  COLLATE DANISH_NORWEGIAN_CI_AS = con.ExtractSchemaName AND COLUMNS.TABLE_NAME  COLLATE DANISH_NORWEGIAN_CI_AS = obj.[ObjectName] AND TABLE_CONSTRAINTS.CONSTRAINT_TYPE = 'PRIMARY KEY' AND KEY_COLUMN_USAGE.ORDINAL_POSITION = 1) in ('int','tinyint','decimal','numeric'),1,0) AS KeyColumnIsNumericFlag

				from 
					meta.[SourceObjects] as obj left join
					meta.[SourceObjectFileSetup] as file_setup on 
						obj.ID = file_setup.SourceObjectID left join
					meta.[SourceObjectIncrementalSetup] as incremental_setup on 
						obj.ID = incremental_setup.SourceObjectID join
					meta.SourceConnections as con on 
						obj.SourceConnectionID = con.ID left join
					meta.FrameworkMetaData as Biml on
						biml.SourceObjectID = obj.ID
						
				where
					obj.ExcludeFlag = 0 and
					con.ExcludeFlag = 0 -- and
					--obj.ID = (select distinct SourceObjectID from etl.SourceColumns where SourceObjectID = obj.ID) /* Exclude items that have not been entered in SourceColumns */

			) as SourceObjects left join

			-- Source objects where all columns are wanted - *
			(
				select 
					distinct 
					SourceObjectID
				from 
					meta.SourceColumns as col
				where
					[ColumnName] = '*'
			) as AllColumns on 
				SourceObjects.ID = AllColumns.SourceObjectID left join

			-- If any Navision tables present
			(
				select 
					SourceConnectionID,
					CompanyName, 
					row_number() over (partition by SourceConnectionID order by SourceConnectionNavisionSetup.ID asc) as rnk,
					NavisionCompanies = stuff(
										(
											select 
												'' + ltrim(rtrim(CompanyName)) + ','  
											from 
												meta.SourceConnectionNavisionSetup scn 
											inner join 
												meta.SourceConnections sc 
													on scn.SourceConnectionID = sc.ID 
											where 
												ExtractFlag = 1 
												and sc.Name = SourceConnections.Name
											for XML PATH(''), TYPE
										).value('.[1]', 'nvarchar(max)'), 
										1, 
										0, 
										''
									   )
				from 
					meta.SourceConnectionNavisionSetup
				inner join
					meta.SourceConnections
						ON SourceConnections.ID = SourceConnectionNavisionSetup.SourceConnectionID
				where
					ExtractFlag = 1
			) as NavisionCompany on 
				SourceObjects.SourceConnectionID = NavisionCompany.SourceConnectionID and
				SourceObjects.NavisionFlag = 1 and 
				NavisionCompany.rnk = 1

	) as flaf
GO
PRINT N'Creating [meta].[SourceObjectKeyColumnDefinitions]...';


GO




CREATE VIEW [meta].[SourceObjectKeyColumnDefinitions] AS 
SELECT 
       SourceObjectDefinitions.ConnectionName
	  ,SourceObjectDefinitions.ObjectName
	  ,SourceObjectKeyColumns.[SourceObjectID]
      ,SourceObjectKeyColumns.[SourceObjectKeyColumnName]
  FROM 
	meta.[SourceObjectKeyColumns]
  INNER JOIN
	meta.SourceObjectDefinitions
		ON SourceObjectDefinitions.SourceObjectID = SourceObjectKeyColumns.SourceObjectID
  WHERE
	SourceObjectDefinitions.KeyColumnFlag = 1
GO
PRINT N'Creating [meta].[GetVariableValue]...';


GO




CREATE FUNCTION [meta].[GetVariableValue] (
	@VariableName nvarchar(100)
)
RETURNS nvarchar(100)
AS
BEGIN
	declare @VariableValue nvarchar(100)
	select @VariableValue = VariableValue from meta.Variables where VariableName = @VariableName
	return @VariableValue
END
GO
PRINT N'Creating [meta].[RemoveNonASCII]...';


GO

CREATE FUNCTION [meta].[RemoveNonASCII] 
(
    @nstring nvarchar(255)
)
RETURNS varchar(255)
AS
BEGIN

    DECLARE @Result varchar(255)
    SET @Result = ''

    DECLARE @nchar nvarchar(1)
    DECLARE @position int

    SET @position = 1
    WHILE @position <= LEN(@nstring)
    BEGIN
        SET @nchar = SUBSTRING(@nstring, @position, 1)
        --Unicode & ASCII are the same from 1 to 255.
        --Only Unicode goes beyond 255
        --0 to 31 are non-printable characters
        IF UNICODE(@nchar) between 32 and 255
            SET @Result = @Result + @nchar
        SET @position = @position + 1
    END

    RETURN @Result

END
GO
PRINT N'Creating [meta].[SplitCamelCase]...';


GO


CREATE FUNCTION [meta].[SplitCamelCase](@X VARCHAR(8000))
RETURNS VARCHAR(8000) AS
BEGIN
WHILE PATINDEX('%[^ ][ABCDEFGHIJKLMNOPQRSTUVWXYZ]%'
COLLATE SQL_Latin1_General_CP1_CS_AS,
@X COLLATE SQL_Latin1_General_CP1_CS_AS) > 0
SET @X = STUFF(@X,
PATINDEX('%[^ ][ABCDEFGHIJKLMNOPQRSTUVWXYZ]%'
COLLATE SQL_Latin1_General_CP1_CS_AS,
@X COLLATE SQL_Latin1_General_CP1_CS_AS) + 1, 0, ' ')
RETURN @X
END
GO
PRINT N'Creating [meta].[GetEasterSundayFromYear]...';


GO

-- =============================================
CREATE FUNCTION [meta].[GetEasterSundayFromYear]
(
    @year INT
)
RETURNS date
AS
BEGIN
	DECLARE
		@a INT
		,@b INT
		,@c INT
		,@d INT
		,@e INT
		,@f INT
		,@g INT
		,@h INT
		,@i INT
		,@k INT
		,@l INT
		,@m INT
		,@n INT
		,@p INT
		,@eastersunday DATE

	SET @a = @year % 19;
	SET @b = @year / 100;
	SET @c = @year % 100;
	SET @d = @b / 4;
	SET @e = @b % 4;
	SET @f = (@b + 8) / 25;
	SET @g = (@b - @f + 1) / 3;
	SET @h = ((19 * @a) + @b - @d - @g + 15) % 30;
	SET @i = @c / 4;
	SET @k = @c % 4;
	SET @l = (32 + (2 * @e) + (2 * @i) - @h -@k) % 7;
	SET @m = (@a + (11 * @h) + (22 * @l)) / 451;
	SET @n = (@h + @l - (7 * @m) + 114) / 31;
	SET @p = ((@h + @l - (7 * @m) + 114) % 31) + 1;

	SET @eastersunday = DATEFROMPARTS(@year,@n,@p);

    RETURN @eastersunday
END
GO
PRINT N'Creating [meta].[TabularStudioDefinition]...';


GO





CREATE VIEW [meta].[TabularStudioDefinition] AS
SELECT DISTINCT meta.SplitCamelCase(dwr.[TableName]) AS FactOrBridgeName
      ,meta.SplitCamelCase(dwr.[DimensionName]) AS DimensionName
      ,meta.SplitCamelCase(dwr.[RolePlayingDimensionName]) AS RolePlayingDimensionName
	  ,dwr.[RolePlayingDimensionName] + 'ID' AS FactOrBridgeIDColumn
	  ,dwr.DimensionName + 'ID' AS DimensionIDColumn
      ,bm.DestinationSchema + 'View' as FactOrBridgeSchema
  FROM 
	meta.[DWRelations] dwr LEFT JOIN
	meta.BusinessMatrix bm ON dwr.TableName = bm.TableName
GO
PRINT N'Creating [meta].[GetEasterDaysFromYear]...';


GO

CREATE FUNCTION [meta].[GetEasterDaysFromYear]
(	
	@year INT
)
RETURNS TABLE 
AS
RETURN 
(
	SELECT 
		meta.GetEasterSundayFromYear(@year)		
												AS [CalendarDate]
		,'Easter'								AS [EasterDayUKName]
		,'Påske'								AS [EasterDayDKName]

	UNION

	SELECT 
		DATEADD(DD,-2,meta.GetEasterSundayFromYear(@year))
												AS [CalendarDate]
		,'Good Friday' as [EasterDayUKName]
		,'Langfredag' as [EasterDayDKName]

	UNION

	SELECT 
		DATEADD(DD,-3,meta.GetEasterSundayFromYear(@year))
												AS [CalendarDate]
		,'Easter Thursday'						AS [EasterDayUKName]
		,'Skærtorsdag'							AS [EasterDayDKName]

	UNION

	SELECT 
		DATEADD(DD,1,meta.GetEasterSundayFromYear(@year))
												AS [CalendarDate]
		,'Easter Monday'						AS [EasterDayUKName]
		,'Påske mandag'							AS [EasterDayDKName]
)
GO
PRINT N'Creating [meta].[SplitString]...';


GO



CREATE FUNCTION [meta].[SplitString] (
      @InputString                  VARCHAR(MAX),
      @Delimiter                    VARCHAR(50)
)

RETURNS @Items TABLE (
      ID INT,
      Item                          VARCHAR(MAX)
)

AS
BEGIN
      IF @Delimiter = ' '
      BEGIN
            SET @Delimiter = ','
            SET @InputString = REPLACE(@InputString, ' ', @Delimiter)
      END

      IF (@Delimiter IS NULL OR @Delimiter = '')
            SET @Delimiter = ','

--INSERT INTO @Items VALUES (@Delimiter) -- Diagnostic
--INSERT INTO @Items VALUES (@InputString) -- Diagnostic

      DECLARE @Item           VARCHAR(8000)
      DECLARE @ItemList       VARCHAR(8000)
      DECLARE @DelimIndex     INT
	  DECLARE @Counter INT

      SET @ItemList = @InputString
      SET @DelimIndex = CHARINDEX(@Delimiter, @ItemList, 0)
	  SET @Counter = 1
      WHILE (@DelimIndex != 0)
      BEGIN
            SET @Item = SUBSTRING(@ItemList, 0, @DelimIndex)
            INSERT INTO @Items (ID, Item) VALUES (@Counter,@Item)

            -- Set @ItemList = @ItemList minus one less item
            SET @ItemList = SUBSTRING(@ItemList, @DelimIndex+1, LEN(@ItemList)-@DelimIndex)
            SET @DelimIndex = CHARINDEX(@Delimiter, @ItemList, 0)
			SET @Counter = @Counter + 1
      END -- End WHILE

	
      IF @Item IS NOT NULL -- At least one delimiter was encountered in @InputString
      BEGIN
            SET @Item = @ItemList
			--SET @Counter = @Counter + 1
             INSERT INTO @Items (ID, Item) VALUES (@Counter,LTRIM(@Item))
      END

      -- No delimiters were encountered in @InputString, so just return @InputString
      ELSE  INSERT INTO @Items (ID, Item) VALUES (@Counter,LTRIM(@InputString))

      RETURN

END -- End Function
GO
PRINT N'Creating [meta].[MaintainDWUpdateView]...';


GO

/**********************************************************************************************************************************************************************
The purpose of this scripts is to create and execute the update view between stage and dw. 
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[MaintainDWUpdateView]

@Table NVARCHAR(100),
@DestinationSchema NVARCHAR(50),
@PrintSQL BIT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/

DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10) 
DECLARE @DatabaseNameDW NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW')
DECLARE @SurrogateKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'SurrogateKeySuffix')
DECLARE @BusinessKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'BusinessKeySuffix')
DECLARE @FactIsIncremental BIT = (SELECT FactAndBridgeIncrementalFlag FROM meta.BusinessMatrix WHERE TableName = @Table AND DestinationSchema = @DestinationSchema)
DECLARE @LoadPattern NVARCHAR(50) = (SELECT LoadPattern FROM meta.BusinessMatrix WHERE TableName = @Table)
DECLARE @UpdateViewFlag BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'MaintainDWUpdateViewFlag')
DECLARE @ViewName NVARCHAR(100) = meta.[SplitCamelCase](@Table)

/**********************************************************************************************************************************************************************
1. Create and insert data into table variables
**********************************************************************************************************************************************************************/

DECLARE @InformationSchema TABLE (DatabaseName NVARCHAR(128), ColumnName NVARCHAR(128), OrdinalPosition INT, OriginalColumnName NVARCHAR(128))
DECLARE @InformationSchemaViews TABLE (TableName NVARCHAR(128), TableSchema NVARCHAR(128), ViewDefinition NVARCHAR(MAX))
DECLARE @ViewDefinition TABLE (SelectStatement NVARCHAR(MAX),FromStatement NVARCHAR(MAX))

/*Generates the combined information schema*/
INSERT @InformationSchema EXEC('SELECT ''DW'' AS [DATABASE_NAME]
										,CASE 
											WHEN (''' + @DestinationSchema + ''' IN (''fact'',''bridge'') AND (COLUMN_NAME LIKE ''%Code'' OR COLUMN_NAME LIKE ''%Name'' OR COLUMN_NAME LIKE ''%Label'')) OR (''' + @DestinationSchema + ''' = ''dim'' AND COLUMN_NAME NOT LIKE ''%' + @SurrogateKeySuffix + ''')
												THEN meta.SplitCamelCase(COLUMN_NAME)   
											ELSE COLUMN_NAME
										 END AS COLUMN_NAME
										,[ORDINAL_POSITION]
										,[COLUMN_NAME] AS ORIGINAL_COLUMN_NAME
								FROM 
									[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.COLUMNS
								WHERE 
										TABLE_NAME = ''' + @Table + ''' 
									AND COLUMN_NAME <> CASE WHEN ''' + @DestinationSchema + ''' = ''fact'' THEN ''' + @Table + @SurrogateKeySuffix + ''' 
														    ELSE '''' 
													   END 
									AND TABLE_SCHEMA = ''' + @DestinationSchema + ''' 
									AND COLUMN_NAME NOT LIKE ''DW%''
						 
								
								UNION
								
								SELECT ''View'' AS [DATABASE_NAME]
										,[COLUMN_NAME]
										,[ORDINAL_POSITION]
										,REPLACE([COLUMN_NAME],'' '','''') AS ORIGINAL_COLUMN_NAME
								FROM 
									[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.COLUMNS
								WHERE 
										TABLE_SCHEMA = ''' + @DestinationSchema +  'View'' 
									AND TABLE_NAME = '''  + @ViewName + ''' 
									AND COLUMN_NAME NOT LIKE ''DW%''')

INSERT @InformationSchemaViews EXEC('SELECT   Views.[name] AS TABLE_NAME
											 ,Schemas.[name] AS TABLE_SCHEMA
											 ,[definition] AS VIEW_DEFINITION
									 FROM 
									 	 [' + @DatabaseNameDW + '].[sys].[views] AS Views
									 INNER JOIN  
									 	 [' + @DatabaseNameDW + '].[sys].[sql_modules] AS Modules 
											 ON Modules.object_id = Views.object_id
									 INNER JOIN  
										 [' + @DatabaseNameDW + '].[sys].[schemas] AS Schemas 
											 ON Schemas.schema_id = Views.schema_id
									 WHERE 
											 Views.Name = ''' + @ViewName + ''' 
										 AND Schemas.Name = ''' + @DestinationSchema +  'View''')
		
							
/*Generates the view definition*/
INSERT @ViewDefinition SELECT REPLACE(REPLACE(ViewDefinition,RIGHT(ViewDefinition,LEN(ViewDefinition)-CHARINDEX('FROM [' + @DestinationSchema + '].[' + @Table + ']',ViewDefinition)+1),''),'CREATE VIEW', '') AS SelectStatement
							 ,RIGHT(ViewDefinition,LEN(ViewDefinition)-CHARINDEX('FROM [' + @DestinationSchema + '].[' + @Table + ']',ViewDefinition)+1) AS FromStatement
                       FROM
							 @InformationSchemaViews

						
/**********************************************************************************************************************************************************************
2. Create Loop counter variables
**********************************************************************************************************************************************************************/

DECLARE @Columns AS INT --Holds the number of columns in the table
DECLARE @Counter AS INT --Just a counter for the loop

SELECT 
	@Columns = (SELECT MAX(OrdinalPosition) + CASE WHEN @DestinationSchema IN ('fact','bridge') THEN 1 ELSE 0 END FROM @InformationSchema WHERE DatabaseName = 'DW'), --Counts the number of columns in the table
	@Counter = 1

/**********************************************************************************************************************************************************************
3. Create variables for determine first change between stage and dw
**********************************************************************************************************************************************************************/

DECLARE @PositionFirstChange INT --The ordinal position of the first change

SELECT 
	@PositionFirstChange = (SELECT TOP 1 InformationSchema.OrdinalPosition 
							FROM 
								@InformationSchema AS InformationSchema
							LEFT JOIN 
								(SELECT * FROM @InformationSchema WHERE DatabaseName = 'View') AS Views
									ON Views.OriginalColumnName = InformationSchema.OriginalColumnName
							WHERE 
									Views.ColumnName IS NULL
							ORDER BY 
								InformationSchema.OrdinalPosition) --Counts the position of the first change


/**********************************************************************************************************************************************************************
4. Create variable for holding the select and from statements
**********************************************************************************************************************************************************************/

DECLARE @SelectStatement NVARCHAR(MAX) --Variable for the current select part of the view
DECLARE @FromStatement NVARCHAR(MAX) --Variable for the current from part of the view

SELECT 
	@SelectStatement = (SELECT SelectStatement FROM @ViewDefinition), --Adds the current select part to the variable
	@FromStatement = (SELECT FromStatement FROM @ViewDefinition) --Adds the current from part to the variable


/**********************************************************************************************************************************************************************
5. Generates the columns for the alter view script
**********************************************************************************************************************************************************************/

DECLARE @PlaceholderColumnNameUpdateView AS NVARCHAR(MAX) --Placeholder used in the loop for the update view script
DECLARE @ColumnNameUpdateView AS NVARCHAR(MAX) --Variable which hold the value of @ColumnNameUpdateView for each loop

BEGIN

WHILE @Counter <= @Columns

BEGIN

	SELECT @PlaceholderColumnNameUpdateView = ',[' + InformationSchema.OriginalColumnName + '] AS [' + InformationSchema.ColumnName + ']' + @CRLF 
				     
	FROM 
		@InformationSchema AS InformationSchema
	LEFT JOIN 
		(SELECT * FROM @InformationSchema WHERE DatabaseName = 'View') AS Views 
			ON Views.ColumnName = InformationSchema.ColumnName
	WHERE 
			Views.ColumnName IS NULL 
		AND InformationSchema.DatabaseName = 'DW' 
		AND InformationSchema.OrdinalPosition = @Counter

	SET @ColumnNameUpdateView = CONCAT(@ColumnNameUpdateView,@PlaceholderColumnNameUpdateView)

	SET @PlaceholderColumnNameUpdateView = ''

	SET @Counter = @Counter + 1

END


/**********************************************************************************************************************************************************************
6.Fill out the dynamic SQL script variables
**********************************************************************************************************************************************************************/

DECLARE @PrepareViewScript NVARCHAR(MAX) --Variable where the view script is created
DECLARE @UpdateViewScript NVARCHAR(MAX) --Variable for the final alter view script
DECLARE @UpdateTempViewScript NVARCHAR(MAX)

SET @PrepareViewScript = 'ALTER VIEW ' + CONCAT(REPLACE(@SelectStatement,'''',''''''),@ColumnNameUpdateView,REPLACE(@FromStatement,'''','''''')) END
					

/*Generates the create view script so it can be executed in the DW database*/
SET @UpdateViewScript = CASE WHEN @PositionFirstChange IS NULL THEN NULL 
                             ELSE 'USE [' + @DatabaseNameDW + ']' + @CRLF + 'EXEC(''' + @PrepareViewScript + ''')'
					    END

SET @UpdateTempViewScript = CASE WHEN @PositionFirstChange IS NULL THEN NULL 
                             ELSE 'USE [' + @DatabaseNameDW + ']' + @CRLF + 'EXEC(''' + REPLACE(REPLACE(@PrepareViewScript ,'[factView].[' + @Table + ']','[factView].[' + @Table + '_Temp]'), 'FROM [' + @DestinationSchema + '].[' + @Table + ']','FROM [' + @DestinationSchema + '].[' + @Table + '_Temp]') + ''')'
							END

/**********************************************************************************************************************************************************************
7. Execute dynamic SQL
***********************************************************************************************************************************************************************/

IF @PrintSQL = 0

	BEGIN 

		EXEC(@UpdateViewScript)

		IF @DestinationSchema = 'fact' AND @LoadPattern <> 'Standard' AND @FactIsIncremental = 1 AND @UpdateViewFlag = 1
			BEGIN
				EXEC(@UpdateTempViewScript)
			END

	END

ELSE

	BEGIN 

		PRINT(@UpdateViewScript) + @CRLF + @CRLF

		IF @DestinationSchema = 'fact' AND @LoadPattern <> 'Standard' AND @FactIsIncremental = 1 AND @UpdateViewFlag = 1
			BEGIN
				PRINT(@UpdateTempViewScript)
			END

	END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[MaintainExtract]...';


GO

CREATE PROCEDURE [meta].[MaintainExtract]

@SourceObjectID INT ,
@DropTable BIT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
1. Create Extract Tables
**********************************************************************************************************************************************************************/
DECLARE @ExecuteCreateTable NVARCHAR(MAX)
DECLARE @ExecuteCreateSourceScript NVARCHAR(MAX)
DECLARE @ExecuteCreatePartitionScript NVARCHAR(MAX)


SELECT 
	 @ExecuteCreateTable = 'EXECUTE meta.[MaintainExtractCreateTable] @SourceObjectID = ''' + CAST(@SourceObjectID AS NVARCHAR(20))+ ''', @DropTable = ' + CAST(@DropTable AS NVARCHAR(1)) + ', @PrintSQL = 0'
	,@ExecuteCreateSourceScript = 'EXECUTE meta.[MaintainExtractCreateSourceScript] @SourceObjectID = ''' + CAST(@SourceObjectID AS NVARCHAR(20)) + '''' + ', @PrintSQL = 0'
	,@ExecuteCreatePartitionScript = 'EXECUTE meta.[MaintainExtractCreatePartitionScript] @SourceObjectID = ''' + CAST(@SourceObjectID AS NVARCHAR(20)) + '''' + ', @PrintSQL = 0'

EXEC(@ExecuteCreateTable)
EXEC(@ExecuteCreateSourceScript)
EXEC(@ExecuteCreatePartitionScript)


SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[MaintainExtractCreateTable]...';


GO




/**********************************************************************************************************************************************************************
The purpose of this scripts is to create the create table script for extract tables
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[MaintainExtractCreateTable] 

@SourceObjectID INT,--Input is the table name without schema
@DropTable BIT, --Input is 1 if you want the table to be dropped if it already exists
@PrintSQL BIT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/
DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10)
DECLARE @DatabaseNameExtract NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameExtract')
DECLARE @ExtractCCIFlag NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'ExtractCCIFlag')
DECLARE @ExtractCCIHistoryFlag NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'ExtractCCIHistoryFlag')
DECLARE @EnterpriseEditionFlag NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'EnterpriseEditionFlag')
DECLARE @SeparateHistoryFlag NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'SeparateHistoryLayerFlag')
DECLARE @NavisionFlag BIT = (SELECT DISTINCT NavisionFlag FROM meta.ExtractInformationSchemaDefinitions WHERE SourceObjectID = CAST(@SourceObjectID AS INT))
DECLARE @IsCloudFlag NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'IsCloudFlag')
DECLARE @Table NVARCHAR(128) = (SELECT DISTINCT TableName  FROM meta.ExtractInformationSchemaDefinitions WHERE SourceObjectID = CAST(@SourceObjectID AS INT))

/**********************************************************************************************************************************************************************
1. Create and insert data into table variables
**********************************************************************************************************************************************************************/
DECLARE @Schemas TABLE (SchemaName NVARCHAR(128), ExtractSchemaName NVARCHAR(128), OrdinalPosition INT)
DECLARE @InformationSchema TABLE (DatabaseName NVARCHAR(128), TableSchema NVARCHAR(128), TableName NVARCHAR(128), ColumnName NVARCHAR(128), OrdinalPosition INT, DataType NVARCHAR(128), Nullable NVARCHAR(128), KeySequence INT, HistoryFlag INT, TruncateFlag INT)

INSERT @InformationSchema SELECT DISTINCT   
									   ISNULL(TableCatalogName,'')
									  ,ISNULL(SchemaName,'')
									  ,TableName
									  ,ColumnName
									  ,ROW_NUMBER() OVER (PARTITION BY SchemaName, TableName ORDER BY OrdinalPositionNumber) AS OrdinalPositionNumber
									  ,FullDataTypeName
									  ,NullableName
									  ,KeySequenceNumber
									  ,PreserveHistoryFlag
									  ,TruncateBeforeDeployFlag
						FROM meta.ExtractInformationSchemaDefinitions AS MetaData
						WHERE MetaData.[SourceObjectID] = @SourceObjectID


						
INSERT @Schemas SELECT ISNULL(MetaData.SchemaName,''), MetaData.ExtractSchemaName,ROW_NUMBER() OVER (ORDER BY MetaData.ExtractSchemaName)
						FROM 
							meta.ExtractInformationSchemaDefinitions AS MetaData
						WHERE
							MetaData.SourceObjectID = @SourceObjectID
						GROUP BY ExtractSchemaName,SchemaName

						

/**********************************************************************************************************************************************************************
2. Create Loop counter variables
**********************************************************************************************************************************************************************/
DECLARE @Counter INT
DECLARE @MaxColumns INT 
DECLARE @InnerCounter INT
DECLARE @MaxSchemas INT

SELECT 
		@Counter = 1
	   ,@InnerCounter = 1
	   ,@MaxColumns = (SELECT MAX(OrdinalPosition) FROM @InformationSchema)
	   ,@MaxSchemas = (SELECT MAX(OrdinalPosition) FROM @Schemas)

/**********************************************************************************************************************************************************************
3. Create Table SQL
**********************************************************************************************************************************************************************/
DECLARE @PlaceholderTables NVARCHAR(MAX)
DECLARE @Tables NVARCHAR(MAX)
DECLARE @TableScript NVARCHAR(MAX)
DECLARE @Schema NVARCHAR(MAX)
DECLARE @ExtractSchema NVARCHAR(MAX)
DECLARE @PlaceholderPrimaryKeyColumns NVARCHAR(MAX)
DECLARE @PrimaryKeyColumns NVARCHAR(MAX)
DECLARE @HistoryFlag INT
DECLARE @SQLScriptDrop NVARCHAR(MAX)
DECLARE @SQLScriptCreate NVARCHAR(MAX)
DECLARE @ClusteredColumnStoreIndexScript NVARCHAR(MAX)
DECLARE @ClusteredColumnStoreIndexScriptHistory NVARCHAR(MAX)
DECLARE @HistoryTable NVARCHAR(100) = IIF(@SeparateHistoryFlag = 1,@Table,@Table + '_History')
DECLARE @HistorySchema NVARCHAR(50)
DECLARE @TruncateFlag BIT
DECLARE @TruncateProperty NVARCHAR(MAX)

WHILE @Counter <= @MaxSchemas

BEGIN

SELECT 
		@Schema = SchemaName,
		@ExtractSchema = ExtractSchemaName,
		@HistorySchema = IIF(@SeparateHistoryFlag = 1,ExtractSchemaName + '_history',ExtractSchemaName)
FROM @Schemas
WHERE @Counter = OrdinalPosition

SET @TruncateFlag = (SELECT DISTINCT TruncateFlag FROM @InformationSchema WHERE TableName = @Table AND TableSchema = @Schema)

	
	WHILE @InnerCounter <= @MaxColumns

	BEGIN

		SELECT 
			@PlaceholderTables = IIF(@InnerCounter = 1,'',',') + '[' + ColumnName + '] ' + DataType + ' ' + Nullable + @CRLF
		FROM @InformationSchema
		WHERE TableName = @Table
		AND OrdinalPosition = @InnerCounter
		AND TableSchema = @Schema

		SELECT 
			@PlaceholderPrimaryKeyColumns = IIF(KeySequence = 1,'',IIF(KeySequence IS NULL,'',',')) + IIF(KeySequence IS NULL,'','[' + ColumnName + ']')
		FROM @InformationSchema
		WHERE TableName = @Table
		AND KeySequence = @InnerCounter
		AND TableSchema = @Schema
		AND KeySequence IS NOT NULL
		ORDER BY KeySequence



SET @Tables = CONCAT(@Tables,@PlaceholderTables)

SET @PrimaryKeyColumns = CONCAT(@PrimaryKeyColumns,@PlaceholderPrimaryKeyColumns)

SET @PlaceholderTables = ''

SET @PlaceholderPrimaryKeyColumns = ''

SET @InnerCounter = @InnerCounter + 1

END

SET @HistoryFlag = (SELECT DISTINCT HistoryFlag FROM @InformationSchema WHERE TableName = @Table AND TableSchema = @Schema)


SET @SQLScriptDrop = IIF(@DropTable = 1,IIF(@IsCloudFLag = 1,'','USE ' + @DatabaseNameExtract + @CRLF) + ' IF EXISTS(SELECT * FROM sys.tables WHERE object_id = object_id(''[' + @ExtractSchema + '].[' + @Table + ']''))
BEGIN
DROP TABLE ['+ @ExtractSchema + '].[' + @Table + ']
END ' +

IIF(@IsCloudFLag = 1,'','USE ' + @DatabaseNameExtract + @CRLF ) + ' IF EXISTS(SELECT * FROM sys.tables WHERE object_id = object_id(''[' + @HistorySchema + '].[' + @HistoryTable + ']''))
BEGIN
DROP TABLE ['+ @HistorySchema + '].[' + @HistoryTable + ']
END','') + @CRLF

SET @SQLScriptCreate = IIF(@IsCloudFLag = 1,'','USE ' + @DatabaseNameExtract) + @CRLF + 
'IF EXISTS(SELECT * FROM sys.tables WHERE object_id = object_id(''[' + @ExtractSchema + '].[' + @Table + ']''))
BEGIN
PRINT ''Table Exists''
END
ELSE
BEGIN
CREATE TABLE ['+ @ExtractSchema + '].[' + @Table + ']' + @CRLF + '(' + @Tables +',DWCreatedDate DATETIME DEFAULT (GETDATE()) ' + IIF(@NavisionFlag = 1,',DWNavisionCompany NVARCHAR(50)','') + @CRLF +
IIF(@PrimaryKeyColumns <> '','CONSTRAINT [PK_' + @Table + '] PRIMARY KEY NONCLUSTERED (' + @PrimaryKeyColumns + IIF(@NavisionFlag = 1,',DWNavisionCompany','') + ')) ' + @CRLF + 'END',') ' + @CRLF + 'END') 
+ @CRLF + @CRLF +
IIF( @HistoryFlag= 1,
'IF EXISTS(SELECT * FROM sys.tables WHERE object_id = object_id(''[' + @HistorySchema + '].[' + @HistoryTable + ']''))
BEGIN
PRINT ''History Table Exists''
END
ELSE
BEGIN
CREATE TABLE ['+ @HistorySchema + '].[' + @HistoryTable + ']' + @CRLF + '(' + @Tables +'
,[DWIsCurrent] BIT
,[DWValidFromDate] DATETIME
,[DWValidToDate] DATETIME
,[DWCreatedDate] DATETIME
,[DWModifiedDate] DATETIME
,[DWIsDeletedInSource] BIT
,[DWDeletedInSourceDate] DATETIME' + IIF(@NavisionFlag = 1,',DWNavisionCompany NVARCHAR(50)','') + @CRLF +
IIF(@PrimaryKeyColumns <> '','CONSTRAINT [PK_' + @Table + '_History] PRIMARY KEY NONCLUSTERED (' + @PrimaryKeyColumns + ',DWValidFromDate' + IIF(@NavisionFlag = 1,',DWNavisionCompany','') + '))' + 'END',') END'),'')

SET @ClusteredColumnStoreIndexScript = IIF(@IsCloudFLag = 1,'','USE ' + @DatabaseNameExtract) + @CRLF + 'IF NOT EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id(''' + @ExtractSchema + '.' + @Table + ''') AND NAME = ''CCI_'+ @Table + ''')' + @CRLF +
																							'BEGIN CREATE CLUSTERED COLUMNSTORE INDEX [CCI_' + @Table + '] ON ' + @ExtractSchema + '.[' + @Table + '] WITH (DROP_EXISTING = OFF, COMPRESSION_DELAY = 0)
																							END'

SET @ClusteredColumnStoreIndexScriptHistory = IIF(@IsCloudFLag = 1,'','USE ' + @DatabaseNameExtract) + @CRLF + 'IF NOT EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id(''' + @HistorySchema + '.' + @HistoryTable + ''') AND NAME = ''CCI_'+ @Table + '_History'')' + @CRLF +
																							'BEGIN CREATE CLUSTERED COLUMNSTORE INDEX [CCI_' + @Table + '_History] ON ' + @HistorySchema + '.[' + @HistoryTable + '] WITH (DROP_EXISTING = OFF, COMPRESSION_DELAY = 0)
																							END'

SET @TruncateProperty = IIF(@TruncateFlag = 0,'','EXEC [' + @DatabaseNameExtract + '].sys.sp_addextendedproperty @name = N''TruncateBeforeDeploy'', @value = N''True'', @level0type = N''SCHEMA'', @level0name = N''' + @ExtractSchema + ''', @level1type = N''TABLE'', @level1name = N''' + @Table +'''' + @CRLF	)																						

IF @PrintSQL = 0

	BEGIN
		EXEC(@SQLScriptDrop)
		EXEC(@SQLScriptCreate)
		EXEC(@TruncateProperty)

		IF @ExtractCCIFlag = 1 AND @EnterpriseEditionFlag = 1
			BEGIN
				EXEC(@ClusteredColumnStoreIndexScript)
			END
		IF @HistoryFlag = 1 AND @ExtractCCIHistoryFlag = 1 AND @EnterpriseEditionFlag = 1
			BEGIN
				EXEC(@ClusteredColumnStoreIndexScriptHistory)
			END
	END

ELSE

	BEGIN
		PRINT(@SQLScriptDrop)
		PRINT(LEFT(@SQLScriptCreate,4000))
		PRINT(SUBSTRING(@SQLScriptCreate,4001,4000))
		PRINT(@TruncateProperty)

		IF @ExtractCCIFlag = 1
			BEGIN
				PRINT(@ClusteredColumnStoreIndexScript)
			END
		IF @HistoryFlag = 1 AND @ExtractCCIHistoryFlag = 1
			BEGIN
				PRINT(@ClusteredColumnStoreIndexScriptHistory)
			END
	END

SET @PrimaryKeyColumns = ''

SET @InnerCounter = 1

SET @Schema = ''

SET @ExtractSchema = ''

SET @Tables = ''

SET @Counter = @Counter + 1

END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[SetLastLoadedValue]...';


GO


/**********************************************************************************************************************************************************************
The purpose of this scripts is set LastValueLoaded in the table SourceObjectIncrementalSetup
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[SetLastLoadedValue] 

  @TableName NVARCHAR(100)
, @ExtractSchemaName NVARCHAR(100)
, @PrintSQL BIT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/

DECLARE @ObjectID INT
DECLARE @IncrementalValueColumn NVARCHAR(500)
DECLARE @IsDateFlag BIT

SET @ObjectID = (
					SELECT SourceObjects.ID 
					FROM 
						meta.SourceObjects
					INNER JOIN
						(SELECT ID, ExtractSchemaName, ROW_NUMBER() OVER (PARTITION BY ExtractSchemaName ORDER BY ID) AS RowN FROM meta.SourceConnections) AS SourceConnections
							ON SourceConnections.ID = SourceObjects.SourceConnectionID
							AND RowN = 1
					WHERE 
						SourceObjects.ObjectName = @TableName
						AND SourceConnections.ExtractSchemaName = @ExtractSchemaName
				)

SET @IncrementalValueColumn =	(
									SELECT IIF(IncrementalValueColumnDefinitionInExtract <> '',IncrementalValueColumnDefinitionInExtract, IncrementalValueColumnDefinition)
									FROM meta.SourceObjectIncrementalSetup
									WHERE SourceObjectID = @ObjectID
								)

SET @IsDateFlag = (
					SELECT IsDateFlag
					FROM meta.SourceObjectIncrementalSetup
					WHERE SourceObjectID = @ObjectID
				)

/**********************************************************************************************************************************************************************
1. Execute dynamic SQL script variables
***********************************************************************************************************************************************************************/

DECLARE @SQL NVARCHAR(MAX) 


SET @SQL = 'UPDATE incremental_setup
 			SET [LastValueLoaded] = ISNULL((SELECT CONVERT(BIGINT, ' + iif (@IsDateFlag = 1,'FORMAT(MAX(' + @IncrementalValueColumn + '), ''yyyyMMddHHmmss''))', 
			'MAX(' + @IncrementalValueColumn + '))') + ' FROM [' + @ExtractSchemaName + '].[' + @TableName + ']), [LastValueLoaded])
			FROM 
				meta.SourceObjectIncrementalSetup as incremental_setup 
			INNER JOIN 
				meta.SourceObjects as source_objects 
			        on incremental_setup.SourceObjectID = source_objects.ID 
			INNER JOIN  
				meta.SourceConnections as source_connections 
					on source_objects.SourceConnectionID = source_connections.ID
  			WHERE
				source_connections.ExtractSchemaName + ''.'' + SUBSTRING(source_objects.ObjectName, CHARINDEX(''$'', source_objects.ObjectName) + 1, 200) = ''' + @ExtractSchemaName + '.' + @TableName + ''''

IF @PrintSQL = 1

	BEGIN
		PRINT(@SQL)
	END

ELSE
	
	BEGIN
		EXEC(@SQL)
	END



SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[GetLastValueLoaded]...';


GO


CREATE PROCEDURE [meta].[GetLastValueLoaded] 

  @TableName NVARCHAR(100)
, @ExtractSchemaName NVARCHAR(100)
, @JobIsIncremental BIT
, @ConnectionType NVARCHAR(50)

AS

SET NOCOUNT ON

SELECT 
	  IIF(ISNULL(SourceObjectIncrementalSetup.IncrementalValueColumnDefinitionInExtract,'') = '', SourceObjectIncrementalSetup.IncrementalValueColumnDefinition,SourceObjectIncrementalSetup.IncrementalValueColumnDefinitionInExtract) AS IncrementalValueColumnDefinition
	, CASE
			WHEN @JobIsIncremental = 0 AND IsDateFlag = 1 AND @ConnectionType NOT IN ('Oracle','MSORA') THEN '19000101000000'
			WHEN @JobIsIncremental = 0 AND IsDateFlag = 1 AND @ConnectionType IN ('Oracle','MSORA') THEN '01010101000000'
			WHEN @JobIsIncremental = 0 AND IsDateFlag = 0 THEN '0'
			WHEN @JobIsIncremental = 1 AND IsDateFlag = 1 THEN FORMAT(DATEADD(DD,RollingWindowDays,CONVERT(datetime,STUFF(STUFF(STUFF(SourceObjectIncrementalSetup.LastValueLoaded,13,0,':'),11,0,':'),9,0,' '))),'yyyyMMddHHmmss')
			ELSE SourceObjectIncrementalSetup.LastValueLoaded
	  END AS LastValueLoaded
FROM 
	meta.SourceObjectIncrementalSetup 
INNER JOIN 
	meta.SourceObjects
		ON SourceObjectIncrementalSetup.SourceObjectID = SourceObjects.ID
INNER JOIN
	(SELECT ID, ExtractSchemaName, ROW_NUMBER() OVER (PARTITION BY ExtractSchemaName ORDER BY ID) AS RowN FROM meta.SourceConnections) AS SourceConnections
		ON SourceConnections.ID = SourceObjects.SourceConnectionID
		AND RowN = 1
WHERE 
	SourceObjects.ObjectName = @TableName
	AND SourceConnections.ExtractSchemaName = @ExtractSchemaName

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[UpdateVariables]...';


GO


CREATE PROCEDURE [meta].[UpdateVariables]

@DatabasePrefix NVARCHAR(100),
@DatabaseNameDW NVARCHAR(100),
@DatabaseNameStage NVARCHAR(100),
@DatabaseNameExtract NVARCHAR(100),
@DatabaseNameMeta NVARCHAR(100),
@IsCloudFlag BIT

AS

SET NOCOUNT ON

DECLARE @FactLoadEngine NVARCHAR(10) = (SELECT IIF(@IsCloudFlag = 1,'SQL','SSIS'))

IF @IsCloudFlag = 0

	BEGIN

		EXEC('
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DatabasePrefix'', @value=N''' + @DatabasePrefix + '''
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DatabaseNameDW'', @value=N''' + @DatabaseNameDW + ''' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DatabaseNameExtract'', @value=N''' + @DatabaseNameExtract + ''' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DatabaseNameStage'', @value=N''' + @DatabaseNameStage + ''' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DatabaseNameMeta'', @value=N''' + @DatabaseNameMeta + ''' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DatabaseNameTabular'', @value=N''' + @DatabasePrefix + 'Tabular''
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DefaultDate'', @value=N''19000101'' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DefaultDimensionMemberID'', @value=N''-1'' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DefaultNumber'', @value=N''0'' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DefaultString'', @value=N''?'' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DefaultBit'', @value=N''0'' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''SurrogateKeySuffix'', @value=N''ID'' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''BusinessKeySuffix'', @value=N''Key'' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''IsCloudFlag'', @value=N''' + @IsCloudFlag + '''
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''EnterpriseEditionFlag'', @value=N''1'' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''FactCCIFlag'', @value=N''1'' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''ExtractCCIFlag'', @value=N''0'' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''ExtractCCIHistoryFlag'', @value=N''1'' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''FactInMemoryFlag'', @value=N''1'' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''FactLoadEngine'', @value=N''' + @FactLoadEngine + ''' 
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''MaintainDWDropTableFlag'', @value=N''0''
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''MaintainDWDropViewFlag'', @value=N''0''
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''MaintainDWUpdateViewFlag'', @value=N''1''
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''ExtractControllerPattern'', @value=N''Standard''
		EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''LoadControllerPattern'', @value=N''Standard''')

	END

ELSE

	BEGIN

		EXEC('
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DatabaseNameDW'', @value=N''' + @DatabaseNameDW + ''' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DatabaseNameExtract'', @value=N''' + @DatabaseNameExtract + ''' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DatabaseNameStage'', @value=N''' + @DatabaseNameStage + ''' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DatabaseNameMeta'', @value=N''' + @DatabaseNameMeta + ''' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DefaultDate'', @value=N''19000101'' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DefaultDimensionMemberID'', @value=N''-1'' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DefaultNumber'', @value=N''0'' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DefaultString'', @value=N''?'' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''DefaultBit'', @value=N''0'' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''SurrogateKeySuffix'', @value=N''ID'' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''BusinessKeySuffix'', @value=N''Key'' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''IsCloudFlag'', @value=N''' + @IsCloudFlag + '''
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''EnterpriseEditionFlag'', @value=N''1'' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''FactCCIFlag'', @value=N''1'' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''ExtractCCIFlag'', @value=N''0'' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''ExtractCCIHistoryFlag'', @value=N''1'' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''FactInMemoryFlag'', @value=N''0'' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''FactLoadEngine'', @value=N''' + @FactLoadEngine + ''' 
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''MaintainDWDropTableFlag'', @value=N''0''
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''MaintainDWDropViewFlag'', @value=N''0''
			EXEC [' + @DatabaseNameMeta + '].sys.sp_addextendedproperty @name=N''MaintainDWUpdateViewFlag'', @value=N''1''')

	END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[UpdateSourceObjectTables]...';


GO
/**********************************************************************************************************************************************************************
The purpose of this scripts is to create the neccessary meta entries for incremental extract tables
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[UpdateSourceObjectTables]

@TableName NVARCHAR(100),
@SourceConnectionName NVARCHAR(100),
@ExtractSchemaName NVARCHAR(100),
@IsDateFlag BIT,
@IncrementalDefinition NVARCHAR(200),
@RollingWindowDays INT,
@ConnectionType NVARCHAR(50)

AS

SET NOCOUNT ON

DECLARE @ErrorMessage NVARCHAR(4000);
DECLARE @ErrorSeverity INT
DECLARE @ErrorState INT

/**********************************************************************************************************************************************************************
1. Update connections
***********************************************************************************************************************************************************************/
IF NOT EXISTS (SELECT TOP 1 [Name] FROM meta.SourceConnections WHERE Name = @SourceConnectionName)
BEGIN TRY				
	INSERT INTO meta.SourceConnections ([Name],[ExtractSchemaName])
	SELECT @SourceConnectionName,@ExtractSchemaName				
END TRY
BEGIN CATCH
	IF ERROR_NUMBER() <> 2627 -- Only react if this is not a "Violation of PRIMARY KEY constraint" error
	BEGIN
		SET @ErrorMessage = ERROR_MESSAGE();  
		SET @ErrorSeverity = ERROR_SEVERITY();  
		SET @ErrorState = ERROR_STATE();  
  
		RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState);  
	END
END CATCH

/**********************************************************************************************************************************************************************
1. Update objects
***********************************************************************************************************************************************************************/
DECLARE @SourceConnectionID INT = (SELECT ID FROM meta.SourceConnections WHERE Name = @SourceConnectionName)

IF NOT EXISTS (SELECT SourceConnectionID, SchemaName, ObjectName FROM meta.SourceObjects WHERE SourceConnectionID = @SourceConnectionID AND ObjectName = @TableName)
BEGIN TRY
	INSERT INTO meta.SourceObjects (SourceConnectionID, SchemaName,ObjectName,PreserveHistoryFlag,IncrementalFlag)
	SELECT @SourceConnectionID, '', @TableName, 1, 1
END TRY
BEGIN CATCH
	IF ERROR_NUMBER() <> 2627 -- Only react if this is not a "Violation of PRIMARY KEY constraint" error
	BEGIN
		SET @ErrorMessage = ERROR_MESSAGE();  
		SET @ErrorSeverity = ERROR_SEVERITY();  
		SET @ErrorState = ERROR_STATE(); 
  
		RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState);  
	END
END CATCH

/**********************************************************************************************************************************************************************
1. Update incremental setup
***********************************************************************************************************************************************************************/
DECLARE @SourceObjectID INT = (SELECT ID FROM meta.SourceObjects WHERE SourceConnectionID = @SourceConnectionID AND ObjectName = @TableName)

IF NOT EXISTS (SELECT SourceObjectID FROM meta.SourceObjectIncrementalSetup WHERE SourceObjectID = @SourceObjectID)
BEGIN
	BEGIN TRY
		INSERT INTO meta.SourceObjectIncrementalSetup (SourceObjectID, IncrementalValueColumnDefinitionInExtract,IsDateFlag,LastValueLoaded,RollingWindowDays)
		SELECT @SourceObjectID, @IncrementalDefinition, @IsDateFlag, CASE
																		WHEN @IsDateFlag = 1 AND @ConnectionType NOT IN ('Oracle','MSORA') THEN '19000101000000'
																		WHEN @IsDateFlag = 1 AND @ConnectionType IN ('Oracle','MSORA') THEN '01010101000000'
																		ELSE '0'																					
																	END, @RollingWindowDays;
	END TRY
	BEGIN CATCH
		IF ERROR_NUMBER() <> 2627 -- Only react if this is not a "Violation of PRIMARY KEY constraint" error
		BEGIN
			SET @ErrorMessage = ERROR_MESSAGE();  
			SET @ErrorSeverity = ERROR_SEVERITY();  
			SET @ErrorState = ERROR_STATE(); 
  
			RAISERROR (@ErrorMessage, @ErrorSeverity, @ErrorState);  
		END
	END CATCH
END
ELSE
BEGIN
	UPDATE meta.SourceObjectIncrementalSetup
	SET IncrementalValueColumnDefinitionInExtract = @IncrementalDefinition,
		IsDateFlag = @IsDateFlag,
		RollingWindowDays = @RollingWindowDays
	WHERE
		SourceObjectID = @SourceObjectID
END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[ViewTableProperties]...';


GO

CREATE PROCEDURE [meta].[ViewTableProperties]

 @Table NVARCHAR(100)
,@SchemaName NVARCHAR(100)

AS

SET NOCOUNT ON

DECLARE @DatabaseNameDW NVARCHAR(50) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW')

EXEC('SELECT DISTINCT
		tables.name AS TableName
	,IIF(TableProperties.name = ColumnProperties.name,NULL, TableProperties.name) AS TableProperties
	,IIF(TableProperties.name = ColumnProperties.name,NULL, TableProperties.value) AS TablePropertiesValue
	,IIF(TableProperties.name <> ColumnProperties.name,NULL, all_columns.name) AS ColumnName
	,IIF(TableProperties.name <> ColumnProperties.name,NULL, ColumnProperties.name) AS ColumnProperties
	

FROM
	' + @DatabaseNameDW + '.sys.tables	
INNER JOIN
	' + @DatabaseNameDW + '.sys.schemas
		ON 	schemas	.schema_id = tables.schema_id					
INNER JOIN 
	' + @DatabaseNameDW + '.sys.all_columns 
		ON all_columns.object_id=tables.object_id
LEFT JOIN 
	' + @DatabaseNameDW + '.sys.extended_properties AS ColumnProperties
		ON ColumnProperties.major_id=tables.object_id 
		AND ColumnProperties.minor_id=all_columns.column_id 
		AND ColumnProperties.class=1
LEFT JOIN 
	' + @DatabaseNameDW + '.sys.extended_properties AS TableProperties
		ON TableProperties.major_id=tables.object_id 										
		AND TableProperties.class=1
WHERE
	tables.name = ''' + @Table + '''
	AND schemas.name = ''' + @SchemaName + '''')

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[PreDeploymentCleanup]...';


GO

CREATE PROCEDURE [meta].[PreDeploymentCleanup]

AS

SET NOCOUNT ON


/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/

DECLARE @DatabaseNameStage NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameStage')
DECLARE @DatabaseNameExtract NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameExtract')
DECLARE @DatabaseNameDW NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW')

DECLARE @TruncateObjects TABLE (TableName NVARCHAR(128),SqlStatement NVARCHAR(MAX))

INSERT @TruncateObjects 

EXEC(
'SELECT 
	''[' + @DatabaseNameExtract + '].['' + s.[name] + ''].['' + t.[name] + '']'' AS SchemaTableName,
	''TRUNCATE TABLE [' + @DatabaseNameExtract + '].['' + s.[name] + ''].['' + t.[name] + ''];'' AS TruncateScript
FROM 
	[' + @DatabaseNameExtract + '].sys.[extended_properties] AS ep
	INNER JOIN [' + @DatabaseNameExtract + '].sys.[tables] AS [t] ON ep.[major_id] = t.[object_id]
	INNER JOIN [' + @DatabaseNameExtract + '].sys.[schemas] AS [s] ON [s].[schema_id] = [t].[schema_id]
WHERE 
	ep.[class_desc] = ''OBJECT_OR_COLUMN''
	AND ep.[name] = ''TruncateBeforeDeploy''

UNION

SELECT 
	''[' + @DatabaseNameDW + '].['' + s.[name] + ''].['' + t.[name] + '']'' AS SchemaTableName,
	''TRUNCATE TABLE [' + @DatabaseNameDW + '].['' + s.[name] + ''].['' + t.[name] + ''];'' AS TruncateScript
FROM 
	[' + @DatabaseNameDW + '].sys.[extended_properties] AS ep
	INNER JOIN [' + @DatabaseNameDW + '].sys.[tables] AS [t] ON ep.[major_id] = t.[object_id]
	INNER JOIN [' + @DatabaseNameDW + '].sys.[schemas] AS [s] ON [s].[schema_id] = [t].[schema_id]
WHERE 
	ep.[class_desc] = ''OBJECT_OR_COLUMN''
	AND ep.[name] = ''TruncateBeforeDeploy''

UNION

SELECT 
	''[' + @DatabaseNameStage + '].['' + TABLE_SCHEMA + ''].['' + TABLE_NAME + '']'' AS SchemaTableName,
	''TRUNCATE TABLE [' + @DatabaseNameStage + '].['' + TABLE_SCHEMA + ''].['' + TABLE_NAME + ''];'' AS TruncateScript
FROM 
	[' + @DatabaseNameStage + '].INFORMATION_SCHEMA.TABLES
WHERE
	TABLE_SCHEMA IN (''stage'',''stage_temp'')')


-- Declare variables
DECLARE @sql NVARCHAR(MAX) = '';

-- Truncate tables before deployment to save time
SET @sql = '';

SELECT 
	@sql += SqlStatement
FROM
	@TruncateObjects

EXEC sp_executesql @sql;

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[CreateCalendarDimension]...';


GO
CREATE PROCEDURE [meta].[CreateCalendarDimension] AS

BEGIN
	SET NOCOUNT ON;
	SET DATEFIRST 1;

	DECLARE 
		@start_date DATETIME,
		@end_date DATETIME,
		@MaxDate DATETIME,
		@FiscalEndMonth INT = 9,
		@UnknownDate VARCHAR(8) = '19000101',
		@YearFirst INT = 2010,
		@YearsAhead INT = 4;				-- @YearsAhead=3 <=> eg. Current year=2019 => Last year in calendar=2022

	-- Drop calendar dimension table
	IF OBJECT_ID('dim.Calendar', 'u') IS NULL BEGIN

	-- Create calendar dimension table
	CREATE TABLE dim.Calendar (
		[CalendarID] INT PRIMARY KEY,
		[CalendarKey] DATE,
		[CalendarDate] DATE NULL ,

		[DayNumber] INT NULL,

		[WeekCode] INT NULL,  
		[WeekNumber] INT NULL, 
		[WeekName] NVARCHAR(20) NULL,
		[WeekYear] INT NULL,

		[WeekDayNumber] SMALLINT NULL,
		[WeekDayName] NVARCHAR(10) NULL,

		[MonthCode] INT NULL,  
		[MonthNumber] INT NULL, 
		[MonthName] NVARCHAR(20) NULL,
		[MonthShort] NVARCHAR(3) NULL,
		[MonthLong] NVARCHAR(12) NULL,

		[QuarterCode] INT NULL,  
		[QuarterNumber] INT NULL, 
		[QuarterName] NVARCHAR(20) NULL,
		[Quarter] NVARCHAR(2) NULL,

		[Year] INT NULL,

		[FiscalMonthCode] INT NULL,  
		[FiscalMonthNumber] INT NULL, 
		[FiscalMonthName] NVARCHAR(20) NULL,

		[FiscalQuarterCode] INT NULL,  
		[FiscalQuarterNumber] INT NULL, 
		[FiscalQuarterName] NVARCHAR(20) NULL,

		[FiscalYear] INT NULL,
		[FiscalYearName] VARCHAR(10) NULL,

		[FirstDateofYear] DATE NULL,
		[LastDateofYear] DATE NULL,
		[FirstDateofQuarter] DATE NULL,
		[LastDateofQuarter] DATE NULL,
		[FirstDateofMonth] DATE NULL,
		[LastDateofMonth] DATE NULL,
		[FirstDateofWeek] DATE NULL,
		[LastDateofWeek] DATE NULL,

		[CurrentYear] SMALLINT NULL,
		[CurrentQuarter] SMALLINT NULL,
		[CurrentMonth] SMALLINT NULL,
		[CurrentWeek] SMALLINT NULL,
		[CurrentDay] INT NULL,

		[IsToday] BIT NULL,
		[IsWeekend] BIT NULL,
		[IsHoliday] BIT NULL,
		[HolidayName] VARCHAR(20) NULL,
		[SpecialDays] VARCHAR(20) NULL,
		[CalendarIsFutureFlag] BIT NULL,
		[DWModifiedDate] DATETIME
	) 

	END

	DROP TABLE IF EXISTS #Calendar
	
		SELECT * INTO #Calendar FROM dim.Calendar WHERE 1 = 2

	IF NOT EXISTS (SELECT * FROM dim.Calendar WHERE CalendarID = 19000101)

		BEGIN

	-- Insert unknown member
			INSERT INTO #Calendar (
				[CalendarID],
				[CalendarKey],
				[CalendarDate]
			)
			SELECT 
				@UnknownDate	AS [CalendarID],
				@UnknownDate	AS [CalendarKey],
				@UnknownDate	AS [CalendarDate]
		END

	-- Insert data
	SET @start_date = IIF((SELECT MIN(CalendarID) FROM dim.Calendar) IS NULL,DATEFROMPARTS(@YearFirst,1,1),(SELECT MAX(CalendarKey) FROM dim.Calendar))
	SET @end_date	= DATEFROMPARTS(@YearsAhead+YEAR(GETDATE()),12,31)

	WHILE @start_date <= @end_date AND @start_date <> @end_date
	BEGIN
		INSERT INTO #Calendar (
			[CalendarID],
			[CalendarKey],
			[CalendarDate]
		)
		SELECT
			[CalendarID]= CONVERT(INT,CONVERT(VARCHAR(8), @start_date,112)),
			[CalendarKey] = @start_date,
			[CalendarDate] = @start_date
		
		SET @start_date = DATEADD(dd, 1, @start_date);
	END;

	-- Update Columns
	UPDATE #Calendar
	SET [DayNumber] = DATEPART(dd,[CalendarDate]),
		-- Week
		[WeekCode] = CONVERT(VARCHAR,DATEPART(YY,[CalendarDate])) + RIGHT('0'+ CONVERT(VARCHAR,DATEPART(ISO_WEEK,[CalendarDate])),2),
		[WeekNumber] = DATEPART(ISO_WEEK,[CalendarDate]),
		[WeekYear] = DATEPART(YY,[CalendarDate]),
		[WeekName] = 'Week '+ RIGHT('0'+ CONVERT(VARCHAR,DATEPART(ISO_WEEK,[CalendarDate])),2) + ', ' + CONVERT(VARCHAR,DATEPART(YY,[CalendarDate])),
		[WeekDayNumber] = DATEPART(dw,[CalendarDate]),
		[WeekDayName] =
		CASE DATEPART(dw,[CalendarDate])
			WHEN 1 THEN 'Monday'
			WHEN 2 THEN 'Tuesday'
			WHEN 3 THEN 'Wednesday'
			WHEN 4 THEN 'Thursday'
			WHEN 5 THEN 'Friday'
			WHEN 6 THEN 'Saturday'
			WHEN 7 THEN 'Sunday'
		END,
		-- Month
		[MonthCode] = 100*DATEPART(yy,[CalendarDate])+DATEPART(mm,[CalendarDate]),
		[MonthNumber] = MONTH([CalendarDate]), 
		[MonthName] =
			CASE DATEPART(MM,[CalendarDate])
				WHEN 1 THEN 'January'
				WHEN 2 THEN 'February'
				WHEN 3 THEN 'March'
				WHEN 4 THEN 'April'
				WHEN 5 THEN 'May'
				WHEN 6 THEN 'June'
				WHEN 7 THEN 'July'
				WHEN 8 THEN 'August'
				WHEN 9 THEN 'September'
				WHEN 10 THEN 'October'
				WHEN 11 THEN 'November'
				WHEN 12 THEN 'December'
			END + ', '+ CONVERT(VARCHAR,DATENAME(YEAR,[CalendarDate])),
		[MonthShort] =
			CASE DATEPART(MM,[CalendarDate])
				WHEN 1 THEN 'Jan'
				WHEN 2 THEN 'Feb'
				WHEN 3 THEN 'Mar'
				WHEN 4 THEN 'Apr'
				WHEN 5 THEN 'May'
				WHEN 6 THEN 'Jun'
				WHEN 7 THEN 'Jul'
				WHEN 8 THEN 'Aug'
				WHEN 9 THEN 'Sep'
				WHEN 10 THEN 'Oct'
				WHEN 11 THEN 'Nov'
				WHEN 12 THEN 'Dec'
			END,
		[MonthLong] =
			CASE DATEPART(MM,[CalendarDate])
				WHEN 1 THEN 'January'
				WHEN 2 THEN 'February'
				WHEN 3 THEN 'March'
				WHEN 4 THEN 'April'
				WHEN 5 THEN 'May'
				WHEN 6 THEN 'June'
				WHEN 7 THEN 'July'
				WHEN 8 THEN 'August'
				WHEN 9 THEN 'September'
				WHEN 10 THEN 'October'
				WHEN 11 THEN 'November'
				WHEN 12 THEN 'December'
			END,
		-- Quarter
		[QuarterCode] = 100*DATEPART(yy,[CalendarDate])+DATEPART(qq,[CalendarDate]),
		[QuarterNumber] = DATEPART(qq,[CalendarDate]),
		[QuarterName] = 'Q'+CONVERT(VARCHAR,DATENAME(QUARTER,[CalendarDate])) + ', ' + CONVERT(VARCHAR,DATENAME(YEAR,[CalendarDate])),
		[Quarter] = 'Q'+CONVERT(VARCHAR,DATENAME(QUARTER,[CalendarDate])),
		-- Year
		[Year] = DATEPART(yy,[CalendarDate]),
		-- Fiscal
		[FiscalMonthCode] = 100*DATEPART(yy,DATEADD(MM,-@FiscalEndMonth,[CalendarDate]))+DATEPART(mm,DATEADD(MM,-@FiscalEndMonth,[CalendarDate])),
		[FiscalMonthNumber] = DATEPART(MM,DATEADD(MM,-@FiscalEndMonth,[CalendarDate])),
		[FiscalMonthName] = CASE DATEPART(MM,[CalendarDate])
				WHEN 1 THEN 'January'
				WHEN 2 THEN 'February'
				WHEN 3 THEN 'March'
				WHEN 4 THEN 'April'
				WHEN 5 THEN 'May'
				WHEN 6 THEN 'June'
				WHEN 7 THEN 'July'
				WHEN 8 THEN 'August'
				WHEN 9 THEN 'September'
				WHEN 10 THEN 'October'
				WHEN 11 THEN 'November'
				WHEN 12 THEN 'December'
			END + ', '+ 
			CASE WHEN MONTH([CalendarDate]) <= @FiscalEndMonth 
				THEN CAST(YEAR(DATEADD(YY,-1,[CalendarDate])) AS VARCHAR)
				ELSE CAST(YEAR([CalendarDate]) AS NVARCHAR)
			END+'/'+CASE WHEN MONTH([CalendarDate]) <= @FiscalEndMonth 
				THEN SUBSTRING(CAST(YEAR([CalendarDate]) AS NVARCHAR),3,2)
				ELSE SUBSTRING(CAST(YEAR(DATEADD(YY,1,[CalendarDate])) AS VARCHAR),3,2)
			END,
		[FiscalQuarterCode] = 100*DATEPART(yy,DATEADD(MM,-@FiscalEndMonth,[CalendarDate]))+DATEPART(qq,DATEADD(MM,-@FiscalEndMonth,[CalendarDate])),
		[FiscalQuarterNumber] = DATEPART(QQ,DATEADD(MM,-@FiscalEndMonth,[CalendarDate])),
		[FiscalQuarterName] = 'Q'+CONVERT(VARCHAR,DATENAME(QUARTER,DATEADD(MM,-@FiscalEndMonth,[CalendarDate]))) + ', '+
			CASE WHEN MONTH([CalendarDate]) <= @FiscalEndMonth 
				THEN CAST(YEAR(DATEADD(YY,-1,[CalendarDate])) AS VARCHAR)
				ELSE CAST(YEAR([CalendarDate]) AS NVARCHAR)
			END+'/'+CASE WHEN MONTH([CalendarDate]) <= @FiscalEndMonth 
				THEN SUBSTRING(CAST(YEAR([CalendarDate]) AS NVARCHAR),3,2)
				ELSE SUBSTRING(CAST(YEAR(DATEADD(YY,1,[CalendarDate])) AS VARCHAR),3,2)
			END,
		[FiscalYear] = CASE WHEN MONTH([CalendarDate]) <= @FiscalEndMonth 
			THEN CAST(CAST(YEAR(DATEADD(YY,-1,[CalendarDate])) AS VARCHAR) AS INT) 
			ELSE CAST(CAST(YEAR([CalendarDate]) AS NVARCHAR) AS INT) 
		END,
		[FiscalYearName] = CASE WHEN MONTH([CalendarDate]) <= @FiscalEndMonth 
			THEN CAST(YEAR(DATEADD(YY,-1,[CalendarDate])) AS VARCHAR)
			ELSE CAST(YEAR([CalendarDate]) AS NVARCHAR)
		END+'/'+CASE WHEN MONTH([CalendarDate]) <= @FiscalEndMonth 
			THEN SUBSTRING(CAST(YEAR([CalendarDate]) AS NVARCHAR),3,2)
			ELSE SUBSTRING(CAST(YEAR(DATEADD(YY,1,[CalendarDate])) AS VARCHAR),3,2)
		END,

		-- First & Last
		[FirstDateofYear] = CAST(CAST(YEAR([CalendarDate]) AS VARCHAR(4)) + '-01-01' AS DATE),
		[LastDateofYear] = CAST(CAST(YEAR([CalendarDate]) AS VARCHAR(4)) + '-12-31' AS DATE),
		[FirstDateofQuarter] = DATEADD(qq,DATEDIFF(qq,0,[CalendarDate]), 0),
		[LastDateofQuarter] = DATEADD(dd,-1,DATEADD(qq,DATEDIFF(qq,0,[CalendarDate])+1,0)),
		[FirstDateofMonth] = CAST(CAST(YEAR([CalendarDate]) AS VARCHAR(4))+'-'+CAST(MONTH([CalendarDate]) AS VARCHAR(2))+'-01' AS DATE),
		[LastDateofMonth] = EOMONTH([CalendarDate]),
		[FirstDateofWeek] = DATEADD(dd,-(DATEPART(dw,@start_date)-1),[CalendarDate]),
		[LastDateofWeek] = DATEADD(dd,7-(DATEPART(dw,@start_date)),[CalendarDate]),
		[CurrentYear] = DATEDIFF(yy,GETDATE(),[CalendarDate]),
		[CurrentQuarter] = DATEDIFF(q,GETDATE(),[CalendarDate]),
		[CurrentMonth] = DATEDIFF(m,GETDATE(),[CalendarDate]),
		[CurrentWeek] = DATEDIFF(ww,GETDATE(),DATEADD(day,-1,[CalendarDate])),
		[CurrentDay] = DATEDIFF(dd,GETDATE(),[CalendarDate]),
		[IsToday] = 0,
		[IsWeekend] = 
		CASE DATEPART(dw,[CalendarDate])
			WHEN 1 THEN 0
			WHEN 2 THEN 0
			WHEN 3 THEN 0
			WHEN 4 THEN 0
			WHEN 5 THEN 0
			WHEN 6 THEN 1
			WHEN 7 THEN 1
		END,
		[IsHoliday] = 0,
		[DWModifiedDate] = GETDATE()

	-- Update the WeekYear for the week number 1
	UPDATE #Calendar WITH (TABLOCK)
	SET  [WeekYear]=[Year]+1
		,[DWModifiedDate] = GETDATE()
	WHERE [WeekNumber]=1 AND [MonthNumber]=12
	
	-- Update the WeekYear for the week number 52/53
	UPDATE #Calendar WITH (TABLOCK)
	SET  [WeekYear]=[Year]-1
		,[DWModifiedDate] = GETDATE()
	WHERE [WeekNumber]>=52 AND [MonthNumber]=1


	--
	-- Set Holidays
	--
	-- Christmas
	UPDATE #Calendar WITH (TABLOCK)
	SET [IsHoliday] = 1
		,[HolidayName] = 'Christmas'
		,[DWModifiedDate] = GETDATE()
	WHERE ([MonthNumber] = 12 AND [DayNumber] = 24)
		OR ([MonthNumber] = 12 AND [DayNumber] = 25)
		OR ([MonthNumber] = 12 AND [DayNumber] = 26)

	-- New Year
	UPDATE #Calendar WITH (TABLOCK)
	SET [IsHoliday] = 1
		,[HolidayName] = 'New Year'
		,[DWModifiedDate] = GETDATE()
	WHERE ([MonthNumber] = 12 AND [DayNumber] = 31)
		OR ([MonthNumber] = 1 AND [DayNumber] = 1)

	-- Easter
	UPDATE #Calendar WITH (TABLOCK)
	SET [IsHoliday] = 1
		,[HolidayName] = e.EasterDayUKName  --e.EasterDayDKName
		,[DWModifiedDate] = GETDATE()
	FROM
		#Calendar c
	INNER JOIN (
			SELECT
				e.CalendarDate
				,e.EasterDayUKName
				,e.EasterDayDKName
			FROM (
				SELECT DISTINCT [Year]
				FROM #Calendar
				) c
				CROSS APPLY meta.GetEasterDaysFromYear(c.[Year]) e
		) e
			ON c.CalendarDate=e.CalendarDate

	-- Set SpecialDays
	UPDATE #Calendar WITH (TABLOCK)
	SET  SpecialDays = 'Valentines Day'
		,[DWModifiedDate] = GETDATE()
	WHERE ([MonthNumber] = 2 AND [DayNumber] = 14)

	-- Set CalendarIsFutureFlag
	UPDATE #Calendar WITH (TABLOCK)
	SET  [CalendarIsFutureFlag] = IIF([CalendarKey] <= CAST(GETDATE() AS DATE),0,1)
		,[DWModifiedDate] = GETDATE()


	DELETE Calendar WITH (TABLOCK) FROM dim.Calendar WHERE EXISTS (SELECT 1 FROM #Calendar WHERE #Calendar.CalendarID = Calendar.CalendarID)

	INSERT INTO dim.Calendar WITH (TABLOCK)
	([CalendarID]
      ,[CalendarKey]
      ,[CalendarDate]
      ,[DayNumber]
      ,[WeekCode]
      ,[WeekNumber]
      ,[WeekName]
      ,[WeekYear]
      ,[WeekDayNumber]
      ,[WeekDayName]
      ,[MonthCode]
      ,[MonthNumber]
      ,[MonthName]
      ,[MonthShort]
      ,[MonthLong]
      ,[QuarterCode]
      ,[QuarterNumber]
      ,[QuarterName]
      ,[Quarter]
      ,[Year]
      ,[FiscalMonthCode]
      ,[FiscalMonthNumber]
      ,[FiscalMonthName]
      ,[FiscalQuarterCode]
      ,[FiscalQuarterNumber]
      ,[FiscalQuarterName]
      ,[FiscalYear]
      ,[FiscalYearName]
      ,[FirstDateofYear]
      ,[LastDateofYear]
      ,[FirstDateofQuarter]
      ,[LastDateofQuarter]
      ,[FirstDateofMonth]
      ,[LastDateofMonth]
      ,[FirstDateofWeek]
      ,[LastDateofWeek]
      ,[CurrentYear]
      ,[CurrentQuarter]
      ,[CurrentMonth]
      ,[CurrentWeek]
      ,[CurrentDay]
      ,[IsToday]
      ,[IsWeekend]
      ,[IsHoliday]
      ,[HolidayName]
      ,[SpecialDays]
	  ,[CalendarIsFutureFlag]
	  ,[DWModifiedDate])

	  SELECT
		[CalendarID]
      ,[CalendarKey]
      ,[CalendarDate]
      ,[DayNumber]
      ,[WeekCode]
      ,[WeekNumber]
      ,[WeekName]
      ,[WeekYear]
      ,[WeekDayNumber]
      ,[WeekDayName]
      ,[MonthCode]
      ,[MonthNumber]
      ,[MonthName]
      ,[MonthShort]
      ,[MonthLong]
      ,[QuarterCode]
      ,[QuarterNumber]
      ,[QuarterName]
      ,[Quarter]
      ,[Year]
      ,[FiscalMonthCode]
      ,[FiscalMonthNumber]
      ,[FiscalMonthName]
      ,[FiscalQuarterCode]
      ,[FiscalQuarterNumber]
      ,[FiscalQuarterName]
      ,[FiscalYear]
      ,[FiscalYearName]
      ,[FirstDateofYear]
      ,[LastDateofYear]
      ,[FirstDateofQuarter]
      ,[LastDateofQuarter]
      ,[FirstDateofMonth]
      ,[LastDateofMonth]
      ,[FirstDateofWeek]
      ,[LastDateofWeek]
      ,[CurrentYear]
      ,[CurrentQuarter]
      ,[CurrentMonth]
      ,[CurrentWeek]
      ,[CurrentDay]
      ,[IsToday]
      ,[IsWeekend]
      ,[IsHoliday]
      ,[HolidayName]
      ,[SpecialDays]
	  ,[CalendarIsFutureFlag]
	  ,[DWModifiedDate]
	FROM 
		#Calendar

	-- Set IsToday in dimension
	UPDATE dim.Calendar WITH (TABLOCK)
		SET [IsToday] = 0
		,[DWModifiedDate] = GETDATE()
	WHERE [IsToday] = 1

	-- Set IsToday
	UPDATE dim.Calendar WITH (TABLOCK)
		SET [IsToday] = 1
		,[DWModifiedDate] = GETDATE()
	WHERE [CalendarDate] = CAST(GETDATE() AS DATE);


		--CurrentYear, CurrentMonth, CurrentWeek
		
	UPDATE dim.Calendar WITH (TABLOCK)
		SET [CurrentYear] = DATEDIFF(yy,GETDATE(),[CalendarDate]),
		[CurrentQuarter] = DATEDIFF(q,GETDATE(),[CalendarDate]),
		[CurrentMonth] = DATEDIFF(m,GETDATE(),[CalendarDate]),
		[CurrentWeek] = DATEDIFF(ww,GETDATE(),DATEADD(day,-1,[CalendarDate])),
		[CurrentDay] = DATEDIFF(dd,GETDATE(),[CalendarDate]),
		[DWModifiedDate] = GETDATE()


	-- Create View
	IF OBJECT_ID('dimView.Calendar') IS NULL 
	
	BEGIN		

	EXEC('CREATE VIEW dimView.Calendar AS
	SELECT 
		[CalendarID]
      ,[CalendarKey]
      ,[CalendarDate]
      ,[DayNumber]
      ,[WeekCode]
      ,[WeekNumber]
      ,[WeekName]
      ,[WeekYear]
      ,[WeekDayNumber]
      ,[WeekDayName]
      ,[MonthCode]
      ,[MonthNumber]
      ,[MonthName]
	  ,[MonthShort]
	  ,[MonthLong]
      ,[QuarterCode]
      ,[QuarterNumber]
      ,[QuarterName]
	  ,[Quarter]
      ,[Year]
      ,[FiscalMonthCode]
      ,[FiscalMonthNumber]
      ,[FiscalMonthName]
      ,[FiscalQuarterCode]
      ,[FiscalQuarterNumber]
      ,[FiscalQuarterName]
      ,[FiscalYear]
      ,[FiscalYearName]
      ,[FirstDateofYear]
      ,[LastDateofYear]
      ,[FirstDateofQuarter]
      ,[LastDateofQuarter]
      ,[FirstDateofMonth]
      ,[LastDateofMonth]
      ,[FirstDateofWeek]
      ,[LastDateofWeek]
      ,[CurrentYear]
      ,[CurrentQuarter]
      ,[CurrentMonth]
      ,[CurrentWeek]
      ,[CurrentDay]
      ,[IsToday]
      ,[IsWeekend]
      ,[IsHoliday]
      ,[HolidayName]
      ,[SpecialDays]
	  ,[CalendarIsFutureFlag]
	FROM dim.Calendar')
	END
END
GO
PRINT N'Creating [meta].[CreateTimeDimension]...';


GO

CREATE procedure [meta].[CreateTimeDimension] as 

	-- Drop the table if it already exists
IF OBJECT_ID('dim.Time', 'U') IS NOT NULL
BEGIN
    DROP TABLE dim.Time;
END
 
-- Then create a new table
CREATE TABLE dim.[Time](
    [TimeID] [int] IDENTITY(1,1) NOT NULL,
    [TimeHourKey] [int] NULL,
    [TimeMinuteKey] [int] NULL,
    [Time] [time](0) NULL,
    [TimeDayPart] [nvarchar](10) NULL,
    [TimeHourFromTo] [nvarchar](13) NULL,
    [TimeNotation] [nvarchar](10) NULL
);
 
-- Needed if the dimension already existed
-- with other column, otherwise the validation
-- of the insert could fail.
 
-- Create a time and a counter variable for the loop
DECLARE @Time as time;
SET @Time = '0:00';
 
DECLARE @counter as int;
SET @counter = 0;
 
 
-- Two variables to store the day part for two languages
DECLARE @daypartEN as varchar(20);
set @daypartEN = '';
  
-- Loop 1440 times (24hours * 60minutes)
WHILE @counter < 1440
BEGIN
 
    -- Determine datepart
    SELECT  @daypartEN = CASE
                         WHEN (@Time >= '0:00' and @Time < '6:00') THEN 'Night'
                         WHEN (@Time >= '6:00' and @Time < '12:00') THEN 'Morning'
                         WHEN (@Time >= '12:00' and @Time < '18:00') THEN 'Afternoon'
                         ELSE 'Evening'
                         END;
 
    INSERT INTO dim.Time (                    
						 [TimeHourKey]
						,[TimeMinuteKey]
						,[Time]
						,[TimeDayPart]
						,[TimeHourFromTo]
						,[TimeNotation]
						)
                VALUES (
                         DATEPART(Hour, @Time) + 1
                       , DATEPART(Minute, @Time) + 1
					   , @Time
                       , @daypartEN
                       , CAST(DATEADD(Minute, -DATEPART(Minute,@Time), @Time) as varchar(5)) + ' - ' + CAST(DATEADD(Hour, 1, DATEADD(Minute, -DATEPART(Minute,@Time), @Time)) as varchar(5))
                       , CAST(@Time as varchar(5))
                       );
 
    -- Raise time with one minute
    SET @Time = DATEADD(minute, 1, @Time);
 
    -- Raise counter by one
    set @counter = @counter + 1;
END

EXEC('Create View dimView.Time AS
					SELECT * FROM dim.Time')
GO
PRINT N'Creating [meta].[CreateDWRelations]...';


GO


/**********************************************************************************************************************************************************************
The below script creates the a dataset with the relations between fact/bridge and dimensions. 
The script is used in the stored procedure etl.LoadFact and when fact and bridges are created throug BIML.
***********************************************************************************************************************************************************************/


CREATE PROCEDURE [meta].[CreateDWRelations]

 @Table NVARCHAR(128) 

 AS

SET NOCOUNT ON

DECLARE @DatabaseNameDW NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW')
DECLARE @DatabaseNameStage NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameStage')
DECLARE @BusinessKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'BusinessKeySuffix')

EXEC('/*1. Create a dataset with all base dimensions--*/

						SELECT DISTINCT 
							   TABLE_NAME  AS BaseDimensionName
							  ,COLUMN_NAME AS BaseDimensionColumnName	
							  --The case statement removes the dimension name from the column in order to identity composite keys where part of the key has it own dimension
							  ,CASE 
									WHEN REPLACE(COLUMN_NAME, TABLE_NAME, '''') = ''' + @BusinessKeySuffix + ''' 
										THEN COLUMN_NAME
									ELSE REPLACE(COLUMN_NAME, TABLE_NAME, '''') 
							   END AS DimensionCompositeKeyColumnName 
							  --The last column is the column name of that comes from the fact. It only differs on the calendar dimension
							  ,COLUMN_NAME AS ColumnNameFromFact	
							  INTO #BaseDimensions
						FROM 
							[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.COLUMNS
						
						WHERE 
							    COLUMN_NAME LIKE ''%' + @BusinessKeySuffix + '''
							AND TABLE_SCHEMA = ''dim''

										
						

/*2. Create a dataset with all fact columns*/

						
						SELECT 
							   TABLE_NAME AS FactName
							  ,COLUMN_NAME AS FactColumnName
							  INTO #FactColumns
						FROM 
							[' + @DatabaseNameStage + '].INFORMATION_SCHEMA.COLUMNS

						WHERE 
							    COLUMN_NAME LIKE ''%' + @BusinessKeySuffix + '''
							AND TABLE_NAME = ''' + @Table + '''
							AND TABLE_SCHEMA = ''stage''
						

/*3. Create a dataset with all role playing dimensions*/

						
						SELECT DISTINCT
						       FactColumns.FactName
							  ,FactColumns.FactColumnName
							  ,MatchBaseAndRolePlaying.BaseDimensionName
							  ,MatchBaseAndRolePlaying.DimensionCompositeKeyColumnName 
							  ,REPLACE(
										FactColumns.FactColumnName,
										REPLACE(
											    MatchBaseAndRolePlaying.DimensionCompositeKeyColumnName,
											    MatchBaseAndRolePlaying.BaseDimensionName,
											    ''''
											    ),
										''''
									   ) AS RolePlayingDimensionName
							  --Since the rows are multiplied when joining role playing dimensions with base dimensions a row number is added to identify unique role playing dimensions 
							  ,ROW_NUMBER() OVER (
													PARTITION BY MatchBaseAndRolePlaying.BaseDimensionName 
													ORDER BY LEN(MatchBaseAndRolePlaying.BaseDimensionColumnName)
												  ) AS RowNumberUniqueRolePlayingDimensions
							  --Since the rows are multiplied when joining role playing dimensions with base dimensions a row number is added to identify unique role playing dimension keys 
							  ,ROW_NUMBER() OVER (
													PARTITION BY FactColumns.FactColumnName 
													ORDER BY CHARINDEX(REPLACE(MatchBaseAndRolePlaying.DimensionCompositeKeyColumnName,''' + @BusinessKeySuffix + ''',''''), FactColumns.FactColumnName) 
													 
													 --Substracting the number of characters from RolePlayingDimensionName columns in order to secure that only rows which holds the exact name of the roleplaying dimensions has RowN = 1
													 - LEN(REPLACE( 
																FactColumns.FactColumnName,
																REPLACE(
																		MatchBaseAndRolePlaying.DimensionCompositeKeyColumnName,
																		MatchBaseAndRolePlaying.BaseDimensionName,
																		''''
																		),
																''''
															   ) 
													) DESC
												  ) AS RowNumberRolePlayingDimensionsKeys
							INTO #RolePlayingDimensions
						FROM 
							#FactColumns AS FactColumns
						--The first join is used for removing base dimensions from the list of columns
						LEFT JOIN 
							#BaseDimensions AS BaseDimensions
								ON FactColumns.FactColumnName = BaseDimensions.ColumnNameFromFact  
						--The second join matches the role playing dimensions with the base dimensions
						INNER JOIN 
							#BaseDimensions AS MatchBaseAndRolePlaying
								ON FactColumns.FactColumnName LIKE MatchBaseAndRolePlaying.BaseDimensionName + ''%''
						WHERE 
							BaseDimensions.DimensionCompositeKeyColumnName IS NULL
							
						



/*4. Create a dataset with SCD2 dimensions*/

						
						    SELECT DISTINCT
							   tables.name AS SCD2DimensionName
							   INTO #SCD2Dimensions
							FROM
							   [' + @DatabaseNameDW + '].sys.tables
							INNER JOIN 
							   [' + @DatabaseNameDW + '].sys.all_columns 
									ON all_columns.object_id=tables.object_id
							INNER JOIN 
							   [' + @DatabaseNameDW + '].sys.extended_properties
									ON extended_properties.major_id=tables.object_id 
									AND extended_properties.minor_id=all_columns.column_id 
									AND extended_properties.class=1
							WHERE
							   extended_properties.name = ''SCDColumn''
						
						

/*5. Create a dataset with all dimensions including role playing dimensions*/


						--Base Dimensions

						SELECT DimensionCompositeKeyColumnName 
							  ,BaseDimensionColumnName
							  ,BaseDimensionName
							  ,BaseDimensionName AS BaseAndRolePlayingDimensionName
							  INTO #BaseAndRolePlayingDimensions
						FROM 
							#BaseDimensions AS BaseDimensions


						UNION

						-- Role Playing Dimensioner

						SELECT 
	  
							   CASE -- If the columnname minus the dimensionname exist in the fact the base dimension key is used
									WHEN KeyIsPartOfOtherDimension.BaseDimensionName IS NOT NULL
										THEN REPLACE(BaseDimensions.BaseDimensionColumnName ,RolePlayingDimensions.BaseDimensionName,'''') 
									-- If it is the calendar dimension the column from the fact is used
									ELSE 
										CASE 
											WHEN RolePlayingDimensions.BaseDimensionName = ''Calendar'' 
												THEN FactColumnName										
									-- Else the correct name is created from name of the role playing dimension and the base dimension key columns
											ELSE CONCAT(RolePlayingDimensions.RolePlayingDimensionName,REPLACE(BaseDimensions.BaseDimensionColumnName,RolePlayingDimensions.BaseDimensionName ,'''')) 
									    END
							   END AS DimensionCompositeKeyColumnName
							  ,BaseDimensions.BaseDimensionColumnName
							  ,RolePlayingDimensions.BaseDimensionName
							  ,RolePlayingDimensions.RolePlayingDimensionName AS BaseAndRolePlayingDimensionName
						FROM 
							#RolePlayingDimensions AS RolePlayingDimensions
						-- Der joines med basis dimensionerne for at f? r?kkerne eksploderet ud og f? de korrekte n?glekolonner
						INNER JOIN 
							#BaseDimensions AS BaseDimensions
								ON RolePlayingDimensions.BaseDimensionName = BaseDimensions.BaseDimensionName
						LEFT JOIN
							#BaseDimensions AS KeyIsPartOfOtherDimension
								ON REPLACE(BaseDimensions.BaseDimensionColumnName ,RolePlayingDimensions.BaseDimensionName,'''') = KeyIsPartOfOtherDimension.BaseDimensionColumnName
						-- Skal kun bruge de unikke Role Playing dimensioner 
						WHERE 
							RolePlayingDimensions.RowNumberRolePlayingDimensionsKeys = 1

						


--/*6. Create a dataset which maps fact/bridge and dimensions.*/

					
						SELECT DISTINCT
							   FactColumns.FactName
							  ,BaseAndRolePlayingDimensions.BaseDimensionName
							  ,CASE 
									WHEN FactColumns.FactColumnName = BaseAndRolePlayingDimensions.BaseDimensionColumnName 
										THEN BaseAndRolePlayingDimensions.BaseDimensionColumnName 
							   	    ELSE BaseAndRolePlayingDimensions.DimensionCompositeKeyColumnName 
							   END AS FactColumnName
							  ,BaseAndRolePlayingDimensions.BaseDimensionColumnName
							  ,ISNULL(RolePlayingDimensions.RolePlayingDimensionName,BaseDimensions.BaseDimensionName) AS BaseAndRolePlayingDimensionName
							  INTO #MapFactsAndDimensions
						FROM 
							#FactColumns AS FactColumns
						--First step is to match fact columns with base dimension columns. This gives us the dimension name which is used when mapping to BaseAndRolePlayingDimensions
						LEFT JOIN 
							#BaseDimensions AS BaseDimensions
								ON FactColumns.FactColumnName = BaseDimensions.ColumnNameFromFact 
						--Second step is to match the role playing dimensions to get the role playing dimension name
						LEFT JOIN 
							#RolePlayingDimensions AS RolePlayingDimensions
								ON RolePlayingDimensions.FactColumnName = FactColumns.FactColumnName
								AND RowNumberRolePlayingDimensionsKeys = 1
						--Third step is to match with the combined list of dimensions  
						LEFT JOIN 
							#BaseAndRolePlayingDimensions AS BaseAndRolePlayingDimensions
								ON ISNULL(RolePlayingDimensions.RolePlayingDimensionName,BaseDimensions.BaseDimensionName) = BaseAndRolePlayingDimensions.BaseAndRolePlayingDimensionName
						WHERE 
							BaseAndRolePlayingDimensions.BaseDimensionName IS NOT NULL

						



/*7. Create the final dataset which filter out incorrect mappings and make the final transformations.*/


						SELECT 
							   MapFactsAndDimensions.FactName
							  ,MapFactsAndDimensions.BaseDimensionName
							  ,MapFactsAndDimensions.FactColumnName
							  ,MapFactsAndDimensions.BaseDimensionColumnName
							  ,MapFactsAndDimensions.BaseAndRolePlayingDimensionName
							  --This case indicates whether a dimension is a SCD2 dimension
							  ,CASE 
									WHEN MapFactsAndDimensions.BaseDimensionName IN (SELECT SCD2DimensionName FROM #SCD2Dimensions) 
										THEN N''Yes''
									ELSE N''No'' 
							   END AS IsSCD2DimensionFlag
							  --This case indicates whether a column is part of a composite key and primary key in its own dimension which is a SCD2 dimension. Information is used in etl.LoadFact
							  ,CASE 
									WHEN REPLACE(MapFactsAndDimensions.FactColumnName,''' + @BusinessKeySuffix + ''','''') IN (SELECT SCD2DimensionName FROM #SCD2Dimensions) 
										THEN N''Yes''
									ELSE N''No'' 
							   END AS IsSCD2CompositeKeyDimensionFlag
							  --Creates a ordinal position with the correct ordering
							  ,ROW_NUMBER() OVER (
													PARTITION BY  MapFactsAndDimensions.FactName 
													ORDER BY MapFactsAndDimensions.BaseAndRolePlayingDimensionName,MapFactsAndDimensions.BaseDimensionColumnName
												  ) AS ColumnOrdinalPosition
							  --This case indicates the when a row goes from one dimension to the next. 
							  ,CASE 
									WHEN ROW_NUMBER() OVER (
															PARTITION BY MapFactsAndDimensions.BaseAndRolePlayingDimensionName 
															ORDER BY MapFactsAndDimensions.BaseAndRolePlayingDimensionName,MapFactsAndDimensions.BaseDimensionColumnName
															) = 1 
										THEN N''Yes''
									ELSE N''No'' 
							   END AS IsNewDimensionFlag
							  --This case adds the default error value to the dataset
							  ,CASE 
									WHEN MapFactsAndDimensions.BaseDimensionName = ''Calendar'' 
										THEN (SELECT CONVERT(NVARCHAR(128),value) FROM sys.extended_properties WHERE class_desc = ''DATABASE'' and name = ''DefaultDate'')
									ELSE (SELECT CONVERT(NVARCHAR(128),value) FROM sys.extended_properties WHERE class_desc = ''DATABASE'' and name = ''DefaultDimensionMemberID'')
							   END AS DefaultErrorValue
							INTO #OnlyFactColumns
						FROM 
							#MapFactsAndDimensions AS MapFactsAndDimensions
						--The last join filter out incorrect mappings
						INNER JOIN 
							#FactColumns AS FactColumns 
								ON FactColumns.FactColumnName = MapFactsAndDimensions.FactColumnName
						

/*8.Remove mappings where only part of composite key is mapped to fact like CompanyKey*/
								
		SELECT 
			FactName
		   ,BaseDimensionName
		   ,FactColumnName
		   ,BaseDimensionColumnName
		   ,BaseAndRolePlayingDimensionName
		   ,IsSCD2DimensionFlag
		   ,IsSCD2CompositeKeyDimensionFlag
		   ,ROW_NUMBER() OVER (PARTITION BY  FactName ORDER BY IsSCD2DimensionFlag,ColumnOrdinalPosition ) AS ColumnOrdinalPosition
		   ,IsNewDimensionFlag
		   ,DefaultErrorValue
		FROM 
			#OnlyFactColumns
		WHERE
			BaseDimensionName IN (SELECT DISTINCT BaseDimensionName FROM #OnlyFactColumns WHERE BaseDimensionColumnName LIKE BaseDimensionName + ''%'')
			
		DROP TABLE #OnlyFactColumns
		DROP TABLE #MapFactsAndDimensions
		DROP TABLE #FactColumns
		DROP TABLE #BaseAndRolePlayingDimensions
		DROP TABLE #RolePlayingDimensions
		DROP TABLE #BaseDimensions
		DROP TABLE #SCD2Dimensions')

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[CreateFactSourceScript]...';


GO



/**********************************************************************************************************************************************************************
The purpose of this scripts is to create the source code for fact and bridge loads. 
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[CreateFactSourceScript]

@Table NVARCHAR(128),--Input is the dimensions name without schema
@PrintSQL NVARCHAR(MAX) OUTPUT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/

DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10)
DECLARE @DatabaseNameStage NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameStage')
DECLARE @DatabaseNameDW NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW')
DECLARE @SurrogatKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'SurrogateKeySuffix')
DECLARE @BusinessKeySuffix NVARCHAR(10) =(SELECT VariableValue FROM meta.Variables WHERE VariableName = 'BusinessKeySuffix')
DECLARE @IsCloudFlag BIT = IIF((SELECT VariableValue FROM meta.Variables WHERE VariableName = 'IsCloudFlag') = '1',1,0)
DECLARE @StageSchemaTable TABLE (SchemaName NVARCHAR(10)) 
INSERT @StageSchemaTable EXEC('SELECT DISTINCT TABLE_SCHEMA FROM [' + @DatabaseNameStage + '].INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''' + @Table + ''' AND TABLE_SCHEMA IN (''dbo'',''stage'')')
DECLARE @StageSchema NVARCHAR(10) = (SELECT IIF(@IsCloudFlag = 1,'stage',(SELECT SchemaName FROM @StageSchemaTable))) --If on-premise and stageschema has not been changed

/**********************************************************************************************************************************************************************
1. Create and insert data into table variables
***********************************************************************************************************************************************************************/

DECLARE @InformationSchema TABLE (DatabaseName NVARCHAR(128),TableName NVARCHAR(128), ColumnName NVARCHAR(128), OrdinalPosition INT, DataType NVARCHAR(128), PrimaryKey INT)
DECLARE @Dimensions TABLE (TableName NVARCHAR(128), DimensionTable NVARCHAR(128), ColumnName NVARCHAR(128),ColumnMapping NVARCHAR(128),RolePlayingDimension NVARCHAR(128),IsSCD2Dimension NVARCHAR(10), IsSCD2CompositeKeyDimension NVARCHAR(10),OrdinalPosition INT,NewDimension NVARCHAR(128), ErrorValue NVARCHAR(128))
DECLARE @SCDCombinedKeys TABLE (DimensionTable NVARCHAR(128), ColumnName NVARCHAR(128), ColumnMapping NVARCHAR(128),OrdinalPosition INT, RolePlayingDimension NVARCHAR(128),NewDimension NVARCHAR(128), ErrorValue NVARCHAR(128))
DECLARE @SCDFromSource TABLE (DimensionTable NVARCHAR(128))

/*Generates the combined information schema*/
INSERT @InformationSchema EXEC('SELECT  ''Stage''
										,COLUMNS.TABLE_NAME
										,COLUMNS.COLUMN_NAME
										,ROW_NUMBER() OVER (ORDER BY COLUMNS.TABLE_NAME) AS ORDINAL_POSITION
										,COLUMNS.DATA_TYPE
										,CASE WHEN KEY_COLUMN_USAGE.COLUMN_NAME IS NULL THEN 0 ELSE 1 END AS PRIMARY_KEY
								FROM 
									[' + @DatabaseNameStage + '].INFORMATION_SCHEMA.COLUMNS
								LEFT JOIN 
									[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.KEY_COLUMN_USAGE
										ON COLUMNS.TABLE_NAME = KEY_COLUMN_USAGE.TABLE_NAME 
										AND COLUMNS.COLUMN_NAME = KEY_COLUMN_USAGE.COLUMN_NAME
								WHERE 
									    COLUMNS.TABLE_NAME = ''' + @Table + ''' 
									AND COLUMNS.COLUMN_NAME NOT LIKE ''DW%''
									AND COLUMNS.TABLE_SCHEMA = ''' + @StageSchema + '''

								UNION ALL

								SELECT  ''DW''
										,COLUMNS.TABLE_NAME
										,COLUMNS.COLUMN_NAME
										,ROW_NUMBER() OVER (ORDER BY COLUMNS.TABLE_NAME) AS ORDINAL_POSITION
										,COLUMNS.DATA_TYPE
										,CASE WHEN KEY_COLUMN_USAGE.COLUMN_NAME IS NULL THEN 0 ELSE 1 END AS PRIMARY_KEY
								FROM 
									[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.COLUMNS
								LEFT JOIN 
									[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.KEY_COLUMN_USAGE
										ON COLUMNS.TABLE_NAME = KEY_COLUMN_USAGE.TABLE_NAME 
										AND COLUMNS.COLUMN_NAME = KEY_COLUMN_USAGE.COLUMN_NAME
								WHERE 
									    COLUMNS.TABLE_NAME = ''' + @Table + ''' 
									AND COLUMNS.TABLE_SCHEMA = ''fact''
									AND COLUMNS.COLUMN_NAME NOT LIKE ''DW%'''
								
								)

							
/*Generates the mapping dataset between fact/bridge and dimensions*/
INSERT @Dimensions EXEC meta.CreateDWRelations @Table = @Table;

/*Generates a dataset with composite SCD keys*/
INSERT @SCDCombinedKeys SELECT Dimensions.DimensionTable
							  ,InformationSchema.ColumnName
							  ,Dimensions.ColumnMapping
							  ,ROW_NUMBER() OVER (ORDER BY Dimensions.DimensionTable,Dimensions.RolePlayingDimension,InformationSchema.ColumnName) AS ORDINAL_POSITION
							  ,CASE WHEN Dimensions.RolePlayingDimension IS NULL THEN Dimensions.DimensionTable 
									ELSE Dimensions.RolePlayingDimension 
							   END
							  ,CASE WHEN ROW_NUMBER() OVER (PARTITION BY CASE WHEN Dimensions.RolePlayingDimension IS NULL THEN Dimensions.DimensionTable 
																			  ELSE Dimensions.RolePlayingDimension 
																		 END ORDER BY Dimensions.DimensionTable,Dimensions.RolePlayingDimension,InformationSchema.ColumnName)  = 1 THEN N'Yes' 
									ELSE N'No' 
							   END 
							  ,Dimensions.ErrorValue
						FROM 
							@InformationSchema AS InformationSchema
						LEFT JOIN 
							@Dimensions AS Dimensions
								ON Dimensions.ColumnName = InformationSchema.ColumnName
						WHERE 
							Dimensions.IsSCD2Dimension = 'Yes' 
							AND InformationSchema.DatabaseName = 'Stage'

INSERT @SCDFromSource EXEC('SELECT DISTINCT TABLE_NAME FROM [' + @DatabaseNameStage + '].INFORMATION_SCHEMA.COLUMNS WHERE REPLACE(COLUMN_NAME,TABLE_NAME,'''') IN (''IsCurrent'',''ValidFromDate'',''ValidToDate'')') 							

/**********************************************************************************************************************************************************************
2. Create Loop counter variables and SCD2FromSource variable
***********************************************************************************************************************************************************************/

DECLARE @Counter INT 
DECLARE @MaxColumns INT  --Number of columns from stage
DECLARE @MaxSCDJoinColumns INT --Max position of composite SCD2 key columns
DECLARE @MaxJoinColumns INT --Max position of key columns from fact/bridge
DECLARE @MinIDNoSCDColumns INT --Min position of key column from stage which is not an SCD column
DECLARE @MaxColumnsKeys INT --Max position of primary key columns i fact/bridge
DECLARE @MaxColumnsFact INT --Number of columns in fact/bridge

SELECT 
	   @Counter = 1
	  ,@MaxColumns = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE DatabaseName = 'Stage' )
	  ,@MaxJoinColumns = (SELECT MAX(OrdinalPosition) FROM @Dimensions) 
	  ,@MaxSCDJoinColumns = (SELECT MAX(OrdinalPosition) FROM @SCDCombinedKeys) 
	  ,@MaxColumnsKeys = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE PrimaryKey = 1 AND DatabaseName = 'DW')
	  ,@MaxColumnsFact = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE DatabaseName = 'DW')
	  ,@MinIDNoSCDColumns = (SELECT MIN(OrdinalPosition) FROM @Dimensions WHERE NewDimension = 'Yes' AND IsSCD2Dimension = 'No') 
	 
/**********************************************************************************************************************************************************************
3. Create position and support variables
***********************************************************************************************************************************************************************/

DECLARE @HasCalendarKey INT 
DECLARE @PositionFirstNonSCDColumn INT

SELECT
	   @HasCalendarKey = CASE WHEN (SELECT COUNT(*) FROM @InformationSchema WHERE ColumnName = 'Calendar' + @BusinessKeySuffix) > 0 THEN 1 ELSE 0 END --Check if CalendarKey is present
	  ,@PositionFirstNonSCDColumn = (SELECT MIN(I.OrdinalPosition) FROM @InformationSchema I INNER JOIN @Dimensions D ON D.ColumnName = I.ColumnName WHERE IsSCD2Dimension = 'No') --Gives the position of the first non SCD column

/**********************************************************************************************************************************************************************
4. Create the select part of the source code for SCD dimensions
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderSelectSCD VARCHAR(MAX)
DECLARE @SelectSCD VARCHAR(MAX)

WHILE @Counter <= @MaxColumns

BEGIN

	SELECT @PlaceholderSelectSCD = --Check if it is the first column
								   CASE 
										WHEN @Counter = @PositionFirstNonSCDColumn 
											THEN ' '
										ELSE ','
								   END
								   
								   +
								   
								   --SCD2Composite keys is handled seperatly. Char columns is UPPER cased and date columns is cast to datetime
								   CASE 
										WHEN IsSCD2CompositeKeyDimension = 'Yes' 
											THEN CASE 
													WHEN InformationSchema.DataType LIKE '%char%' 
														THEN  'UPPER(' + InformationSchema.TableName + '.[' + InformationSchema.ColumnName + ']) AS [' + InformationSchema.ColumnName + ']'
													WHEN InformationSchema.DataType LIKE '%date%' 
														THEN  'CAST(' + InformationSchema.TableName + '.[' + InformationSchema.ColumnName + '] AS DATE) AS [' + InformationSchema.ColumnName + ']'
													ELSE '' + InformationSchema.TableName + '.[' + InformationSchema.ColumnName + ']' 
												 END
										ELSE CASE 
												WHEN InformationSchema.DataType LIKE '%char%' 
													THEN  'UPPER([' + InformationSchema.ColumnName + ']) AS [' + InformationSchema.ColumnName + ']'
												WHEN InformationSchema.DataType LIKE '%date%' 
													THEN  'CAST([' + InformationSchema.ColumnName + '] AS DATE) AS [' + InformationSchema.ColumnName + ']'
												ELSE '[' + InformationSchema.ColumnName + ']' 
											 END
									END

								   + 
								   
								   @CRLF
	FROM 
		@InformationSchema AS InformationSchema
	LEFT JOIN 
		@Dimensions AS Dimensions
			ON Dimensions.ColumnName = InformationSchema.ColumnName
	WHERE 
		    Dimensions.IsSCD2Dimension = 'No' 
		AND @Counter = InformationSchema.OrdinalPosition 
		AND InformationSchema.DatabaseName = 'Stage'


	SET @SelectSCD = CONCAT(@SelectSCD,@PlaceholderSelectSCD)

	SET @PlaceholderSelectSCD = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
5. Create the select part of the source code for non ID columns
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderSelect VARCHAR(MAX) = ''
DECLARE @Select VARCHAR(MAX) = ''

WHILE @Counter <= @MaxColumns

BEGIN

	SELECT @PlaceholderSelect = ',[' + InformationSchema.ColumnName + ']' + @CRLF
	FROM 
		@InformationSchema AS InformationSchema
	LEFT JOIN 
		@Dimensions AS Dimensions
			ON Dimensions.ColumnName = InformationSchema.ColumnName
	WHERE 
		Dimensions.DimensionTable IS NULL 
		AND @Counter = InformationSchema.OrdinalPosition 
		AND InformationSchema.DatabaseName = 'Stage'

	SET @Select = CONCAT(@Select,@PlaceholderSelect)

	SET @PlaceholderSelect = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
6. Create the select SCD ID part for source code and SCD ID with error handling for merge part
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderIDSCD VARCHAR(MAX)
DECLARE @IDSCD VARCHAR(MAX)

WHILE @Counter <= @MaxSCDJoinColumns

BEGIN

	SELECT @PlaceholderIDSCD = ',' + RolePlayingDimension + '.[' + DimensionTable + @SurrogatKeySuffix + ']' + CASE 
																								WHEN RolePlayingDimension <> DimensionTable 
																									THEN ' AS [' + RolePlayingDimension + @SurrogatKeySuffix + ']'
	  																							ELSE '' 
																							END + @CRLF
	FROM 
		@SCDCombinedKeys
	WHERE 
			@Counter = OrdinalPosition 
		AND NewDimension = 'Yes' 

	SET @IDSCD = CONCAT(@IDSCD,@PlaceholderIDSCD)

	SET @PlaceholderIDSCD = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
7. Create the the left join part for SCD dimensions
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderLeftJoinSCD VARCHAR(MAX) 
DECLARE @LeftJoinSCD VARCHAR(MAX) 

WHILE @Counter <= @MaxSCDJoinColumns

BEGIN

	SELECT @PlaceholderLeftJoinSCD = CASE
										WHEN NewDimension = 'Yes'
											THEN 'LEFT JOIN [' + @DatabaseNameDW + '].[dim].[' + SCDCombinedKeys.DimensionTable + '] ' + CASE 
																																			WHEN RolePlayingDimension IS NOT NULL 
																																				THEN ' AS [' + RolePlayingDimension + ']' 
																																			ELSE '' 
																																		 END + @CRLF + 'ON  ' + CASE 
																																									WHEN @HasCalendarKey = 1 AND SCDFromSource.DimensionTable IS NULL
																																										THEN @Table + '.[CalendarKey] BETWEEN ' + RolePlayingDimension + '.[DWValidFromDate] AND ' + RolePlayingDimension + '.[DWValidToDate]' 
																																									WHEN @HasCalendarKey = 1 AND SCDFromSource.DimensionTable IS NOT NULL
																																										THEN @Table + '.[CalendarKey] BETWEEN ' + RolePlayingDimension + '.[' + SCDFromSource.DimensionTable + 'ValidFromDate] AND ' + RolePlayingDimension + '.[' + SCDFromSource.DimensionTable + 'ValidToDate]' 
																																									WHEN @HasCalendarKey = 0 AND SCDFromSource.DimensionTable IS NOT NULL
																																										THEN RolePlayingDimension + '.[' + SCDFromSource.DimensionTable + 'IsCurrent] = 1 ' 
																																									ELSE RolePlayingDimension + '.[DWIsCurrent] = 1 ' 
																																								 END +  @CRLF + 'AND ' + RolePlayingDimension + '.[' + ColumnMapping  + '] = ' + @Table + '.[' + ColumnName + ']' 
										ELSE 'AND ' + RolePlayingDimension + '.[' + ColumnMapping + '] = ' + @Table + '.[' + ColumnName + ']' 
									 END + @CRLF
	FROM
		@SCDCombinedKeys AS SCDCombinedKeys
	LEFT JOIN 
		@SCDFromSource AS SCDFromSource
			ON SCDFromSource.DimensionTable = SCDCombinedKeys.DimensionTable
	WHERE 
		@Counter = OrdinalPosition
	
	SET @LeftJoinSCD = CONCAT(@LeftJoinSCD,@PlaceholderLeftJoinSCD)

	SET @PlaceholderLeftJoinSCD = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1



/**********************************************************************************************************************************************************************
8. Fill out dynamic SQL variables
***********************************************************************************************************************************************************************/


SET @PrintSQL = 'SELECT ' + @CRLF + ISNULL(@SelectSCD,'') + ISNULL(@IDSCD,'') + ISNULL(@Select,'') + 'FROM [' + @StageSchema + '].[' + @Table + ']' + @CRLF + ISNULL(@LeftJoinSCD,'')

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[CreateStageTablesFromBusinessMatrix]...';


GO


/**********************************************************************************************************************************************************************
The purpose of this scripts is to create the dummy destination tables in stage used  by GenerateFrameworkTransformLayer. The script is executed by BIML
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[CreateStageTablesFromBusinessMatrix] AS

SET NOCOUNT ON

	DECLARE @DatabaseNameStage NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameStage')
	DECLARE @Create VARCHAR(MAX)
	DECLARE @Counter INT = 1
	DECLARE @MaxID INT = (SELECT MAX(ID) FROM  meta.BusinessMatrix)
	DECLARE @InformationSchema TABLE (TABLE_NAME NVARCHAR(128))

	INSERT @InformationSchema EXEC('SELECT TABLE_NAME FROM [' + @DatabaseNameStage + '].INFORMATION_SCHEMA.TABLES')


	WHILE @Counter <= @MaxID BEGIN

		SELECT 
			@Create = 'CREATE TABLE [' + @DatabaseNameStage + '].[' + IIF(DestinationSchema = 'temp','stage_temp','stage') + '].[' + TableName + '] ([DummyColumn] int) '
		FROM 
			meta.BusinessMatrix
		WHERE 
			ID = @Counter AND 
			TransformExcludeFlag = 0 AND 
			TableName NOT IN ('Calendar','Time') AND
			TableName NOT IN (SELECT TABLE_NAME FROM @InformationSchema)

		EXEC(@Create)
		SET @Create = ''

		SET @Counter = @Counter + 1

	END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[CreateTransformProcedures]...';


GO



/**********************************************************************************************************************************************************************
The purpose of this scripts is to create the transform procedures for each object in the business matrix
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[CreateTransformProcedures] AS

SET NOCOUNT ON

	DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10)
	DECLARE @DatabaseNameStage NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameStage')
	DECLARE @Create VARCHAR(MAX)
	DECLARE @CreateFinal VARCHAR(MAX)
	DECLARE @Counter INT = 1
	DECLARE @MaxID INT = (SELECT MAX(ID) FROM  meta.BusinessMatrix)
	DECLARE @InformationSchema TABLE (TABLE_NAME NVARCHAR(128))


	INSERT @InformationSchema EXEC('SELECT REPLACE(NAME,''Transform_'','''') FROM [' + @DatabaseNameStage + '].SYS.PROCEDURES')


	WHILE @Counter <= @MaxID BEGIN

		SELECT 
			@Create = '
CREATE PROCEDURE [stage].[Transform_' + TableName + '] ' + @CRLF + @CRLF + IIF(FactAndBridgeIncrementalFlag = 1,'@JobIsIncremental BIT ','') + '
			
AS 
		
/**********************************************************************************************************************************************************************
1. Truncate Table
***********************************************************************************************************************************************************************/

TRUNCATE TABLE [' + IIF(DestinationSchema = 'Temp','stage_temp','stage') + '].[' + TableName  + ']' + IIF(FactAndBridgeIncrementalFlag = 1,'

/**********************************************************************************************************************************************************************
2. Business Logik - Remember to use the input variable @JobIsIncremental to distinguish between full and incremental load. 
***********************************************************************************************************************************************************************/

/*Full Load pattern

	INSERT INTO stage.[' + TableName + '] WITH (TABLOCK)
	(Columns)

	--Apply business logic for full load here

Incremental Pattern

IF @JobIsIncremental = 0 --Full Load

	BEGIN
		
		INSERT INTO stage.[' + TableName + '] WITH (TABLOCK)
		(Columns)

		--Apply business logic for full load here

	END

ELSE --Incremental Load

	BEGIN

		INSERT INTO stage.[' + TableName + '] WITH (TABLOCK)
		(Columns)

		--Apply business logic for incremental load here.
	END*/','

/**********************************************************************************************************************************************************************
2. Business Logik - Remember to use the input variable @JobIsIncremental to distinguish between full and incremental load. 
***********************************************************************************************************************************************************************/

/*Full Load pattern

	INSERT INTO stage.[' + TableName + '] WITH (TABLOCK)
	(Columns)

	--Apply business logic for full load here
*/')

		FROM 
			meta.BusinessMatrix
		WHERE 
			ID = @Counter AND 
			TransformExcludeFlag = 0 AND 
			TableName NOT IN ('Calendar','Time') AND
			TableName NOT IN (SELECT TABLE_NAME FROM @InformationSchema)

		SET @CreateFinal = 'USE [' + @DatabaseNameStage + ']' + @CRLF + 'EXEC(''' + @Create + ''')'
		
		EXEC(@CreateFinal)
		
		SET @Create = ''
		SET @CreateFinal = ''

		SET @Counter = @Counter + 1

	END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[DropStageTablesFromBusinessMatrix]...';


GO


CREATE PROCEDURE [meta].[DropStageTablesFromBusinessMatrix]

AS

SET NOCOUNT ON

DECLARE @DatabaseNameStage NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameStage')
DECLARE @Drop VARCHAR(MAX)
DECLARE @Counter INT = 1
DECLARE @MaxID INT 
DECLARE @InformationSchema TABLE (TABLE_NAME NVARCHAR(128), ORDINAL_POSITION INT)

INSERT @InformationSchema EXEC('SELECT DISTINCT TABLE_NAME 
											   ,ROW_NUMBER() OVER (ORDER BY TABLE_NAME) AS ORDINAL_POSITION
								FROM [' + @DatabaseNameStage + '].INFORMATION_SCHEMA.COLUMNS WHERE COLUMN_NAME = ''DummyColumn''')

SET @MaxID = (SELECT MAX(ORDINAL_POSITION) FROM @InformationSchema)

WHILE  @Counter <= @MaxID

BEGIN

SELECT @Drop = 'DROP TABLE [' + @DatabaseNameStage + '].stage.[' + TABLE_NAME + ']'

FROM @InformationSchema
WHERE @Counter = ORDINAL_POSITION

EXEC(@Drop)

SET @Counter = @Counter + 1

END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[FactPatternsDelta]...';


GO


/**********************************************************************************************************************************************************************
The purpose of this scripts is to insert delta rows in the fact temp table
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[FactPatternsDelta]

@Table NVARCHAR(128),--Input is the fact name without schema
@DestinationSchema NVARCHAR(128),
@CleanUpPartitionsFlag BIT,
@PrintSQL BIT 

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/

DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10)
DECLARE @DatabaseNameStage NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameStage')
DECLARE @DatabaseNameDW NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW')
DECLARE @SurrogateKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'SurrogateKeySuffix')
DECLARE @BusinessKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'BusinessKeySuffix')
DECLARE @IsCloudFlag BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'IsCloudFlag')
DECLARE @PrimaryKeys TABLE (TableName NVARCHAR(128), ColumnName NVARCHAR(128))
DECLARE @StageSchemaTable TABLE (SchemaName NVARCHAR(10)) 
INSERT @StageSchemaTable EXEC('SELECT DISTINCT TABLE_SCHEMA FROM [' + @DatabaseNameStage + '].INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''' + @Table + ''' AND TABLE_SCHEMA IN (''dbo'',''stage'')')
DECLARE @StageSchema NVARCHAR(10) = (SELECT IIF(@IsCloudFlag = 1,'stage',(SELECT SchemaName FROM @StageSchemaTable))) --If on-premise and stageschema has not been changed

/**********************************************************************************************************************************************************************
1. Create and insert data into table variables
***********************************************************************************************************************************************************************/

DECLARE @InformationSchema TABLE (DatabaseName NVARCHAR(128),TableName NVARCHAR(128), ColumnName NVARCHAR(128), OrdinalPosition INT, DataType NVARCHAR(128), PrimaryKey INT)
/*Generates the combined information schema*/
INSERT @InformationSchema EXEC('WITH PrimaryKeys AS
								(
								SELECT DISTINCT
										tables.name AS TableName
									   ,all_columns.name AS ColumnName
									FROM
									   [' + @DatabaseNameDW + '].sys.tables
									INNER JOIN 
									   [' + @DatabaseNameDW + '].sys.all_columns 
											ON all_columns.object_id=tables.object_id
									INNER JOIN 
									   [' + @DatabaseNameDW + '].sys.extended_properties
											ON extended_properties.major_id=tables.object_id 
											AND extended_properties.minor_id=all_columns.column_id 
											AND extended_properties.class=1
									WHERE
									   extended_properties.name = ''PrimaryKeyColumn''
									   AND tables.name = ''' + @Table + '''
								)

								SELECT  ''DW''
										,COLUMNS.TABLE_NAME
										,COLUMNS.COLUMN_NAME
										,ROW_NUMBER() OVER (ORDER BY COLUMNS.TABLE_NAME) AS ORDINAL_POSITION
										,COLUMNS.DATA_TYPE
										,CASE WHEN PrimaryKeys.ColumnName IS NULL THEN 0 ELSE 1 END AS PRIMARY_KEY
								FROM 
									[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.COLUMNS
								LEFT JOIN
									PrimaryKeys
										ON PrimaryKeys.ColumnName = COLUMNS.COLUMN_NAME
								WHERE 
									    COLUMNS.TABLE_NAME = ''' + @Table + ''' 
									AND COLUMNS.TABLE_SCHEMA IN (''fact'',''bridge'')
									AND COLUMNS.COLUMN_NAME NOT LIKE ''DW%'''
								
								)
				


/**********************************************************************************************************************************************************************
2. Create Loop counter variables and SCD2FromSource variable
***********************************************************************************************************************************************************************/

DECLARE @Counter INT 
DECLARE @MaxColumns INT  --Number of columns from stage
DECLARE @MaxSCDJoinColumns INT --Max position of composite SCD2 key columns
DECLARE @MaxJoinColumns INT --Max position of key columns from fact/bridge
DECLARE @MaxColumnsKeys INT --Max position of primary key columns i fact/bridge
DECLARE @MaxColumnsFact INT --Number of columns in fact/bridge
DECLARE @MinKeyCounter INT


SELECT 
	   @Counter = 1
	  ,@MaxColumns = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE DatabaseName = 'DW' )
	  ,@MaxColumnsKeys = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE PrimaryKey = 1 AND DatabaseName = 'DW')
	  ,@MinKeyCounter  = (SELECT MIN(OrdinalPosition) FROM @InformationSchema WHERE PrimaryKey = 1 AND DatabaseName = 'DW')
	

/**********************************************************************************************************************************************************************
3. Create the select part 
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderInsertColumns VARCHAR(MAX) = ''
DECLARE @InsertColumns VARCHAR(MAX) = ''
DECLARE @PlaceholderSelect VARCHAR(MAX) = ''
DECLARE @Select VARCHAR(MAX) = ''
DECLARE @PlaceholderSelectDelta VARCHAR(MAX) = ''
DECLARE @SelectDelta VARCHAR(MAX) = ''

WHILE @Counter <= @MaxColumns

BEGIN

	SELECT @PlaceholderInsertColumns	= IIF(@Counter = 1,'',',') + '[' + InformationSchema.ColumnName + ']' + @CRLF
		  ,@PlaceholderSelect		= IIF(@Counter = 1,'',',') + 'fact.[' + InformationSchema.ColumnName + ']' + @CRLF
		  ,@PlaceholderSelectDelta  = IIF(@Counter = 1,'',',') + CASE 
																	WHEN ColumnName NOT LIKE '%ID' AND ColumnName <> 'LastValueLoaded' AND ColumnName NOT LIKE '%Code' AND ColumnName NOT LIKE '%Flag'AND ColumnName NOT LIKE '%Number' AND Datatype IN ('Decimal','Numeric','int','bigint','float','smallint') THEN '-'
																	ELSE ''
																 END + 'fact.[' + InformationSchema.ColumnName + ']' + @CRLF
	FROM 
		@InformationSchema AS InformationSchema	
	WHERE 
		@Counter = InformationSchema.OrdinalPosition 
		AND InformationSchema.DatabaseName = 'DW'

   	SET @InsertColumns = CONCAT(@InsertColumns,@PlaceholderInsertColumns)
	SET @Select = CONCAT(@Select,@PlaceholderSelect)
	SET @SelectDelta = CONCAT(@SelectDelta,@PlaceholderSelectDelta)

	SET @PlaceholderSelect = ''
	SET @PlaceholderInsertColumns = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1



/**********************************************************************************************************************************************************************
4. Create the key join
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderKeys VARCHAR(MAX) --Placeholder for the match SCD1 part of the script
DECLARE @Keys VARCHAR(MAX) --Holds the value of @ColumnNameDim for each loop


WHILE @Counter <= @MaxColumnsKeys

BEGIN 

	SELECT @PlaceholderKeys	= CASE 
											WHEN @Counter = @MinKeyCounter
												THEN 'ON ' 
											ELSE ' AND ' 
											END 	 
											+ 'stage.[' + InformationSchema.ColumnName + '] = fact.[' + InformationSchema.ColumnName + ']'
		  

	FROM 
		@InformationSchema AS InformationSchema	
	WHERE 
			InformationSchema.OrdinalPosition = @Counter 
		AND DatabaseName = 'DW'
		AND InformationSchema.PrimaryKey = 1
	
	SET @Keys = CONCAT(@Keys,@PlaceholderKeys)

	SET @PlaceholderKeys = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1



/**********************************************************************************************************************************************************************
5. Fill out dynamic SQL variables
***********************************************************************************************************************************************************************/

DECLARE @ExistingDelta NVARCHAR(MAX) --Holds the parameter part of the Merge Join Script
DECLARE @NewDelta NVARCHAR(MAX)
DECLARE @UnionExistingDelta NVARCHAR(MAX) --Holds the SCD1 part of the Merge Join Script
DECLARE @DeleteFromFact NVARCHAR(MAX) --Holds the SCD1 part of the Merge Join Script
DECLARE @DeleteFromDelta NVARCHAR(MAX) --Holds the SCD1 part of the Merge Join Script
DECLARE @SQL NVARCHAR(MAX)


SET @NewDelta = 
'INSERT INTO [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '_Temp] WITH (TABLOCK)
(' + ISNULL(@InsertColumns,'') + ',DWCreatedDate, DWModifiedDate)
 SELECT 
	' + ISNULL(@SelectDelta ,'')
	  + '
	  ,''1900-01-01''
	  ,''1900-01-01''
 FROM [' + @DatabaseNameStage + '].[' + @StageSchema +'].['+ @Table + '] AS Stage
INNER JOIN
	[' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '] AS fact'  + @CRLF 
	+ @Keys

SET @DeleteFromFact = '
DELETE fact WITH (TABLOCK)
FROM
	[' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '] AS fact'  + @CRLF +
'INNER JOIN
	[' + @DatabaseNameStage + '].[' + @StageSchema +'].['+ @Table + '] AS Stage' + @CRLF +
	+ @Keys


SET @SQL = IIF(@CleanUpPartitionsFlag = 0,CONCAT('BEGIN TRAN ',@NewDelta,@DeleteFromFact,' COMMIT TRAN'),@DeleteFromFact)

/**********************************************************************************************************************************************************************
6. Execute dynamic SQL variables
***********************************************************************************************************************************************************************/

IF @PrintSQL = 0

	BEGIN
		
		EXEC(@SQL)

	END

ELSE

	BEGIN

		IF @CleanUpPartitionsFlag = 0

			BEGIN

				PRINT('BEGIN TRAN ') + @CRLF + @CRLF
				PRINT(@NewDelta) + @CRLF + @CRLF
				PRINT(@DeleteFromFact) + @CRLF + @CRLF
				PRINT(' COMMIT TRAN ') + @CRLF + @CRLF

			END

	    ELSE

			BEGIN

				PRINT(@DeleteFromFact)

			END
			
	END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[LoadSourceObjectHistory]...';


GO
CREATE PROCEDURE [meta].[LoadSourceObjectHistory] 

	@ExtractTable  NVARCHAR(200)--Input is the extract table with schema
,	@LoadIsIncremental BIT
,	@SCD2Columns NVARCHAR(MAX) 
,	@PrintSQL BIT 

AS


SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/

SET @ExtractTable = REPLACE(REPLACE(@ExtractTable, '[',''), ']','');

DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10)
DECLARE @TableSchema NVARCHAR(100) = SUBSTRING(@ExtractTable, 0,CHARINDEX('.', @ExtractTable));
DECLARE @Table NVARCHAR(100) = REPLACE(RIGHT(@ExtractTable, LEN(@ExtractTable) - LEN(@TableSchema)), '.', '');
DECLARE @DatabaseNameExtract NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameExtract')
DECLARE @DatabaseNameMeta NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameMeta')
DECLARE @DatabaseNameHistory NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameHistory')
DECLARE @IsCloudFlag NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'IsCloudFlag')
DECLARE @SeparateHistoryFlag NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'SeparateHistoryLayerFlag')
DECLARE @SCD2ColumnsCleansed NVARCHAR(MAX) = IIF(RIGHT(@SCD2Columns,1) = ',',LEFT(@SCD2Columns,LEN(@SCD2Columns)-1),@SCD2Columns)
DECLARE @HistoryTable NVARCHAR(100) = IIF(@SeparateHistoryFlag = 1 AND @IsCloudFlag = 1,@Table,@Table + '_History')
DECLARE @HistorySchema NVARCHAR(50) = IIF(@SeparateHistoryFlag = 1 AND @IsCloudFlag = 1,@TableSchema + '_history',@TableSchema)
DECLARE @DatabaseCollation NVARCHAR(100) = (SELECT CONVERT (varchar, DATABASEPROPERTYEX('' + @DatabaseNameMeta + '','collation')))
DECLARE @TargetTableHasHistoricRows TABLE (HasHistoricRowsFlag BIT)
INSERT INTO @TargetTableHasHistoricRows EXEC('SELECT TOP 1 IIF(DWIsCurrent = 0,1,0) FROM [' + @HistorySchema + '].[' + @HistoryTable + '] WHERE DWIsCurrent = 0')
DECLARE @HasHistoricRowsFlag BIT = ISNULL(IIF(@SCD2Columns = '',(SELECT HasHistoricRowsFlag FROM @TargetTableHasHistoricRows),1),0)
DECLARE @RowExtractedTable TABLE (NumberOfExtractedRows INT)
INSERT INTO @RowExtractedTable EXEC('SELECT COUNT(*) FROM [' + @TableSchema+ '].[' + @Table + ']')
DECLARE @NumberOfExtractedRows INT = (SELECT NumberOfExtractedRows FROM @RowExtractedTable)

/**********************************************************************************************************************************************************************
1. Create and insert data into table variables
**********************************************************************************************************************************************************************/

DECLARE @InformationSchema TABLE (DatabaseName NVARCHAR(128), TableName NVARCHAR(128), ColumnName NVARCHAR(128), OrdinalPosition INT, PrimaryKey INT)
DECLARE @SCD2ColumnTable TABLE (SCD2Columns NVARCHAR(500))
DECLARE @ColumnDefaults TABLE (DataType NVARCHAR(50),DefaultValue NVARCHAR(250))

/*Generates the combined information schema*/
INSERT @InformationSchema EXEC('SELECT ''Extract'' AS DATABASE_NAME
										,COLUMNS.TABLE_NAME
										,COLUMNS.COLUMN_NAME
										,COLUMNS.ORDINAL_POSITION
										,CASE WHEN KEY_COLUMN_USAGE.COLUMN_NAME IS NULL THEN 0 
											  ELSE 1 
									     END AS PRIMARY_KEY
								FROM 
									[' + @DatabaseNameExtract + '].INFORMATION_SCHEMA.COLUMNS
								LEFT JOIN 
									[' + @DatabaseNameExtract + '].INFORMATION_SCHEMA.KEY_COLUMN_USAGE
										ON COLUMNS.TABLE_NAME = KEY_COLUMN_USAGE.TABLE_NAME 
										AND COLUMNS.COLUMN_NAME = KEY_COLUMN_USAGE.COLUMN_NAME
										AND COLUMNS.TABLE_SCHEMA = KEY_COLUMN_USAGE.TABLE_SCHEMA
								WHERE 
									COLUMNS.TABLE_NAME = ''' + @Table + ''' 
									AND (COLUMNS.COLUMN_NAME NOT LIKE ''DW%'' 
									OR COLUMNS.COLUMN_NAME = ''DWNavisionCompany'')
									AND COLUMNS.TABLE_SCHEMA NOT LIKE ''%View%''
									AND COLUMNS.TABLE_SCHEMA = ''' + @TableSchema + '''
						

								UNION ALL

								SELECT ''History'' AS DATABASE_NAME
										,COLUMNS.TABLE_NAME
										,COLUMNS.COLUMN_NAME
										,COLUMNS.ORDINAL_POSITION
										,CASE WHEN KEY_COLUMN_USAGE.COLUMN_NAME IS NULL THEN 0 
											  ELSE 1 
										 END AS PRIMARY_KEY
								FROM 
									[' + @DatabaseNameExtract + '].INFORMATION_SCHEMA.COLUMNS
								LEFT JOIN 
									[' + @DatabaseNameExtract + '].INFORMATION_SCHEMA.KEY_COLUMN_USAGE
										ON COLUMNS.TABLE_NAME = KEY_COLUMN_USAGE.TABLE_NAME 
										AND COLUMNS.COLUMN_NAME = KEY_COLUMN_USAGE.COLUMN_NAME
										AND COLUMNS.TABLE_SCHEMA = KEY_COLUMN_USAGE.TABLE_SCHEMA
								WHERE 
									COLUMNS.TABLE_NAME = ''' + @Table + ''' + ''_History''
									AND (COLUMNS.COLUMN_NAME NOT LIKE ''DW%'' 
									OR COLUMNS.COLUMN_NAME = ''DWNavisionCompany'')
									AND COLUMNS.TABLE_SCHEMA = ''' + @TableSchema + '''')


/*Generates a table with the SCD2 columns*/
INSERT @SCD2ColumnTable EXEC('WITH AllColumns AS

						  (
						  SELECT COLUMN_NAME
						  FROM [' + @DatabaseNameExtract + '].INFORMATION_SCHEMA.COLUMNS
						  WHERE
							TABLE_SCHEMA = ''' + @TableSchema + '''
							AND TABLE_NAME = ''' + @Table + '''
							AND COLUMN_NAME NOT LIKE ''DW%''

						  )
						  
						  
						  
						  SELECT DISTINCT IIF(Item = ''*'', COLUMN_NAME COLLATE ' + @DatabaseCollation + ', Item) 
						  FROM [meta].[SplitString](''' + @SCD2ColumnsCleansed + ''','','')
						  LEFT JOIN AllColumns ON Item = ''*''
						  WHERE Item <> '''''
						  )
		
					

/**********************************************************************************************************************************************************************
2. Create Loop counter and support variables
**********************************************************************************************************************************************************************/

DECLARE @ColumnsExtract INT --Number of columns from Extract
DECLARE @ColumnsHistory INT --Number of columns from History
DECLARE @ColumnsSCD1 INT --Number of SCD1 columns
DECLARE @ColumnsSCD2 INT --Number of SCD2 columns
DECLARE @Counter INT --Just a counter
DECLARE @ColumnsID INT --Number of key columns
DECLARE @NonKeyColumns INT



SELECT 
	@ColumnsExtract = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE DatabaseName = 'Extract'),
	@Counter = 1,
	@ColumnsID = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE PrimaryKey = 1 AND DatabaseName = 'Extract'),
	@ColumnsHistory = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE DatabaseName = 'History'),
	@ColumnsSCD1 =(SELECT MAX(OrdinalPosition) FROM @InformationSchema C LEFT JOIN @SCD2ColumnTable SCD ON SCD.SCD2Columns = C.ColumnName WHERE DatabaseName = 'Extract' AND SCD.SCD2Columns IS NULL AND PrimaryKey = 0),
	@ColumnsSCD2 =(SELECT MAX(OrdinalPosition) FROM @InformationSchema C LEFT JOIN @SCD2ColumnTable SCD ON SCD.SCD2Columns = C.ColumnName WHERE DatabaseName = 'Extract' AND (PrimaryKey = 1 OR SCD.SCD2Columns IS NOT NULL)),
	@NonKeyColumns = (SELECT COUNT(ColumnName) FROM @InformationSchema WHERE DatabaseName = 'Extract' AND PrimaryKey = 0)


/**********************************************************************************************************************************************************************
3. Create Merge Keys part and Merge Ouput part
**********************************************************************************************************************************************************************/

DECLARE @PlaceholderKeys NVARCHAR(MAX) --Placeholder used in the loop generating the business keys used in the Merge Join script
DECLARE @Keys NVARCHAR(MAX) --Holds the value of @Keys for each loop
DECLARE @KeyFields NVARCHAR(MAX) --Holds the value of @Keys for each loop
DECLARE @PlaceholderKeyFields NVARCHAR(MAX) --Holds the value of @Keys for each loop

WHILE @Counter <= @ColumnsID

BEGIN

	SELECT	
		@PlaceholderKeys = '[SOURCE].' + QUOTENAME(ColumnName) + ' = [TARGET].' + QUOTENAME(ColumnName) + CASE 
																										WHEN @Counter != @ColumnsID 
																											THEN ' AND ' 
																										ELSE '' 
																								  END,
		@PlaceholderKeyFields = QUOTENAME(ColumnName) + CASE WHEN @Counter != @ColumnsID THEN ', ' ELSE '' END
	FROM 
		@InformationSchema
	WHERE 
			OrdinalPosition = @Counter 
		AND PrimaryKey = 1 
		AND DatabaseName = 'Extract'

	SET @Keys = CONCAT(@Keys,@PlaceholderKeys)
	SET @KeyFields = CONCAT(@KeyFields,@PlaceholderKeyFields)

	SET @PlaceholderKeys = ''
	SET @PlaceholderKeyFields = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
4. Create columns from extract and output column part
**********************************************************************************************************************************************************************/

DECLARE @PlaceholderColumnNameTarget NVARCHAR(MAX) --Placeholder for the columns from Extract
DECLARE @ColumnNameTarget NVARCHAR(MAX) --Holds the value of @ColumnNameExtract for each loop
DECLARE @PlaceholderColumnNames NVARCHAR(MAX) --Placeholder for the columns from Extract
DECLARE @ColumnNames NVARCHAR(MAX) --Holds the value of @ColumnNameExtract for each loop
DECLARE @PlaceholderColumnNameSource NVARCHAR(MAX) --Placeholder for the output part of the script
DECLARE @ColumnNameSource NVARCHAR(MAX) --Holds the value of @ColumnNameDim for each loop
DECLARE @PlaceholderColumnNameMerge NVARCHAR(MAX) --Placeholder for the output part of the script
DECLARE @ColumnNameMerge NVARCHAR(MAX) --Holds the value of @ColumnNameDim for each loop

WHILE @Counter <= @ColumnsExtract

BEGIN 

	SELECT	@PlaceholderColumnNameTarget = '[TARGET].' + QUOTENAME(ColumnName) + ' AS ' + QUOTENAME(ColumnName) + '' + CASE 
																										WHEN @Counter != @ColumnsExtract 
																											THEN ', ' 
																										ELSE '' 
																									END + @CRLF,
			@PlaceholderColumnNameSource = '[SOURCE].' + QUOTENAME(ColumnName) + ' AS ' + QUOTENAME(ColumnName) + '' + CASE 
																									    WHEN @Counter != @ColumnsExtract 
																											THEN ', ' 
																										ELSE '' 
																									END + @CRLF,
			@PlaceholderColumnNameMerge = '[MERGE].' + QUOTENAME(ColumnName) + '' + CASE 
																				WHEN @Counter != @ColumnsExtract 
																					THEN ', ' 
																				ELSE '' 
																			END + @CRLF,
			@PlaceholderColumnNames = '' + QUOTENAME(ColumnName) + '' +  CASE 
																	WHEN @Counter != @ColumnsExtract 
																		THEN ', ' 
																	ELSE '' 
																END + @CRLF																					
	FROM 
		@InformationSchema
	WHERE 
			DatabaseName = 'Extract' 
		AND TableName = @Table 
		AND OrdinalPosition = @Counter

	SET @ColumnNameTarget = CONCAT(@ColumnNameTarget,@PlaceholderColumnNameTarget)

	SET @PlaceholderColumnNameTarget = ''

	SET @ColumnNameSource = CONCAT(@ColumnNameSource,@PlaceholderColumnNameSource)

	SET @PlaceholderColumnNameSource = ''

	SET @ColumnNameMerge = CONCAT(@ColumnNameMerge,@PlaceholderColumnNameMerge)

	SET @PlaceholderColumnNameMerge = ''

	SET @ColumnNames = CONCAT(@ColumnNames,@PlaceholderColumnNames)

	SET @PlaceholderColumnNames = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
5.Create update part and match part for SCD1 columns
**********************************************************************************************************************************************************************/

DECLARE @PlaceholderColumnNamesSourceSCD1 NVARCHAR(MAX) --Placeholder for the update SCD1 part of the script
DECLARE @ColumnNamesSourceSCD1 NVARCHAR(MAX) --Holds the value of @ColumnNameDim for each loop
DECLARE @PlaceholderColumnNamesTargetSCD1 NVARCHAR(MAX) --Placeholder for the update SCD1 part of the script
DECLARE @ColumnNamesTargetSCD1 NVARCHAR(MAX) --Holds the value of @ColumnNameDim for each loop
DECLARE @PlaceholderColumnNamesSCD1WithHistorySCD1 NVARCHAR(MAX) 
DECLARE @ColumnNamesSCD1WithHistorySCD1 NVARCHAR(MAX) 
DECLARE @PlaceholderColumnNamesSCD1WithHistorySCD2 NVARCHAR(MAX) 
DECLARE @ColumnNamesSCD1WithHistorySCD2 NVARCHAR(MAX) 

WHILE @Counter <= @ColumnsExtract

BEGIN 

	SELECT	@PlaceholderColumnNamesSourceSCD1 = IIF(SCD.SCD2Columns IS NULL,'[SOURCE].' + QUOTENAME(ColumnName) + '' +  CASE 
																								WHEN @Counter != @ColumnsExtract 
																									THEN ', ' 
																								ELSE '' 
																							END + @CRLF, ''),
			@PlaceholderColumnNamesTargetSCD1 = IIF(SCD.SCD2Columns IS NULL,'[TARGET].' + QUOTENAME(ColumnName) + '' +  CASE 
																								WHEN @Counter != @ColumnsExtract 
																									THEN ', ' 
																								ELSE '' 
																							END + @CRLF, ''),
			@PlaceholderColumnNamesSCD1WithHistorySCD1 = IIF(SCD.SCD2Columns IS NULL, '[SOURCE].', '[TARGET].') + QUOTENAME(ColumnName) + '' +	CASE 
																																					WHEN @Counter != @ColumnsExtract 
																																						THEN ', ' 
																																					ELSE '' 
																																				END + @CRLF,
			@PlaceholderColumnNamesSCD1WithHistorySCD2 = IIF(SCD.SCD2Columns IS NULL, '[TARGET].', '[SOURCE].') + QUOTENAME(ColumnName) + '' +	CASE 
																																					WHEN @Counter != @ColumnsExtract 
																																						THEN ', ' 
																																					ELSE '' 
																																				END + @CRLF
	FROM 
		@InformationSchema AS InformationSchema
	LEFT JOIN 
		@SCD2ColumnTable AS SCD 
			ON SCD.SCD2Columns = InformationSchema.ColumnName
	WHERE 
			DatabaseName = 'Extract' 
		AND OrdinalPosition = @Counter 

	SET @ColumnNamesSourceSCD1 = CONCAT(@ColumnNamesSourceSCD1,@PlaceholderColumnNamesSourceSCD1)

	SET @PlaceholderColumnNamesSourceSCD1 = ''

	SET @ColumnNamesTargetSCD1 = CONCAT(@ColumnNamesTargetSCD1,@PlaceholderColumnNamesTargetSCD1)

	SET @PlaceholderColumnNamesTargetSCD1 = ''

	SET @ColumnNamesSCD1WithHistorySCD1 = CONCAT(@ColumnNamesSCD1WithHistorySCD1,@PlaceholderColumnNamesSCD1WithHistorySCD1)

	SET @PlaceholderColumnNamesSCD1WithHistorySCD1 = ''

	SET @ColumnNamesSCD1WithHistorySCD2 = CONCAT(@ColumnNamesSCD1WithHistorySCD2,@PlaceholderColumnNamesSCD1WithHistorySCD2)

	SET @PlaceholderColumnNamesSCD1WithHistorySCD2 = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1



/**********************************************************************************************************************************************************************
6.Create update part and match part for SCD2 columns
**********************************************************************************************************************************************************************/

DECLARE @PlaceholderColumnNamesSourceSCD2 NVARCHAR(MAX) --Placeholder for the update SCD1 part of the script
DECLARE @ColumnNamesSourceSCD2 NVARCHAR(MAX) --Holds the value of @ColumnNameDim for each loop
DECLARE @PlaceholderColumnNamesTargetSCD2 NVARCHAR(MAX) --Placeholder for the update SCD1 part of the script
DECLARE @ColumnNamesTargetSCD2 NVARCHAR(MAX) --Holds the value of @ColumnNameDim for each loop

WHILE @Counter <= @ColumnsSCD2

BEGIN 

	SELECT  @PlaceholderColumnNamesSourceSCD2 = '[SOURCE].' + QUOTENAME(ColumnName) +  CASE 
																	WHEN @Counter != @ColumnsSCD2 
																		THEN ', ' 
																	ELSE '' 
																END,	
			@PlaceholderColumnNamesTargetSCD2 = '[TARGET].' + QUOTENAME(ColumnName) +  CASE 
																	WHEN @Counter != @ColumnsSCD2 
																		THEN ', ' 
																	ELSE '' 
																END		
       
	FROM 
		@InformationSchema AS InformationSchema
	LEFT JOIN 
		@SCD2ColumnTable AS SCD 
			ON SCD.SCD2Columns = InformationSchema.ColumnName
	WHERE 
			DatabaseName = 'Extract' 
		AND OrdinalPosition = @Counter 
		AND (PrimaryKey = 1 OR SCD.SCD2Columns IS NOT NULL)

	SET @ColumnNamesSourceSCD2 = CONCAT(@ColumnNamesSourceSCD2,@PlaceholderColumnNamesSourceSCD2);
	SET @PlaceholderColumnNamesSourceSCD2 = '';
	SET @ColumnNamesTargetSCD2 = CONCAT(@ColumnNamesTargetSCD2,@PlaceholderColumnNamesTargetSCD2);
	SET @PlaceholderColumnNamesTargetSCD2 = '';
	SET @Counter = @Counter + 1;

END

SET @Counter = 1;

/**********************************************************************************************************************************************************************
6. Fill out the dynamic SQL script variables
**********************************************************************************************************************************************************************/

DECLARE @Parameters NVARCHAR(MAX) --Holds the parameter part of the Merge Join Script
DECLARE @Deletes NVARCHAR(MAX) --Holds the delete part of the Script
DECLARE @UnDeletes NVARCHAR(MAX) --Holds the delete part of the Script
DECLARE @Inserts NVARCHAR(MAX) --Holds the insert part of the Script
DECLARE @UpdatesSCD1 NVARCHAR(MAX) --Holds the update part of the Script
DECLARE @UpdatesSCD1WithHistory NVARCHAR(MAX) --Holds the update part of the Script
DECLARE @UpdatesSCD2 NVARCHAR(MAX) --Holds the update part of the Script
DECLARE @FullScript NVARCHAR(MAX) --Combining 
DECLARE @DeleteSQL NVARCHAR(MAX)
DECLARE @ReplaceSQL NVARCHAR(MAX)
DECLARE @SourceTableHasDWOperation BIT = 0

/* Do we have an IUD audit column from source e.g CDC or CT TRUE/FALSE */
SET @SourceTableHasDWOperation = (SELECT IIF( COL_LENGTH('' + @DatabaseNameExtract + '.' + @TableSchema + '.' + @Table + '', 'DWOperation') > 0, 1, 0) );

SET @Parameters =
'DECLARE @CurrentDateTime DATETIME;
DECLARE @MinDateTime DATETIME;
DECLARE @MaxDateTime DATETIME;
DECLARE @BooleanTrue BIT;
DECLARE @BooleanFalse BIT;
DECLARE @DateToDateTime DATETIME


SELECT
	@CurrentDateTime = CAST(GETDATE() AS DATETIME)
,	@MinDateTime	 = CAST(''1900-01-01'' AS DATETIME)
,	@MaxDateTime	 = CAST(''9999-12-31'' AS DATETIME)
,	@BooleanTrue	 = CAST(1 AS BIT)
,	@BooleanFalse	 = CAST(0 AS BIT)
,	@DateToDateTime  = DATEADD(MS,-3,  GETDATE())


-- ==================================================
-- Create #temp table #ChangedRecords 
-- to hold deleted and updated records
-- ==================================================

DROP TABLE IF EXISTS #ChangedRecords;

-- ==================================================
-- Create #temp table #ChangedRecords 
-- based on [@HistorySchema].[@HistoryTable] definition
-- ==================================================

SELECT 
' + @ColumnNameTarget + '
,[TARGET].[DWIsCurrent]
,[TARGET].[DWValidFromDate]
,[TARGET].[DWValidToDate]
,[TARGET].[DWCreatedDate]
,[TARGET].[DWModifiedDate]
,[TARGET].[DWIsDeletedInSource]
,[TARGET].[DWDeletedInSourceDate]
,[ETLOperation] = CAST(NULL AS NVARCHAR(30)) /* Internal Change Audit column used in data flow task decission - NOT the same as CDC or CT DWOperation */
INTO 
	#ChangedRecords
FROM 
	' + QUOTENAME(@DatabaseNameHistory) + '.' + QUOTENAME(@HistorySchema) + '.' + QUOTENAME(@HistoryTable) + '  AS [TARGET] 
WHERE 1 = 0 ;
'


SET @Deletes = IIF(@LoadIsIncremental = 1 AND @SourceTableHasDWOperation = 0, '', '

-- ==================================================
-- Prepare Deleted Records store TARGET records 
-- in #temp table #ChangedRecords change audit columns
-- ==================================================

INSERT INTO #ChangedRecords WITH (TABLOCKX)
(' + @ColumnNames + '
,[DWIsCurrent]
,[DWValidFromDate]
,[DWValidToDate]
,[DWCreatedDate]
,[DWModifiedDate]
,[DWIsDeletedInSource]
,[DWDeletedInSourceDate]
,[ETLOperation])

SELECT 
' + @ColumnNameTarget + '
,[DWIsCurrent]				=	[TARGET].[DWIsCurrent]
,[DWValidFromDate]			=	[TARGET].[DWValidFromDate]
,[DWValidToDate]			=	[TARGET].[DWValidToDate]
,[DWCreatedDate]			=	[TARGET].[DWCreatedDate]
,[DWModifiedDate]			=	@CurrentDateTime
,[DWIsDeletedInSource]		=	@BooleanTrue 
,[DWDeletedInSourceDate]	=	@CurrentDateTime
,[ETLOperation]				=	''Deleted''
FROM 
	' + QUOTENAME(@DatabaseNameHistory) + '.' + QUOTENAME(@HistorySchema) + '.' + QUOTENAME(@HistoryTable) + ' AS [TARGET]
' +
CASE 
	WHEN (@LoadIsIncremental = 1) AND (@SourceTableHasDWOperation = 1) 
		THEN
	'INNER JOIN 
	' + QUOTENAME(@DatabaseNameExtract) + '.' + QUOTENAME(@TableSchema) + '.' + QUOTENAME(@Table) + ' AS [SOURCE]
		ON (' + @Keys + ') AND ([SOURCE].[DWOperation] IN (''D'')) '
	ELSE 
	'WHERE
	NOT EXISTS (SELECT 1 
				FROM ' + QUOTENAME(@DatabaseNameExtract) + '.' + QUOTENAME(@TableSchema) + '.' + QUOTENAME(@Table) + ' AS [SOURCE] 
					WHERE 
						(' + @Keys + ')
				) '
END + 
'AND ([TARGET].[DWIsDeletedInSource] = 0) ;
'
) 



SET @UpdatesSCD1 =	
' 
-- ==================================================
-- Updated Records SCD1 without SCD2 columns
-- ==================================================

INSERT INTO #ChangedRecords WITH (TABLOCKX)
(' + @ColumnNames + '
,[DWIsCurrent]
,[DWValidFromDate]
,[DWValidToDate]
,[DWCreatedDate]
,[DWModifiedDate]
,[DWIsDeletedInSource]
,[DWDeletedInSourceDate]
,[ETLOperation]
)

SELECT 
' + @ColumnNameSource + '
,[DWIsCurrent]				=	[TARGET].[DWIsCurrent]
,[DWValidFromDate]			=	[TARGET].[DWValidFromDate]
,[DWValidToDate]			=	[TARGET].[DWValidToDate]
,[DWCreatedDate]			=	[TARGET].[DWCreatedDate]
,[DWModifiedDate]			=	@CurrentDateTime
,[DWIsDeletedInSource]		=	@BooleanFalse 
,[DWDeletedInSourceDate]	=	@MinDateTime
,[ETLOperation]				=	''SCD1 - Update''
FROM 
	' + QUOTENAME(@DatabaseNameExtract) + '.' + QUOTENAME(@TableSchema) + '.' + QUOTENAME(@Table) + ' AS [SOURCE]
INNER JOIN
	' + QUOTENAME(@DatabaseNameHistory) + '.' + QUOTENAME(@HistorySchema) + '.' + QUOTENAME(@HistoryTable) + ' AS [TARGET] 
		ON (' + @Keys + ') AND ([TARGET].[DWIsCurrent] = 1)' + IIF(@SourceTableHasDWOperation = 1, ' AND ([SOURCE].[DWOperation] IN (''I'', ''U'')) ', '') + '
WHERE
	EXISTS
( SELECT 
' + @ColumnNameSource + ' 
  EXCEPT
  SELECT 
' + @ColumnNameTarget + ' )
;'

SET @UpdatesSCD1WithHistory =	
'
-- ==================================================
-- Updated Records SCD1 with SCD2 columns
-- ==================================================

INSERT INTO #ChangedRecords WITH (TABLOCKX)
(' + @ColumnNames + '
,[DWIsCurrent]
,[DWValidFromDate]
,[DWValidToDate]
,[DWCreatedDate]
,[DWModifiedDate]
,[DWIsDeletedInSource]
,[DWDeletedInSourceDate]
,[ETLOperation])

SELECT 
' + @ColumnNamesSCD1WithHistorySCD1 + '
,[DWIsCurrent]				=	[TARGET].[DWIsCurrent]
,[DWValidFromDate]			=	[TARGET].[DWValidFromDate]
,[DWValidToDate]			=	[TARGET].[DWValidToDate]
,[DWCreatedDate]			=	[TARGET].[DWCreatedDate]
,[DWModifiedDate]			=	@CurrentDateTime
,[DWIsDeletedInSource]		=	@BooleanFalse 
,[DWDeletedInSourceDate]	=	@MinDateTime
,[ETLOperation]				=	IIF([TARGET].[DWIsCurrent] = 1,''SCD1 Update - Current'',''SCD1 Update - History'')
FROM 
	' + QUOTENAME(@DatabaseNameExtract) + '.' + QUOTENAME(@TableSchema) + '.' + QUOTENAME(@Table) + ' AS [SOURCE]
INNER JOIN
	' + QUOTENAME(@DatabaseNameHistory) + '.' + QUOTENAME(@HistorySchema) + '.' + QUOTENAME(@HistoryTable) + ' AS [TARGET] 
		ON (' + @Keys + ')' + IIF(@SourceTableHasDWOperation = 1, ' AND ([SOURCE].[DWOperation] IN (''I'', ''U'')) ', '') + '
WHERE
	EXISTS
( SELECT 
' + @ColumnNamesSourceSCD1 + ' 
  EXCEPT
  SELECT 
' + @ColumnNamesTargetSCD1 + ' )
;'

SET @UpdatesSCD2 = 
'
-- ==================================================
-- Create #temp table #ChangedSCD1WithHistoryRecords 
-- Records which is updated though a SCD type 1 
-- but also triggered by a SCD type 2 update 
-- ==================================================

DROP TABLE IF EXISTS #ChangedSCD1WithHistoryRecords;

-- ==================================================
-- Updated Records SCD2
-- Close existing records
-- ==================================================

/* Handle Updates from Source - Close existing records */ 
SELECT
' + @ColumnNamesSCD1WithHistorySCD1 + '
,[DWIsCurrent]				= @BooleanFalse
,[DWValidFromDate]			= [TARGET].[DWValidFromDate]
,[DWValidToDate]			= @DateToDateTime
,[DWCreatedDate]			= [TARGET].[DWCreatedDate]
,[DWModifiedDate]			= @CurrentDateTime
,[DWIsDeletedInSource]		= [TARGET].[DWIsDeletedInSource]	
,[DWDeletedInSourceDate]	= [TARGET].[DWDeletedInSourceDate]
,[ETLOperation]				= ''SCD2 Update - Closing'' -- BeforeUpdate
INTO 
	#ChangedSCD1WithHistoryRecords
FROM		
  ' + QUOTENAME(@DatabaseNameHistory) + '.' + QUOTENAME(@HistorySchema) + '.' + QUOTENAME(@HistoryTable) + ' AS [TARGET]
INNER JOIN
	' + QUOTENAME(@DatabaseNameExtract) + '.' + QUOTENAME(@TableSchema) + '.' + QUOTENAME(@Table) + ' AS [SOURCE]
		ON (' + @Keys + ') AND ([TARGET].[DWIsCurrent] = 1)' + IIF(@SourceTableHasDWOperation = 1, ' AND ([SOURCE].[DWOperation] IN (''I'', ''U'')) ', '') + '
WHERE
	EXISTS
(SELECT 
' + @ColumnNamesSourceSCD2 + ' 
  
 EXCEPT
 
 SELECT 
' + @ColumnNamesTargetSCD2 + '
) ;

-- ==================================================
-- Updated Records SCD2
-- Delete SCD type 1 records which is triggered by
-- an SCD type 2 update - Insert SCD1 records and
-- SCD type 2 records.
-- ==================================================

/* Delete SCD1 updates which is triggered by and SCD2 update */
DELETE [TARGET] WITH (TABLOCKX) 
FROM 
	#ChangedRecords AS [TARGET]
INNER JOIN
	#ChangedSCD1WithHistoryRecords AS [SOURCE]
		ON (' + @Keys + ') AND (([SOURCE].[ETLOperation] = ''SCD2 Update - Closing'')  ' + IIF(ISNULL(@SCD2Columns,'') LIKE '*%',');','AND ([TARGET].[ETLOperation] = ''SCD1 Update - Current''))') + '
;

/* Insert SCD1 records with SCD2 audit History */
INSERT INTO #ChangedRecords WITH (TABLOCKX) 
(' + @ColumnNames + '
,[DWIsCurrent]
,[DWValidFromDate]
,[DWValidToDate]
,[DWCreatedDate]
,[DWModifiedDate]
,[DWIsDeletedInSource]
,[DWDeletedInSourceDate]
,[ETLOperation])

SELECT
' + @ColumnNames + '
,[DWIsCurrent]			
,[DWValidFromDate]		
,[DWValidToDate]		
,[DWCreatedDate]		
,[DWModifiedDate]		
,[DWIsDeletedInSource]	
,[DWDeletedInSourceDate]
,[ETLOperation]			
FROM  
	#ChangedSCD1WithHistoryRecords AS [SOURCE]
;

-- ==================================================
-- Updated Records SCD2
-- Create new SCD2 records
-- ==================================================

INSERT INTO #ChangedRecords WITH (TABLOCKX) 
(' + @ColumnNames + '
,[DWIsCurrent]
,[DWValidFromDate]
,[DWValidToDate]
,[DWCreatedDate]
,[DWModifiedDate]
,[DWIsDeletedInSource]
,[DWDeletedInSourceDate]
,[ETLOperation])

SELECT
' + @ColumnNamesSCD1WithHistorySCD2 + '
,[DWIsCurrent]				= @BooleanTrue		
,[DWValidFromDate]			= @CurrentDateTime	
,[DWValidToDate]			= @MaxDateTime		
,[DWCreatedDate]			= @CurrentDateTime	
,[DWModifiedDate]			= @CurrentDateTime	
,[DWIsDeletedInSource]		= @BooleanFalse		
,[DWDeletedInSourceDate]	= @MinDateTime
,[ETLOperation]				= ''SCD2 Insert - Opening'' -- AfterUpdate
FROM		
	#ChangedSCD1WithHistoryRecords AS [TARGET]
INNER JOIN
	' + QUOTENAME(@DatabaseNameExtract) + '.' + QUOTENAME(@TableSchema) + '.' + QUOTENAME(@Table) + ' AS [SOURCE]
		ON (' + @Keys + ') AND ([TARGET].[DWIsCurrent] = 0) AND ([TARGET].[ETLOperation] = ''SCD2 Update - Closing'')
;'


SET @UnDeletes ='

-- ==================================================
-- Prepare UnDeleted Records store TARGET records 
-- which has not been changed through other operations
-- ==================================================

DROP TABLE IF EXISTS #Undeletes

SELECT 
' + @ColumnNameTarget + '
,[DWIsCurrent]				=	[TARGET].[DWIsCurrent]
,[DWValidFromDate]			=	[TARGET].[DWValidFromDate]
,[DWValidToDate]			=	[TARGET].[DWValidToDate]
,[DWCreatedDate]			=	[TARGET].[DWCreatedDate]
,[DWModifiedDate]			=	@CurrentDateTime
,[DWIsDeletedInSource]		=	@BooleanFalse
,[DWDeletedInSourceDate]	=	@MinDateTime
,[ETLOperation]				=	''UnDeleted''
INTO 
	#Undeletes
FROM 
	' + QUOTENAME(@DatabaseNameHistory) + '.' + QUOTENAME(@HistorySchema) + '.' + QUOTENAME(@HistoryTable) + ' AS [TARGET]
WHERE
		EXISTS (SELECT 1 
				FROM ' + QUOTENAME(@DatabaseNameExtract) + '.' + QUOTENAME(@TableSchema) + '.' + QUOTENAME(@Table) + ' AS [SOURCE] 
					WHERE 
						(' + @Keys + ')
				) 
 AND ([TARGET].[DWIsDeletedInSource] = 1)
 AND NOT EXISTS (SELECT 1 
				FROM #ChangedRecords AS [SOURCE] 
					WHERE 
						(' + @Keys + ')
				) ;


INSERT INTO #ChangedRecords WITH (TABLOCKX)
(' + @ColumnNames + '
,[DWIsCurrent]
,[DWValidFromDate]
,[DWValidToDate]
,[DWCreatedDate]
,[DWModifiedDate]
,[DWIsDeletedInSource]
,[DWDeletedInSourceDate]
,[ETLOperation])

SELECT 
' + @ColumnNameSource + '
,[DWIsCurrent]				
,[DWValidFromDate]			
,[DWValidToDate]			
,[DWCreatedDate]			
,[DWModifiedDate]			
,[DWIsDeletedInSource]		
,[DWDeletedInSourceDate]	
,[ETLOperation]				
FROM 
	#Undeletes AS [SOURCE]
'


SET @Inserts = 
'
-- ==================================================
-- New Records which does not exists
-- ==================================================	

INSERT INTO #ChangedRecords WITH (TABLOCKX)
(' + @ColumnNames + '
,[DWIsCurrent]
,[DWValidFromDate]
,[DWValidToDate]
,[DWCreatedDate]
,[DWModifiedDate]
,[DWIsDeletedInSource]
,[DWDeletedInSourceDate]
,[ETLOperation])

SELECT 
' + @ColumnNameSource + '
,[DWIsCurrent]				=	@BooleanTrue
,[DWValidFromDate]			=	@MinDateTime
,[DWValidToDate]			=	@MaxDateTime
,[DWCreatedDate]			=	@CurrentDateTime
,[DWModifiedDate]			=	@CurrentDateTime
,[DWIsDeletedInSource]		=	@BooleanFalse
,[DWDeletedInSourceDate]	=	@MinDateTime
,[ETLOperation]				=   ''Insert''
FROM 
	' + QUOTENAME(@DatabaseNameExtract) + '.' + QUOTENAME(@TableSchema) + '.' + QUOTENAME(@Table) + ' AS [SOURCE]
WHERE
	NOT EXISTS
		(SELECT 1 FROM ' + QUOTENAME(@DatabaseNameHistory) + '.' + QUOTENAME(@HistorySchema) + '.' + QUOTENAME(@HistoryTable) + ' AS [TARGET]
		 WHERE
			(' + @Keys + '))' + IIF(@SourceTableHasDWOperation = 1, ' AND ([SOURCE].[DWOperation] IN (''I'', ''U'')) ', '') + '
;


-- ==================================================
-- Before deleting existing records we add a NC Index 
-- to optimize index-scan instead of table scan
-- ==================================================	

CREATE NONCLUSTERED INDEX [NCI_ChangedRecords] ON #ChangedRecords (' + @KeyFields + ', [DWValidFromDate]);

-- ==================================================
-- UnDeleted Records which has been changed through 
-- other operations is undeleted
-- ==================================================	

UPDATE TARGET WITH (TABLOCKX)
SET [DWIsDeletedInSource]	=	@BooleanFalse
   ,[DWDeletedInSourceDate]	=	@MinDateTime
FROM 
	#ChangedRecords AS TARGET
WHERE
	EXISTS (SELECT 1 
				FROM ' + QUOTENAME(@DatabaseNameExtract) + '.' + QUOTENAME(@TableSchema) + '.' + QUOTENAME(@Table) + ' AS [SOURCE] 
					WHERE 
						(' + @Keys + ')
				) 
	AND ([TARGET].[DWIsDeletedInSource] = 1) ;

BEGIN TRY
	BEGIN TRANSACTION

	-- ==================================================
	-- Delete soft-deleted- and updated records
	-- ==================================================	
	
	DELETE [TARGET] WITH (TABLOCKX)
	FROM 
		' + QUOTENAME(@DatabaseNameHistory) + '.' + QUOTENAME(@HistorySchema) + '.' + QUOTENAME(@HistoryTable) + ' AS [TARGET]
	INNER JOIN 
		#ChangedRecords AS [SOURCE]
			ON (' + @Keys + ' AND [SOURCE].[DWValidFromDate] = [TARGET].[DWValidFromDate])
	;
	
	
	-- ==================================================
	-- Insert records
	-- ==================================================
	
	INSERT INTO ' + QUOTENAME(@DatabaseNameHistory) + '.' + QUOTENAME(@HistorySchema) + '.' + QUOTENAME(@HistoryTable) + ' WITH (TABLOCKX)
	(' + @ColumnNames + '
	,[DWIsCurrent]
	,[DWValidFromDate]
	,[DWValidToDate]
	,[DWCreatedDate]
	,[DWModifiedDate]
	,[DWIsDeletedInSource]
	,[DWDeletedInSourceDate])
	
	SELECT 
	' + @ColumnNameSource + '
	,[SOURCE].[DWIsCurrent]
	,[SOURCE].[DWValidFromDate]
	,[SOURCE].[DWValidToDate]
	,[SOURCE].[DWCreatedDate]
	,[SOURCE].[DWModifiedDate]
	,[SOURCE].[DWIsDeletedInSource]
	,[SOURCE].[DWDeletedInSourceDate]
	FROM 
		#ChangedRecords AS [SOURCE]
	;

	COMMIT TRANSACTION;
END TRY
BEGIN CATCH
	IF @@TRANCOUNT > 0 ROLLBACK TRANSACTION;
	DECLARE @Message varchar(MAX) = ERROR_MESSAGE(),
        @Severity int = ERROR_SEVERITY(),
        @State smallint = ERROR_STATE() 
   RAISERROR (@Message, @Severity, @State)
END CATCH;
'


SET @FullScript = IIF(@ColumnsSCD1 IS NULL AND ISNULL(@SCD2Columns,'') = '','',CONCAT(@Parameters,@Deletes,CASE WHEN @ColumnsSCD1 IS NULL THEN NULL ELSE IIF(@HasHistoricRowsFlag = 1,@UpdatesSCD1WithHistory,@UpdatesSCD1) END,CASE WHEN ISNULL(@SCD2Columns,'') = '' THEN NULL ELSE @UpdatesSCD2 END,@UnDeletes,@Inserts))

/**********************************************************************************************************************************************************************
8. Execute dynamic SQL script variables
**********************************************************************************************************************************************************************/

IF @PrintSQL = 0 

	BEGIN
		IF @NumberOfExtractedRows = 0 AND @LoadIsIncremental = 0
			BEGIN 
				PRINT('No extracted rows in full load. Merge terminated')
			END
		ELSE
			BEGIN
				EXEC(@FullScript)
			END
	END

ELSE

	BEGIN
		
				PRINT(LEFT(@FullScript,4000)) 
				PRINT(SUBSTRING(@FullScript,4001,8000)) 
				PRINT(SUBSTRING(@FullScript,8001,12000)) 
				PRINT(SUBSTRING(@FullScript,12001,16000)) 
				PRINT(SUBSTRING(@FullScript,16001,20000)) 
				PRINT(SUBSTRING(@FullScript,20001,24000)) 
				PRINT(SUBSTRING(@FullScript,24001,28000)) 
				PRINT(SUBSTRING(@FullScript,28001,32000)) 
				PRINT(SUBSTRING(@FullScript,32001,36000)) 
				PRINT(SUBSTRING(@FullScript,36001,40000)) 
				PRINT(SUBSTRING(@FullScript,40001,44000)) 
				PRINT(SUBSTRING(@FullScript,44001,48000)) 
				PRINT(SUBSTRING(@FullScript,48001,52000)) 
				PRINT(SUBSTRING(@FullScript,52001,56000)) 
				PRINT(SUBSTRING(@FullScript,56001,60000)) 
				PRINT(SUBSTRING(@FullScript,60001,64000)) 
				PRINT(SUBSTRING(@FullScript,64001,68000)) 
				PRINT(SUBSTRING(@FullScript,68001,72000)) 
				PRINT(SUBSTRING(@FullScript,72001,76000)) 
				PRINT(SUBSTRING(@FullScript,76001,80000)) 
				PRINT(SUBSTRING(@FullScript,80001,84000)) 
				PRINT(SUBSTRING(@FullScript,84001,88000)) 
				PRINT(SUBSTRING(@FullScript,88001,92000)) 
				PRINT(SUBSTRING(@FullScript,92001,96000)) 
				PRINT(SUBSTRING(@FullScript,96001,100000)) 
		
	END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[MaintainDWCreateTableAndView]...';


GO


/**********************************************************************************************************************************************************************
The purpose of this scripts is to create and execute the create table and create view script between stage and dw. 
***********************************************************************************************************************************************************************/



CREATE PROCEDURE [meta].[MaintainDWCreateTableAndView]

@Table NVARCHAR(100),--Input is the table name without schema
@DestinationSchema NVARCHAR(10),--Input is the destination schema (dim, fact or bridge)
@PrintSQL BIT--Enter 1 if you want to print the dynamic SQL and 0 if you want to execute the dynamic SQL

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/

DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10) 
DECLARE @DatabaseNameStage NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameStage')
DECLARE @DatabaseNameDW NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW')
DECLARE @DatabaseNameMeta NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameMeta')
DECLARE @SurrogatKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'SurrogateKeySuffix')
DECLARE @BusinessKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'BusinessKeySuffix')
DECLARE @FactIsIncremental BIT = (SELECT FactAndBridgeIncrementalFlag FROM meta.BusinessMatrix WHERE TableName = @Table AND DestinationSchema = @DestinationSchema)
DECLARE @CompatibilityLevel INT = (SELECT compatibility_level FROM sys.databases WHERE name COLLATE DANISH_NORWEGIAN_CI_AS = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW'))
DECLARE @SQLEnterpriseServer BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'EnterpriseEditionFlag')
DECLARE @LoadPattern NVARCHAR(50) = (SELECT LoadPattern FROM meta.BusinessMatrix WHERE TableName = @Table)
DECLARE @FactCCIFlag BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'FactCCIFlag')
DECLARE @FactInMemoryFlag BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'FactInMemoryFlag')
DECLARE @FactEngineIsSQLFlag BIT = IIF((SELECT VariableValue FROM meta.Variables WHERE VariableName = 'FactLoadEngine') = 'SQL',1,0)
DECLARE @UpdateViewFlag BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'MaintainDWUpdateViewFlag')
DECLARE @ViewName NVARCHAR(100) = meta.[SplitCamelCase](@Table)
DECLARE @IsCloudFlag BIT = IIF((SELECT VariableValue FROM meta.Variables WHERE VariableName = 'IsCloudFlag') = '1',1,0)
DECLARE @IsSingleDatabase BIT = IIF(@DatabaseNameMeta = @DatabaseNameDW,1,0)
DECLARE @StageSchemaTable TABLE (SchemaName NVARCHAR(10)) 
INSERT @StageSchemaTable EXEC('SELECT DISTINCT TABLE_SCHEMA FROM [' + @DatabaseNameStage + '].INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''' + @Table + ''' AND TABLE_SCHEMA IN (''dbo'',''stage'')')
DECLARE @StageSchema NVARCHAR(10) = (SELECT IIF(@IsCloudFlag = 1,'stage',(SELECT SchemaName FROM @StageSchemaTable))) --If on-premise and stageschema has not been changed
DECLARE @DatabaseCollation NVARCHAR(100) = (SELECT CONVERT (varchar, DATABASEPROPERTYEX('' + @DatabaseNameMeta + '','collation')))
DECLARE @TruncateFlag BIT = (SELECT TruncateBeforeDeployFlag FROM meta.BusinessMatrix WHERE TableName = @Table AND DestinationSchema = @DestinationSchema)


/**********************************************************************************************************************************************************************
1. Create and insert data into table variables
***********************************************************************************************************************************************************************/

DECLARE @TableExists TABLE (TableName NVARCHAR(50)) --Table variable used to check if the table exists in the DW
DECLARE @ViewExists TABLE (TableName NVARCHAR(50)) --Table variable used to check if the table exists in the DW
DECLARE @TempViewExists TABLE (TableName NVARCHAR(50)) --Table variable used to check if the table exists in the DW
DECLARE @TempTableExists TABLE (TableName NVARCHAR(50)) --Table variable used to check if the table exists in the DW
DECLARE @InformationSchema TABLE (DatabaseName NVARCHAR(128), TableName NVARCHAR(128), ColumnName NVARCHAR(128), OrdinalPosition INT, DataType NVARCHAR(128), CharacterMaximumLenght INT, NumericPrecision INT, NumericScale INT)
DECLARE @DWRelations TABLE (TableName NVARCHAR(128), DimensionName NVARCHAR(128), TableColumnName NVARCHAR(128), DimensionColumnMappingName NVARCHAR(128), RolePlayingDimensionName NVARCHAR(128), IsSCD2DimensionFlag NVARCHAR(10), IsSCD2CompositeKeyDimensionFlag NVARCHAR(10), ColumnOrdinalPosition INT, IsNewDimensionFlag NVARCHAR(128), DefaultErrorValue NVARCHAR(128))
DECLARE @DimensionCombinedKeys TABLE (TableName NVARCHAR(128), ColumnName NVARCHAR(128), DimensionTable NVARCHAR(128))
DECLARE @PrimaryKeys TABLE (ColumnName NVARCHAR(128), OrdinalPosition INT)
DECLARE @PrimaryDimensionKeys TABLE (ColumnName NVARCHAR(128), OrdinalPosition INT)
DECLARE @SCD2Columns TABLE (ColumnName NVARCHAR(128), OrdinalPosition INT)

/*Generates a dataset with the combined information schema*/

INSERT @InformationSchema EXEC('SELECT 
										 ''Stage'' AS DATABASE_NAME
										,TABLE_NAME
										,COLUMN_NAME
										,ORDINAL_POSITION
										,DATA_TYPE
										,CHARACTER_MAXIMUM_LENGTH
										,NUMERIC_PRECISION
										,NUMERIC_SCALE
								FROM 
									[' + @DatabaseNameStage + '].INFORMATION_SCHEMA.COLUMNS
								WHERE 
									    TABLE_NAME = ''' + @Table + ''' 
									AND COLUMN_NAME NOT LIKE ''DW%''
									AND TABLE_SCHEMA = ''' + @StageSchema + '''')


/*Populates @TableExists and @ViewExists to check if table or View exists or not*/

INSERT @TableExists       EXEC('SELECT 
										TABLE_NAME 
						        FROM 
									[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.TABLES 
								 WHERE 
									    TABLE_NAME = ''' + @Table + ''' 
									AND TABLE_SCHEMA = ''' + @DestinationSchema + '''')

INSERT @ViewExists		  EXEC('SELECT 
										TABLE_NAME 
								FROM 
									[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.TABLES 
								WHERE 
										TABLE_NAME = ''' + @ViewName + ''' 
									AND TABLE_SCHEMA = ''' + @DestinationSchema + 'View''')

INSERT @TempViewExists		  EXEC('SELECT 
										TABLE_NAME 
								FROM 
									[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.TABLES 
								WHERE 
										TABLE_NAME = ''' + @ViewName + '_Temp'' 
									AND TABLE_SCHEMA = ''' + @DestinationSchema + 'View''')

INSERT @TempTableExists       EXEC('SELECT 
										TABLE_NAME 
						        FROM 
									[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.TABLES 
								 WHERE 
									    TABLE_NAME = ''' + @Table + '_Temp'' 
									AND TABLE_SCHEMA = ''' + @DestinationSchema + '''')

INSERT @PrimaryKeys SELECT PrimaryKeyColumnName AS ColumnName,ROW_NUMBER() OVER (ORDER BY PrimaryKeyColumnName) AS OrdinalPosition FROM meta.BusinessMatrixIncrementalSetup INNER JOIN meta.BusinessMatrix ON BusinessMatrix.ID = BusinessMatrixIncrementalSetup.BusinessMatrixID WHERE BusinessMatrix.TableName = @Table

INSERT @PrimaryDimensionKeys SELECT ColumnName,ROW_NUMBER() OVER (ORDER BY ColumnName) AS OrdinalPosition FROM @InformationSchema WHERE ColumnName LIKE '%' + @BusinessKeySuffix

INSERT @DWRelations EXEC meta.CreateDWRelations @Table		

INSERT @SCD2Columns EXEC('WITH AllColumns AS

						  (
						  SELECT COLUMN_NAME COLLATE ' + @DatabaseCollation + ' AS COLUMN_NAME
						  FROM 
							[' + @DatabaseNameStage + '].INFORMATION_SCHEMA.COLUMNS
						  WHERE
							TABLE_NAME = ''' + @Table + '''
							AND COLUMN_NAME NOT LIKE ''DW%''

						  )
						  
						  
						  
						  SELECT 
								 IIF(SCD2ColumnName = ''*'',COLUMN_NAME,SCD2ColumnName)
								,ROW_NUMBER() OVER ( ORDER BY IIF(SCD2ColumnName = ''*'',COLUMN_NAME,SCD2ColumnName))
						  FROM 
							[meta].[BusinessMatrixSCD2Setup] 
						  INNER JOIN 
							[meta].[BusinessMatrix] 
								ON BusinessMatrixSCD2Setup.BusinessMatrixID = BusinessMatrix.ID
						  LEFT JOIN
							AllColumns
								ON SCD2ColumnName = ''*''
						  WHERE 
							TableName = ''' + @Table + '''
							AND DestinationSchema = ''dim''
							AND SCD2ColumnName <> ''''
							AND BusinessMatrix.SCD2DimensionFlag = 1
						  GROUP BY 
							IIF(SCD2ColumnName = ''*'',COLUMN_NAME,SCD2ColumnName)')
						
/*Populates @DimensionCombinedKeys to check if combined keys are used and in which dimensions they are used*/

INSERT @DimensionCombinedKeys  SELECT 
										TableName
									  ,	TableColumnName
									  ,	RolePlayingDimensionName
																  
								FROM 
									@DWRelations						
								WHERE --Only dimensions with composite keys are maintained
									RolePlayingDimensionName IN (
								SELECT 
										RolePlayingDimensionName
								FROM 
									@DWRelations
								WHERE
									TableColumnName  LIKE RolePlayingDimensionName + '%'
								GROUP BY
										RolePlayingDimensionName
								HAVING
									COUNT(*) > 1) 
								AND TableColumnName  LIKE RolePlayingDimensionName + '%'
								
							
						
/**********************************************************************************************************************************************************************
2. Create Loop counter variables
***********************************************************************************************************************************************************************/

DECLARE @Counter AS INT --Just a counter for the loop		
DECLARE @NumberOfColumns AS INT --Holds the number of columns in the table
DECLARE @NumberOfPrimaryColumns AS INT --Holds the number of columns in the table
DECLARE @NumberOfPrimaryDimensionColumns AS INT --Holds the number of columns in the table
DECLARE @NumberOfSCD2Columns AS INT --Holds the number of columns in the table
DECLARE @SCD2HistoryFromSourceKey BIT --If the dimension has the following columns DimensionNameIsCurrent, DimensionNameValidFromDate and DimensionNameValidToDate SCD2 history is created in the source
								
SELECT 
	@Counter = 1,
	@NumberOfColumns = (SELECT MAX(OrdinalPosition) FROM @InformationSchema),
	@NumberOfPrimaryColumns = (SELECT MAX(OrdinalPosition) FROM @PrimaryKeys),
	@NumberOfPrimaryDimensionColumns = (SELECT MAX(OrdinalPosition) FROM @PrimaryDimensionKeys),
	@NumberOfSCD2Columns = (SELECT MAX(OrdinalPosition) FROM @SCD2Columns),
	@SCD2HistoryFromSourceKey = (SELECT IIF(COUNT(ColumnName) = 3, 1, 0) FROM @InformationSchema WHERE REPLACE(ColumnName,@Table,'') IN ('IsCurrent', 'ValidFromDate', 'ValidToDate') AND DatabaseName = 'Stage' )



/**********************************************************************************************************************************************************************
3. Create Auditcolumn variable
***********************************************************************************************************************************************************************/

DECLARE @AuditColumns NVARCHAR(MAX) = CASE 
										  WHEN @DestinationSchema = 'dim' 
											  THEN ',[DWIsCurrent] BIT NOT NULL' + @CRLF + ',[DWValidFromDate] DATETIME NOT NULL' + @CRLF + ',[DWValidToDate] DATETIME NOT NULL' + @CRLF + ',[DWCreatedDate] DATETIME NOT NULL' + @CRLF + ',[DWModifiedDate] DATETIME NOT NULL' + @CRLF + ',[DWIsDeleted] BIT NOT NULL'
										  ELSE ',[DWCreatedDate] DATETIME NOT NULL' + @CRLF + ',[DWModifiedDate] DATETIME NOT NULL'
									  END


/**********************************************************************************************************************************************************************
4. Generates the columns for the create table script
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderColumnNameCreateTable AS NVARCHAR(MAX) 
DECLARE @ColumnNameCreateTable AS NVARCHAR(MAX) 


BEGIN

WHILE @Counter <= @NumberOfColumns

BEGIN

	SELECT @PlaceholderColumnNameCreateTable =
											--Check if it is the first column
											   CASE 
													WHEN OrdinalPosition = 1 
														THEN ''
													ELSE ','
											   END 
											   
											   + 
											--If the destination schema is bridge or fact key columns are converted to ID with datatype int with the default value stated in application.Variables  
											   CASE 
													WHEN @DestinationSchema IN ('fact','bridge') AND ColumnName LIKE '%' + @BusinessKeySuffix AND ColumnName NOT IN (SELECT ColumnName FROM @DimensionCombinedKeys) 
														THEN  '[' + REPLACE(ColumnName,@BusinessKeySuffix,@SurrogatKeySuffix) + '] INT NOT NULL DEFAULT(' + (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DefaultDimensionMemberID') + ')'
													WHEN @DestinationSchema IN ('fact','bridge') AND ColumnName LIKE '%' + @BusinessKeySuffix AND ColumnName IN (SELECT ColumnName FROM @DimensionCombinedKeys) 
														THEN  '[' + (SELECT DISTINCT DimensionTable FROM @DimensionCombinedKeys AS Dimension WHERE InformationSchema.ColumnName = Dimension.ColumnName) + @SurrogatKeySuffix + '] INT NOT NULL DEFAULT(' + (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DefaultDimensionMemberID') + ')'
											--If not column datatypes are maintained with the default value stated in application.Variables  
													ELSE  '[' + ColumnName + '] ' + UPPER(DataType) +  CASE 
																											WHEN DataType LIKE '%int%' OR DataType LIKE '%float%' 
																												THEN ''
																											WHEN DataType IN ('nvarchar', 'varchar', 'nchar', 'char') AND CharacterMaximumLenght = -1 
																												THEN '(MAX)'
																											WHEN CharacterMaximumLenght IS NOT NULL 
																												THEN ' (' + CAST(CharacterMaximumLenght AS NVARCHAR(50)) + ')'
																											WHEN NumericPrecision IS NOT NULL 
																												THEN ' (' + CAST(NumericPrecision AS NVARCHAR(50)) + ', ' + CAST(NumericScale AS NVARCHAR(50))+ ')'
																											ELSE '' 
																										END + CASE
																												 WHEN @DestinationSchema IN ('fact','bridge') AND InformationSchema.ColumnName IN (SELECT ColumnName FROM @PrimaryKeys) 
																													THEN ' NOT NULL'
																												 ELSE ''
																											  END
																												
												
											   END
																				
												+ 
											   @CRLF 
                                    
	FROM 
		@InformationSchema AS InformationSchema
	WHERE 
		OrdinalPosition = @Counter

	SET @ColumnNameCreateTable = CONCAT(@ColumnNameCreateTable,CASE WHEN ISNULL( CHARINDEX (REPLACE(@PlaceholderColumnNameCreateTable,',','') , @ColumnNameCreateTable),0) <> 0 THEN '' ELSE @PlaceholderColumnNameCreateTable END)

	SET @PlaceholderColumnNameCreateTable = ''

	SET @Counter = @Counter + 1

END



SET @Counter = 1


/**********************************************************************************************************************************************************************
5. Generates the columns for the create view script
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderColumnNameCreateView AS NVARCHAR(MAX) 
DECLARE @ColumnNameCreateView AS NVARCHAR(MAX) 

WHILE @Counter <= @NumberOfColumns

BEGIN

	SELECT @PlaceholderColumnNameCreateView = 
											  --Check if it is the first column
											  CASE 
												 WHEN OrdinalPosition = 1 
													THEN ''
												 ELSE ','
											  END 
											  
											  + 
											  --If the destination schema is bridge or fact key columns are converted to ID.  
											  CASE 
												WHEN @DestinationSchema IN ('fact','bridge') AND ColumnName LIKE '%' + @BusinessKeySuffix AND ColumnName NOT IN (SELECT ColumnName FROM @DimensionCombinedKeys) 
													THEN '[' + REPLACE(ColumnName,@BusinessKeySuffix,@SurrogatKeySuffix) + '] '
												WHEN @DestinationSchema IN ('fact','bridge') AND ColumnName LIKE '%' + @BusinessKeySuffix AND ColumnName IN (SELECT ColumnName FROM @DimensionCombinedKeys) 
													THEN  '[' + (SELECT DISTINCT DimensionTable FROM @DimensionCombinedKeys AS Dimension WHERE InformationSchema.ColumnName = Dimension.ColumnName) + @SurrogatKeySuffix + ']' 
											  --If not the column is given an alias where the name is splited on upper characters
											  	WHEN (@DestinationSchema IN ('fact','bridge') AND (ColumnName LIKE '%Code' OR ColumnName LIKE '%Name' OR ColumnName LIKE '%Label')) OR (@DestinationSchema = 'dim' AND ColumnName NOT LIKE '%' + @SurrogatKeySuffix)
													THEN '[' + ColumnName + '] AS [' + meta.SplitCamelCase(ColumnName) +']'
												ELSE '[' + ColumnName + ']'
											  END

											  +

											  @CRLF							  
											  											
	FROM 
		@InformationSchema AS InformationSchema
	WHERE 
		OrdinalPosition = @Counter

	SET @ColumnNameCreateView = CONCAT(@ColumnNameCreateView,CASE WHEN ISNULL( CHARINDEX (REPLACE(@PlaceholderColumnNameCreateView,',','') , @ColumnNameCreateView),0) <> 0 THEN '' ELSE @PlaceholderColumnNameCreateView END)

	SET @PlaceholderColumnNameCreateView = ''

	SET @Counter = @Counter + 1

END


SET @Counter = 1

/**********************************************************************************************************************************************************************
6. Create Primary Key Columns
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderPrimaryKeyColumns NVARCHAR(MAX)
DECLARE @PrimaryKeyColumns NVARCHAR(MAX)
DECLARE @PlaceholderPrimaryKeyColumnsExtended NVARCHAR(MAX)
DECLARE @PrimaryKeyColumnsExtended NVARCHAR(MAX)

WHILE @Counter <= @NumberOfPrimaryColumns

BEGIN

	SELECT 
		 @PlaceholderPrimaryKeyColumns = CASE WHEN @Counter = 1 THEN '' ELSE ',' END + ColumnName
		,@PlaceholderPrimaryKeyColumnsExtended = 'EXEC [' + @DatabaseNameDW + '].sys.sp_addextendedproperty @name=N''PrimaryKeyColumn'', @value=N''PK'' ,@level0type = N''Schema'', @level0name = ''' + @DestinationSchema + ''' ,@level1type = N''Table'',  @level1name = ''' + @Table + ''' ,@level2type = N''Column'', @level2name = ''' + ColumnName + '''' + @CRLF
	FROM 
		@PrimaryKeys
	WHERE
		OrdinalPosition = @Counter

SET @PrimaryKeyColumns = CONCAT(@PrimaryKeyColumns,@PlaceholderPrimaryKeyColumns)
SET @PrimaryKeyColumnsExtended = CONCAT(@PrimaryKeyColumnsExtended,@PlaceholderPrimaryKeyColumnsExtended)

SET @PlaceholderPrimaryKeyColumns = ''
SET @PlaceholderPrimaryKeyColumnsExtended = ''

SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
7. Create Primary Key Columns
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderPrimaryDimensionKeyColumns NVARCHAR(MAX)
DECLARE @PrimaryDimensionKeyColumns NVARCHAR(MAX)

WHILE @Counter <= @NumberOfPrimaryDimensionColumns

BEGIN

	SELECT @PlaceholderPrimaryDimensionKeyColumns = CASE WHEN @Counter = 1 THEN '' ELSE ',' END + ColumnName
	FROM 
		@PrimaryDimensionKeys
	WHERE
		OrdinalPosition = @Counter

SET @PrimaryDimensionKeyColumns = CONCAT(@PrimaryDimensionKeyColumns,@PlaceholderPrimaryDimensionKeyColumns)

SET @PlaceholderPrimaryDimensionKeyColumns = ''

SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
8. Create SCD2 columns
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderSCD2 NVARCHAR(MAX)
DECLARE @SCD2 NVARCHAR(MAX)

WHILE @Counter <= @NumberOfSCD2Columns

BEGIN

	SELECT @PlaceholderSCD2 = 'EXEC [' + @DatabaseNameDW + '].sys.sp_addextendedproperty @name=N''SCDColumn'', @value=N''SCD2'' ,@level0type = N''Schema'', @level0name = ''dim'' ,@level1type = N''Table'',  @level1name = ''' + @Table + ''' ,@level2type = N''Column'', @level2name = ''' + ColumnName + '''' + @CRLF
	FROM 
		@SCD2Columns
	WHERE
		OrdinalPosition = @Counter

SET @SCD2 = CONCAT(@SCD2,@PlaceholderSCD2)

SET @PlaceholderSCD2 = ''

SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
9. Fill out the dynamic SQL script variables
***********************************************************************************************************************************************************************/

DECLARE @CreateTableScript AS NVARCHAR(MAX) 
DECLARE @CreateTempTableScript AS NVARCHAR(MAX) 
DECLARE @CreateClusteredColumnStoreIndexScript NVARCHAR(MAX)
DECLARE @PrepareViewScript AS NVARCHAR(MAX) 
DECLARE @CreateViewScript NVARCHAR(MAX) 
DECLARE @PrepareTempViewScript AS NVARCHAR(MAX) 
DECLARE @CreateTempViewScript NVARCHAR(MAX) 
DECLARE @CreateIncrementalProperty NVARCHAR(MAX)
DECLARE @CreateTruncateProperty NVARCHAR(MAX)
DECLARE @CreateTruncatePropertyTemp NVARCHAR(MAX)

/*Generates the final create table script*/

SET @CreateTableScript = 'CREATE TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].[' + @Table + ']' + @CRLF +
'(' + @CRLF +
CASE WHEN @DestinationSchema IN ('fact','bridge') THEN '' 
	 ELSE ' [' + @Table + @SurrogatKeySuffix + '] INT IDENTITY PRIMARY KEY' + @CRLF + ',' 
END + @ColumnNameCreateTable 
+ @AuditColumns 
+ @CRLF +
+ CASE 
	   WHEN @DestinationSchema IN ('fact','bridge') AND @FactIsIncremental = 1 AND @PrimaryKeyColumns IS NOT NULL AND @LoadPattern = 'Standard' THEN 'CONSTRAINT PK_' + @Table + ' PRIMARY KEY NONCLUSTERED (' + @PrimaryKeyColumns + ')'
	   WHEN @DestinationSchema IN ('dim') THEN 'CONSTRAINT NCI_' + @Table + ' UNIQUE NONCLUSTERED (' + @PrimaryDimensionKeyColumns + IIF(@SCD2HistoryFromSourceKey = 1, ',' + @Table + 'ValidFromDate)',',DWValidFromDate)')
 	  -- WHEN @DestinationSchema IN ('dim') AND @SCD2HistoryFromSourceKey = 1 THEN 'CONSTRAINT NCI_' + @Table + ' UNIQUE NONCLUSTERED (' + @PrimaryDimensionKeyColumns + ',' + @Table + 'ValidFromDate)'
	  -- WHEN @DestinationSchema IN ('dim') AND NOT EXISTS (SELECT * FROM @SCD2Columns) THEN 'CONSTRAINT NCI_' + @Table + ' UNIQUE NONCLUSTERED (' + @PrimaryDimensionKeyColumns + ')'
	   ELSE ''
  END +
')'

/*Generates the final create temp table script for incremental facts*/

SET @CreateTempTableScript = 'CREATE TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].[' + @Table + '_Temp]' + @CRLF +
'(' + @CRLF +
+ @ColumnNameCreateTable
+ @AuditColumns
+ @CRLF +
CASE 
	 WHEN @CompatibilityLevel >= 130  AND @SQLEnterpriseServer = 1 AND @PrimaryKeyColumns IS NOT NULL AND @LoadPattern = 'Standard' AND @FactEngineIsSQLFlag = 0 AND @FactInMemoryFlag = 1 THEN 'INDEX PK_TEMP_' + @Table + ' UNIQUE NONCLUSTERED HASH (' + @PrimaryKeyColumns + ') WITH (BUCKET_COUNT = 1000000)' 
	 WHEN @LoadPattern = 'Standard' AND @PrimaryKeyColumns IS NOT NULL THEN 'CONSTRAINT PK_TEMP_' + @Table + ' PRIMARY KEY NONCLUSTERED (' + @PrimaryKeyColumns + ')' 
	 ELSE ''
END + @CRLF + 
') ' + CASE WHEN @CompatibilityLevel >= 130  AND @SQLEnterpriseServer = 1 AND @PrimaryKeyColumns IS NOT NULL AND @LoadPattern = 'Standard' AND @FactEngineIsSQLFlag = 0 AND @FactInMemoryFlag = 1 THEN ' WITH (MEMORY_OPTIMIZED = ON, DURABILITY = SCHEMA_ONLY)' ELSE '' END

SET @CreateClusteredColumnStoreIndexScript = 'CREATE CLUSTERED COLUMNSTORE INDEX [CCI_' + @Table + '] ON [' + @DatabaseNameDW + '].[fact].[' + @Table + '] WITH (DROP_EXISTING = OFF)'

/*Generates the final create view script*/

SET @PrepareViewScript = 'CREATE VIEW [' + @DestinationSchema + 'View].[' + @ViewName + '] AS' + @CRLF +
'SELECT' + @CRLF +
CASE WHEN @DestinationSchema IN ('dim') THEN' [' + @Table + @SurrogatKeySuffix + ']' + @CRLF + ',' 
     ELSE '' 
END + @ColumnNameCreateView + @CRLF +
'  FROM [' + @DestinationSchema + '].[' + @Table + ']'

END

/*Generates the create view script so it can be executed in the DW database*/
SET @CreateViewScript =IIF(@IsSingleDatabase = 1,'','USE [' + @DatabaseNameDW + ']') + @CRLF + 'EXEC(''' + @PrepareViewScript + ''')'


SET @PrepareTempViewScript = 'CREATE VIEW [' + @DestinationSchema + 'View].[' + @ViewName + '_Temp] AS' + @CRLF +
'SELECT' + @CRLF +
CASE WHEN @DestinationSchema IN ('dim') THEN' [' + @Table + @SurrogatKeySuffix + ']' + @CRLF + ',' 
     ELSE '' 
END + @ColumnNameCreateView + @CRLF +
'  FROM [' + @DestinationSchema + '].[' + @Table + '_Temp]'

SET @CreateTempViewScript =IIF(@IsSingleDatabase = 1,'','USE [' + @DatabaseNameDW + ']') + @CRLF + 'EXEC(''' + @PrepareTempViewScript + ''')'

SET @CreateIncrementalProperty = 'EXEC [' + @DatabaseNameDW + '].sys.sp_addextendedproperty @name=N''IncrementalFactOrBridgeFlag'', @value=N''1'' ,@level0type = N''Schema'', @level0name = ''' + @DestinationSchema + ''' ,@level1type = N''Table'',  @level1name = ''' + @Table + '''' + @CRLF

SET @CreateTruncateProperty = IIF(@TruncateFlag = 0,'','EXEC [' + @DatabaseNameDW + '].sys.sp_addextendedproperty @name = N''TruncateBeforeDeploy'', @value = N''True'', @level0type = N''SCHEMA'', @level0name = N''' + @DestinationSchema + ''', @level1type = N''TABLE'', @level1name = N''' + @Table +'''' + @CRLF	)																						
SET @CreateTruncatePropertyTemp = 'EXEC [' + @DatabaseNameDW + '].sys.sp_addextendedproperty @name = N''TruncateBeforeDeploy'', @value = N''True'', @level0type = N''SCHEMA'', @level0name = N''' + @DestinationSchema + ''', @level1type = N''TABLE'', @level1name = N''' + @Table +'_Temp''' + @CRLF																					

/**********************************************************************************************************************************************************************
10. Execute dynamic SQL
***********************************************************************************************************************************************************************/

IF @PrintSQL = 0

	BEGIN

		/*Check if table exists*/
		IF NOT EXISTS (SELECT * FROM @TableExists)

			BEGIN

				EXEC(@CreateTableScript)
				EXEC(@SCD2) 
				EXEC(@CreateTruncateProperty)
				IF @FactIsIncremental = 1
					BEGIN
						EXEC(@CreateIncrementalProperty)
						EXEC(@PrimaryKeyColumnsExtended) 
					END
				IF @DestinationSchema = 'fact' AND @SQLEnterpriseServer = 1 AND @CompatibilityLevel >= 130 AND @FactCCIFlag = 1
					BEGIN
						EXEC(@CreateClusteredColumnStoreIndexScript)
					END
			END

		/*Check if view exists*/
		IF NOT EXISTS (SELECT * FROM @ViewExists)

			BEGIN
				EXEC(@CreateViewScript)
			END

		/*Check if temp table exists*/

		IF EXISTS (SELECT * FROM @TempTableExists) AND @FactIsIncremental = 1
			BEGIN
				EXEC('DROP TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].[' + @Table + '_Temp]')
				EXEC(@CreateTempTableScript)
				EXEC(@CreateTruncatePropertyTemp)
			END

		IF NOT EXISTS (SELECT * FROM @TempTableExists) AND @FactIsIncremental = 1

			BEGIN
				EXEC(@CreateTempTableScript)
				EXEC(@CreateTruncatePropertyTemp)
			END

		/*Check if temp view exists*/

		IF NOT EXISTS (SELECT * FROM @TempViewExists) AND @DestinationSchema = 'fact' AND @LoadPattern <> 'Standard' AND @FactIsIncremental = 1

			BEGIN
				EXEC(@CreateTempViewScript)
			END

	END

ELSE

	BEGIN

		 /*Check if table exists*/
		IF NOT EXISTS (SELECT * FROM @TableExists)

			BEGIN

				PRINT(@CreateTableScript) + @CRLF + @CRLF
				PRINT(@SCD2) + @CRLF + @CRLF
				PRINT(@CreateTruncateProperty) + @CRLF + @CRLF
				IF @FactIsIncremental = 1
					BEGIN
						PRINT(@CreateIncrementalProperty) + @CRLF + @CRLF
						PRINT(@PrimaryKeyColumnsExtended) + @CRLF + @CRLF 
					END
				IF @DestinationSchema = 'fact' AND @SQLEnterpriseServer = 1 AND @CompatibilityLevel >= 130 AND @FactCCIFlag = 1
					BEGIN
						PRINT(@CreateClusteredColumnStoreIndexScript) + @CRLF + @CRLF
					END
			END

		/*Check if view exists*/
		IF NOT EXISTS (SELECT * FROM @ViewExists)

			BEGIN
				PRINT(@CreateViewScript) + @CRLF + @CRLF
			END

		/*Check if temp table exists*/

		IF EXISTS (SELECT * FROM @TempTableExists) AND @FactIsIncremental = 1
			BEGIN
				PRINT('DROP TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].[' + @Table + '_Temp]') + @CRLF + @CRLF
				PRINT(@CreateTempTableScript) + @CRLF + @CRLF
				PRINT(@CreateTruncatePropertyTemp) + @CRLF + @CRLF
			END

		IF NOT EXISTS (SELECT * FROM @TempTableExists) AND @FactIsIncremental = 1

			BEGIN
				PRINT(@CreateTempTableScript) + @CRLF + @CRLF
				PRINT(@CreateTruncatePropertyTemp) + @CRLF + @CRLF
			END

		/*Check if temp view exists*/

		IF NOT EXISTS (SELECT * FROM @TempViewExists) AND @DestinationSchema = 'fact' AND @LoadPattern <> 'Standard' AND @FactIsIncremental = 1

			BEGIN
				PRINT(@CreateTempViewScript) + @CRLF + @CRLF
			END

		


	END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[MaintainDWFactIndexes]...';


GO
	


/**********************************************************************************************************************************************************************
The purpose of this scripts is to create and execute the create or drop clustered column store index script and the rebuild or disable index script on fact tables. 
The script has the following charasteristic:
	- Indexes is maintained on facts
	- Clustered column store indexes is only created if the compatibility level is 120 or higher and the server version is Enterprise
***********************************************************************************************************************************************************************/


CREATE PROCEDURE [meta].[MaintainDWFactIndexes]

@Table VARCHAR(100),--Input is the table name without schema
@DestinationSchema VARCHAR(10),
@DisableIndexes BIT,--Input is 1 if you want to create indexes and 0 if you want to drop indexes
@PrintSQL BIT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/

DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10) 
DECLARE @DatabaseNameDW NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW')
DECLARE @DatabaseCollation NVARCHAR(100) = (SELECT CONVERT (varchar, DATABASEPROPERTYEX('' + @DatabaseNameDW + '','collation')))
DECLARE @CompatibilityLevelTable TABLE (CompatibilityLevel INT)
INSERT @CompatibilityLevelTable EXEC('(SELECT compatibility_level FROM sys.databases WHERE name COLLATE ' + @DatabaseCollation + ' = (SELECT VariableValue FROM meta.Variables WHERE VariableName = ''DatabaseNameDW''))')
DECLARE @CompatibilityLevel INT = (SELECT CompatibilityLevel FROM @CompatibilityLevelTable)
DECLARE @SQLEnterpriseServer BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'EnterpriseEditionFlag')
DECLARE @FactCCIFlag BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'FactCCIFlag')
DECLARE @FactLoadEngine NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'FactLoadEngine')
DECLARE @IsCloudFlag BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'IsCloudFlag')


/**********************************************************************************************************************************************************************
1. Create and insert data into table variables
***********************************************************************************************************************************************************************/
DECLARE @FactIndex TABLE (IndexName NVARCHAR(128), OrdinalPosition INT, IsDisabled INT)
DECLARE @FactIndexSQL NVARCHAR(MAX) = IIF(@IsCloudFlag = 1,'','USE [' + @DatabaseNameDW + ']') + ' SELECT name,ROW_NUMBER() OVER (ORDER BY name), is_disabled FROM sys.indexes WHERE object_id = object_id(''' + @DestinationSchema + '.' + @Table + ''') AND type_desc NOT LIKE ''CLUSTERED%'' AND type_desc <> ''HEAP'''


INSERT @FactIndex EXEC(@FactIndexSQL)

/**********************************************************************************************************************************************************************
2. Create Loop counter variables
***********************************************************************************************************************************************************************/

DECLARE @Counter AS INT --Just a counter for the loop		
DECLARE @NumberOfColumns AS INT --Holds the number of columns in the table
								
SELECT 
	@Counter = 1,
	@NumberOfColumns = (SELECT MAX(OrdinalPosition) FROM @FactIndex)

/**********************************************************************************************************************************************************************
3. Create clustered columnstore index script
***********************************************************************************************************************************************************************/

DECLARE @ClusteredColumnStoreIndexScript NVARCHAR(MAX)

SET @ClusteredColumnStoreIndexScript = IIF(@IsCloudFlag = 1,'','USE [' + @DatabaseNameDW + ']') + @CRLF + CASE 
																				WHEN @DisableIndexes = 0 
																					THEN   'IF NOT EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id(''' + @DestinationSchema + '.' + @Table + ''') AND type_desc = ''CLUSTERED'' AND NAME <> ''CCI_'+ @Table + ''')
																							BEGIN
																							IF NOT EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id(''' + @DestinationSchema + '.' + @Table + ''') AND NAME = ''CCI_'+ @Table + ''')' + @CRLF +
																							'CREATE CLUSTERED COLUMNSTORE INDEX [CCI_' + @Table + '] ON [fact].[' + @Table + '] WITH (DROP_EXISTING = OFF)
																							END'

																				ELSE 

																							'IF EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id(''' + @DestinationSchema + '.' + @Table + ''') AND NAME = ''CCI_'+ @Table + ''')' + @CRLF +
																							'DROP INDEX [CCI_' + @Table + '] ON [fact].[' + @Table + ']'

																		  END

/**********************************************************************************************************************************************************************
4. Create disable index script
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderIndex NVARCHAR(MAX)
DECLARE @Index NVARCHAR(MAX)

WHILE @Counter <= @NumberOfColumns

BEGIN

	SELECT 
			@PlaceholderIndex =		   CASE 
											WHEN @DisableIndexes = 1 
												THEN IIF(IsDisabled = 1,'',IIF(@IsCloudFlag = 1,'','USE [' + @DatabaseNameDW + ']') + ' ALTER INDEX [' + IndexName + '] ON fact.' + @Table + ' DISABLE;') + @CRLF
											ELSE IIF(IsDisabled = 0,'',IIF(@IsCloudFlag = 1,'','USE [' + @DatabaseNameDW + ']') + ' ALTER INDEX [' + IndexName + '] ON fact.' + @Table + ' REBUILD;') + @CRLF 
									   END
									
	FROM 
		@FactIndex
	WHERE
		OrdinalPosition = @Counter

SET @Index = CONCAT(@Index,@PlaceholderIndex)

SET @PlaceholderIndex = ''

SET @Counter = @Counter + 1

END


/**********************************************************************************************************************************************************************
5. Execute dynamic SQL script variables
***********************************************************************************************************************************************************************/

/*Only executed if the destination schema is fact and SQL server is Enterprise and 2014 or higher*/

IF @DestinationSchema = 'fact'  

	BEGIN 

		IF @PrintSQL = 0

			BEGIN
		/*Only executed if the destination schema is fact and SQL server is Enterprise and 2014 or higher*/

				IF @CompatibilityLevel >= 120 AND @SQLEnterpriseServer = 1 AND @FactCCIFlag = 1 AND @FactLoadEngine = 'SSIS'

					BEGIN

						EXEC(@ClusteredColumnStoreIndexScript)

					END

				/*Only executed if the destination schema is fact*/

				EXEC(@Index)

			END

		ELSE

			BEGIN

				IF @CompatibilityLevel >= 120 AND @SQLEnterpriseServer = 1 AND @FactCCIFlag = 1 AND @FactLoadEngine = 'SSIS'

					BEGIN

						PRINT(@ClusteredColumnStoreIndexScript) + @CRLF + @CRLF

					END

				/*Only executed if the destination schema is fact*/

				PRINT(@Index)

			END

	END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[ScaleDatabase]...';


GO


CREATE PROCEDURE [meta].[ScaleDatabase] 

@DatabaseSkuName NVARCHAR(20)
			
AS 

SET NOCOUNT ON
		
EXEC('ALTER DATABASE [<%DatabaseNameDW%>] MODIFY (SERVICE_OBJECTIVE = ''' + @DatabaseSkuName + ''')')

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[DeleteIncrementalRows]...';


GO


/**********************************************************************************************************************************************************************
The purpose of this scripts is to delete rows in the history table based on the period extracted
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[DeleteIncrementalRows] 

  @TableName NVARCHAR(100)
, @ExtractSchemaName NVARCHAR(100)
, @PrintSQL BIT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/

DECLARE @ObjectID INT
DECLARE @IncrementalValueColumn NVARCHAR(500)
DECLARE @IsDateFlag BIT
DECLARE @DatabaseNameExtract NVARCHAR(50) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameExtract')

SET @ObjectID = (
					SELECT SourceObjects.ID 
					FROM 
						meta.SourceObjects
					INNER JOIN
						meta.SourceConnections
							ON SourceConnections.ID = SourceObjects.SourceConnectionID
					WHERE 
						SourceObjects.ObjectName = @TableName
						AND SourceConnections.ExtractSchemaName = @ExtractSchemaName
				)

SET @IncrementalValueColumn =	(
									SELECT IIF(IncrementalValueColumnDefinitionInExtract <> '',IncrementalValueColumnDefinitionInExtract, IncrementalValueColumnDefinition)
									FROM meta.SourceObjectIncrementalSetup
									WHERE SourceObjectID = @ObjectID
								)

SET @IsDateFlag = (
					SELECT IsDateFlag
					FROM meta.SourceObjectIncrementalSetup
					WHERE SourceObjectID = @ObjectID
				)

/**********************************************************************************************************************************************************************
1. Execute dynamic SQL script variables
***********************************************************************************************************************************************************************/

DECLARE @SQL NVARCHAR(MAX) 


SET @SQL = '
DECLARE @MinDate NVARCHAR(50)
DECLARE @MaxDate NVARCHAR(50)

SET @MinDate = (SELECT MIN([' + @IncrementalValueColumn + ']) FROM [' + @DatabaseNameExtract + '].[' + @ExtractSchemaName + '].[' + @TableName + '])
SET @MaxDate = (SELECT MAX([' + @IncrementalValueColumn + ']) FROM [' + @DatabaseNameExtract + '].[' + @ExtractSchemaName + '].[' + @TableName + '])

DELETE T1 WITH (TABLOCK) FROM [' + @DatabaseNameExtract + '].[' + @ExtractSchemaName + '].[' + @TableName + '_History] AS T1 WHERE [' + @IncrementalValueColumn + '] >= @MinDate AND [' + @IncrementalValueColumn + '] <= @MaxDate'
	

IF @PrintSQL = 1

	BEGIN
		PRINT(@SQL)
	END

ELSE
	
	BEGIN
		EXEC(@SQL)
	END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[MaintainExtractInformationSchemaFromJsonMeta]...';


GO


/**********************************************************************************************************************************************************************
The purpose of this scripts is to update meta data information schema table based on Get Metadata activity in ADF
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[MaintainExtractInformationSchemaFromJsonMeta] 
@SourceObjectID int, -- SourceObjectID
@JsonOutput NVARCHAR(MAX)--Json output from ADF Get Meta Data activity

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/
DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10)
DECLARE @ConnectionType NVARCHAR(128) = (SELECT ConnectionType FROM [meta].[SourceObjectDefinitions] WHERE SourceObjectID = @SourceObjectID)
DECLARE @FileName NVARCHAR(128) = (SELECT FileName FROM [meta].[SourceObjectDefinitions] WHERE SourceObjectID = @SourceObjectID)

/**********************************************************************************************************************************************************************
1. Update ExtractInformationSchema table
**********************************************************************************************************************************************************************/

DELETE FROM meta.ExtractInformationSchema WHERE SourceObjectID= @SourceObjectID;

INSERT INTO meta.ExtractInformationSchema
(
	[SourceObjectID], 
	[SourceSystemTypeName], 
	[TableCatalogName], 
	[SchemaName], 
	[TableName], 
	[ColumnName], 
	[OrdinalPositionNumber], 
	[DataTypeName], 
	[MaximumLenghtNumber], 
	[NumericPrecisionNumber], 
	[NumericScaleNumber], 
	[KeySequenceNumber]
)

SELECT
	@SourceObjectID			AS SourceObjectID
	,@ConnectionType		AS SourceSystemTypeName
	,null					AS TableCatalogName
	,null					AS SchemaName
	,@FileName				AS TableName
    ,SourceItems.name		AS ColumnName
	,ROW_NUMBER() OVER (PARTITION BY SourceHeader.itemName, SourceHeader.itemType ORDER BY (SELECT NULL))
							AS OrdinalPositionNumber
	,SourceItems.type		AS DataTypeName
	,null					AS MaximumLenghtNumber
	,null					AS NumericPrecisionNumber
	,null					AS NumericScaleNumber
	,null					AS KeySequenceNumber   
FROM OPENJSON(@JsonOutput)
WITH(
	itemName  varchar(200),
    itemType  varchar(200),  
    structure nvarchar(max) '$.structure' AS JSON
) SourceHeader
CROSS APPLY OPENJSON(SourceHeader.structure)
WITH(name nvarchar(200)
    ,type nvarchar(200)) SourceItems

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[MaintainTargetCreateConnectionScript]...';


GO


/**********************************************************************************************************************************************************************
The purpose of this scripts is to create the source SQL for extract packages
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[MaintainTargetCreateConnectionScript] 

@TargetObjectID INT,
@PrintSQL BIT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/
DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10)
DECLARE @DatabaseNameExtract NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameExtract')
	
/**********************************************************************************************************************************************************************
1. Update FrameworkMetaData table with IDs
***********************************************************************************************************************************************************************/
INSERT INTO meta.FrameworkMetaData
(TargetObjectID)

SELECT 
	TargetObjects.ID 
FROM 
	meta.TargetObjects 
LEFT JOIN 
	meta.FrameworkMetaData 
		ON FrameworkMetaData.TargetObjectID = TargetObjects.ID 
WHERE 
	FrameworkMetaData.BusinessMatrixID IS NULL
	AND FrameworkMetaData.SourceObjectID IS NULL
	AND	FrameworkMetaData.TargetObjectID IS NULL
	AND TargetObjects.ID = @TargetObjectID

DELETE FROM meta.FrameworkMetaData WHERE TargetObjectID NOT IN (SELECT ID FROM meta.TargetObjects) AND TargetObjectID IS NOT NULL;

/**********************************************************************************************************************************************************************
2. Create and insert data into table variables
**********************************************************************************************************************************************************************/
DECLARE @InformationSchemaTables TABLE (TargetObjectID INT, FileSystemName NVARCHAR(128),TargetConnectionName NVARCHAR(128), FolderName NVARCHAR(128), FileFormat NVARCHAR(128), AzureDWSchemaName NVARCHAR(128), OrdinalPosition INT)
INSERT @InformationSchemaTables SELECT TargetObjectID,TargetFileSystemName, TargetConnectionName, TargetFolderName, TargetAzureFileTypeName, TargetExtractSchemaName,ROW_NUMBER() OVER ( ORDER BY TargetObjectID) FROM meta.TargetObjectDefinitions WHERE TargetObjectID = @TargetObjectID AND TargetAzureSqlDWFlag = 1 GROUP BY TargetObjectID,TargetFileSystemName,TargetConnectionName,TargetFolderName,TargetAzureFileTypeName,TargetExtractSchemaName

/**********************************************************************************************************************************************************************
3. Create Loop counter variables
**********************************************************************************************************************************************************************/
DECLARE @Counter INT = 1
DECLARE @MaxTable INT = (SELECT MAX(OrdinalPosition) FROM @InformationSchemaTables)


/**********************************************************************************************************************************************************************
4. Create outer loop
**********************************************************************************************************************************************************************/
DECLARE @SQL NVARCHAR(MAX)


WHILE @Counter <= @MaxTable

BEGIN

	SELECT
	  @TargetObjectID = TargetObjectID
	 ,@SQL = 'IF (SELECT [name] FROM [sys].[external_data_sources] WHERE [name] = ''' + TargetConnectionName + FileSystemName + ''') IS NULL' + @CRLF +   
					'CREATE EXTERNAL DATA SOURCE ' + TargetConnectionName + FileSystemName + '
					WITH (
						LOCATION=''abfss://' + LOWER(FileSystemName) + '@' + LOWER(TargetConnectionName) + '.dfs.core.windows.net'',
						CREDENTIAL = ' + TargetConnectionName  + ',
								TYPE = HADOOP
					);
			  IF (SELECT [name] FROM [sys].[schemas] WHERE [name] = ''' + AzureDWSchemaName + ''') IS NULL' + @CRLF +  '
			  EXEC(''CREATE SCHEMA ' + AzureDWSchemaName + ' AUTHORIZATION dbo'');
			  IF (SELECT [name] FROM [sys].[external_file_formats] WHERE [name] = ''' + FileFormat + 'Format'') IS NULL' + @CRLF +  '
			  EXEC(''' + CASE FileFormat
							WHEN 'DelimitedText' THEN 'CREATE EXTERNAL FILE FORMAT ' + FileFormat + 'Format WITH (FORMAT_TYPE = DELIMITEDTEXT, FORMAT_OPTIONS(FIELD_TERMINATOR = '''','''',STRING_DELIMITER = ''''\"'''',USE_TYPE_DEFAULT = True))'
							WHEN 'Parquet'		 THEN 'CREATE EXTERNAL FILE FORMAT ' + FileFormat + 'Format WITH (FORMAT_TYPE = PARQUET, DATA_COMPRESSION = ''''org.apache.hadoop.io.compress.SnappyCodec'''')'
							WHEN 'Orc'			 THEN 'CREATE EXTERNAL FILE FORMAT ' + FileFormat + 'Format WITH (FORMAT_TYPE = PARQUET, DATA_COMPRESSION = ''''org.apache.hadoop.io.compress.SnappyCodec'''')'
							ELSE ''
						 END + ''')'

	FROM 
	@InformationSchemaTables
	WHERE 
	@Counter = OrdinalPosition

/**********************************************************************************************************************************************************************
8. Update FrameworkMetaDate
**********************************************************************************************************************************************************************/
IF @PrintSQL = 0
	BEGIN
		UPDATE FrameworkMetaData
		SET ConnectionSQLScript = @SQL
		FROM meta.FrameworkMetaData
		WHERE TargetObjectID = @TargetObjectID
	END
ELSE
	BEGIN
		PRINT(@SQL)
	END

	SET @SQL = '' 
	SET @Counter = @Counter + 1

END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[MaintainTargetCreateSourceScript]...';


GO


/**********************************************************************************************************************************************************************
The purpose of this scripts is to create the source SQL for extract packages
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[MaintainTargetCreateSourceScript] 

@TargetObjectID INT,
@PrintSQL BIT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/
DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10)
DECLARE @DatabaseNameExtract NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameExtract')
DECLARE @DefaultMaxDop NVARCHAR(3) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DefaultMaxDop')
	
/**********************************************************************************************************************************************************************
1. Update FrameworkMetaData table with IDs
***********************************************************************************************************************************************************************/
INSERT INTO meta.FrameworkMetaData
(TargetObjectID)

SELECT 
	TargetObjects.ID 
FROM 
	meta.TargetObjects 
LEFT JOIN 
	meta.FrameworkMetaData 
		ON FrameworkMetaData.TargetObjectID = TargetObjects.ID 
WHERE 
	FrameworkMetaData.BusinessMatrixID IS NULL
	AND FrameworkMetaData.SourceObjectID IS NULL
	AND	FrameworkMetaData.TargetObjectID IS NULL
	AND TargetObjects.ID = @TargetObjectID

DELETE FROM meta.FrameworkMetaData WHERE TargetObjectID NOT IN (SELECT ID FROM meta.TargetObjects) AND TargetObjectID IS NOT NULL;

/**********************************************************************************************************************************************************************
2. Create and insert data into table variables
**********************************************************************************************************************************************************************/
DECLARE @InformationSchemaTables TABLE (TargetObjectID INT, SourceObjectID INT, ObjectName NVARCHAR(128),OrdinalPosition INT, ParallelizationFlag BIT, PartitionFlag BIT, UseModulusFlag BIT, PartitionValueColumnDefinition NVARCHAR(200), TargetFileFlag BIT)
INSERT @InformationSchemaTables SELECT TargetObjectID,SourceObjectID, SourceTableName, ROW_NUMBER() OVER ( ORDER BY SourceTableName) , ParallelizationFlag, PartitionFlag, UseModulusFlag, PartitionValueColumnDefinition, TargetFileExtractFlag FROM meta.TargetObjectDefinitions WHERE TargetObjectID = @TargetObjectID GROUP BY TargetObjectID,SourceObjectID,SourceTableName, ParallelizationFlag, PartitionFlag, UseModulusFlag, PartitionValueColumnDefinition,TargetFileExtractFlag
/**********************************************************************************************************************************************************************
3. Create Loop counter variables
**********************************************************************************************************************************************************************/
DECLARE @OuterCounter INT = 1
DECLARE @MaxTable INT = (SELECT MAX(OrdinalPosition) FROM @InformationSchemaTables)


/**********************************************************************************************************************************************************************
4. Create outer loop
**********************************************************************************************************************************************************************/
DECLARE @Table NVARCHAR(100)
DECLARE @Parallelization BIT
DECLARE @Partition BIT
DECLARE @UseModulusFlag BIT
DECLARE @PartitionValueColumnDefinition NVARCHAR(200)
DECLARE @TargetFileFlag BIT

WHILE @OuterCounter <= @MaxTable

BEGIN

SELECT
  @TargetObjectID = TargetObjectID
 ,@Table = ObjectName
 ,@Parallelization = ParallelizationFlag
 ,@Partition = PartitionFlag
 ,@UseModulusFlag = UseModulusFlag
 ,@PartitionValueColumnDefinition = PartitionValueColumnDefinition
 ,@TargetFileFlag = TargetFileFlag
FROM 
@InformationSchemaTables
WHERE 
@OuterCounter = OrdinalPosition


/**********************************************************************************************************************************************************************
5. Create and insert data into table variables
**********************************************************************************************************************************************************************/
DECLARE @Schemas TABLE (SourceConnectionID INT, SchemaName NVARCHAR(128), ExtractSchemaName NVARCHAR(128), OrdinalPosition INT)
DECLARE @InformationSchema TABLE (SourceConnectionID INT, TableName NVARCHAR(128),ColumnName NVARCHAR(128), SchemaName NVARCHAR(128), OrdinalPosition INT,DataType NVARCHAR(128), CharacterMaximumLength NVARCHAR(128), NumericPrecisionNumber INT ,SourceSystem NVARCHAR(128), OriginalDataType NVARCHAR(128), KeySequence INT)


INSERT @InformationSchema EXEC('WITH SourceData AS 
(SELECT 
   SourceConnectionID
  ,[TableName]
  ,MetaData.[ColumnName]
  ,[SchemaName]
  ,[OrdinalPositionNumber]
  ,[DataTypeName]
  ,[MaximumLenghtNumber]
  ,[NumericPrecisionNumber]
  ,[SourceSystemTypeName]
  ,IIF(TargetColumns.ColumnName IS NULL,0,1) AS TableHasColumnFilerFlag
  ,IIF(TargetColumns2.ColumnName IS NULL,0,1) AS ColumnFilerFlag
  ,[OriginalDataTypeName]
  ,[KeySequenceNumber]
  
   FROM 
		meta.ExtractInformationSchemaDefinitions AS MetaData
   INNER JOIN
		meta.TargetObjects
			ON TargetObjects.SourceObjectID = MetaData.SourceObjectID
   LEFT JOIN
		meta.SourceColumns AS TargetColumns
			ON TargetObjects.SourceObjectID = TargetColumns.SourceObjectID
   LEFT JOIN
		meta.SourceColumns AS TargetColumns2
			ON MetaData.ColumnName = TargetColumns2.ColumnName
			AND TargetObjects.SourceObjectID = TargetColumns2.SourceObjectID 
   WHERE TargetObjects.ID = ''' + @TargetObjectID + ''' 
   AND MetaData.ColumnName <> ''DWCreatedDate'')

SELECT   
   SourceConnectionID
  ,[TableName]
  ,[ColumnName]
  ,[SchemaName]
  ,ROW_NUMBER() OVER (PARTITION BY SourceConnectionID,TableName ORDER BY [OrdinalPositionNumber]) AS [OrdinalPositionNumber]
  ,[DataTypeName]
  ,[MaximumLenghtNumber]
  ,[NumericPrecisionNumber]
  ,[SourceSystemTypeName]
  ,[OriginalDataTypeName]
  ,[KeySequenceNumber]
FROM SourceData
WHERE TableHasColumnFilerFlag = ColumnFilerFlag
GROUP BY SourceConnectionID
  ,[TableName]
  ,[ColumnName]
  ,[SchemaName]
  ,[DataTypeName]
  ,[MaximumLenghtNumber]
  ,[NumericPrecisionNumber]
  ,[SourceSystemTypeName]
  ,[OrdinalPositionNumber]
  ,[OriginalDataTypeName]
  ,[KeySequenceNumber]')


INSERT @Schemas EXEC('SELECT SourceConnectionID, SchemaName, ExtractSchemaName,ROW_NUMBER() OVER (ORDER BY ExtractSchemaName)
FROM 
	meta.ExtractInformationSchemaDefinitions AS MetaData
INNER JOIN
	meta.TargetObjects
		ON TargetObjects.SourceObjectID = MetaData.SourceObjectID
WHERE
	TargetObjects.ID = ''' + @TargetObjectID + '''
GROUP BY SourceConnectionID,ExtractSchemaName,SchemaName')

/**********************************************************************************************************************************************************************
6. Create Loop counter variables
**********************************************************************************************************************************************************************/
DECLARE @Counter INT
DECLARE @MaxColumns INT 
DECLARE @InnerCounter INT
DECLARE @MaxSchemas INT

SELECT 
@Counter = 1
   ,@InnerCounter = 1
   ,@MaxColumns = (SELECT MAX(OrdinalPosition) FROM @InformationSchema)
   ,@MaxSchemas = (SELECT MAX(OrdinalPosition) FROM @Schemas)


/**********************************************************************************************************************************************************************
7. Create loop
**********************************************************************************************************************************************************************/
DECLARE @SourceTable NVARCHAR(MAX)
DECLARE @PlaceholderColumns NVARCHAR(MAX)
DECLARE @Columns NVARCHAR(MAX)
DECLARE @TableScript NVARCHAR(MAX)
DECLARE @Schema NVARCHAR(MAX)
DECLARE @ExtractSchema NVARCHAR(MAX)
DECLARE @ConnectionID INT
DECLARE @NavisionFlag BIT
DECLARE @RemoveBrackets BIT
DECLARE @OracleFlag BIT
DECLARE @MySQLFlag BIT
DECLARE @SQLScript NVARCHAR(MAX)
DECLARE @SQLDummyScript NVARCHAR(MAX)
DECLARE @KeyColumn NVARCHAR(MAX) = (SELECT '[' + ColumnName + ']' FROM @InformationSchema WHERE KeySequence = 1)


WHILE @Counter <= @MaxSchemas

BEGIN

SELECT 
@Schema = ISNULL(SchemaName,''),
@ExtractSchema = ExtractSchemaName,
@ConnectionID = SourceConnectionID
FROM @Schemas
WHERE @Counter = OrdinalPosition 

SET @NavisionFlag = (SELECT NavisionFlag FROM meta.SourceConnections WHERE ID = @ConnectionID)
SET @RemoveBrackets = (SELECT RemoveBracketsFlag FROM meta.SourceConnections WHERE ID = @ConnectionID)
SET @OracleFlag = IIF((SELECT ConnectionType FROM meta.SourceConnections WHERE ID = @ConnectionID) = 'Oracle',1,0)
SET @MySQLFlag = IIF((SELECT ConnectionType FROM meta.SourceConnections WHERE ID = @ConnectionID) = 'MySQL',1,0)

/**********************************************************************************************************************************************************************
8. Create inner loop
**********************************************************************************************************************************************************************/


WHILE @InnerCounter <= @MaxColumns

BEGIN

	SELECT 
	@PlaceholderColumns = IIF(@InnerCounter = 1,'',',') 
													+ CASE 
														WHEN NumericPrecisionNumber > 36 THEN 'CAST([' + ColumnName + '] AS DECIMAL(36,12)) AS [' + ColumnName + ']'
														WHEN @MySQLFlag = 1 AND OriginalDataType = 'TIME' THEN 'CAST(' + ColumnName + ' AS CHAR) AS ' + ColumnName 
														WHEN @NavisionFlag = 1 AND ColumnName = 'timestamp' THEN 'CAST([' + ColumnName + '] AS BIGINT) AS [' + ColumnName + ']'
														ELSE '[' + ColumnName + ']'
													  END 
													+ @CRLF				
	FROM @InformationSchema
	WHERE OrdinalPosition = @InnerCounter
	AND SchemaName = @Schema
	AND SourceConnectionID = @ConnectionID

	SET @Columns = CONCAT(@Columns,@PlaceholderColumns)
	SET @PlaceholderColumns = ''

	SET @InnerCounter = @InnerCounter + 1

END

SELECT
	@SQLScript = 'SELECT ' + @Columns + IIF(@NavisionFlag = 1,',''@{item().NavisionCompany}'' AS DWNavisionCompany','') + ' FROM ' + @Schema + IIF(@Schema = '','','.') + '[' + IIF(@NavisionFlag = 1,'@{item().NavisionCompany}$','') + @Table + ']' + @CRLF + 
																				  CASE 
																					 WHEN ExtractSQLFilter = '' AND IncrementalFlag = 0 AND @Parallelization = 0 THEN ''
																					 WHEN ExtractSQLFilter = '' AND IncrementalFlag = 0 AND @Parallelization = 1 AND @TargetFileFlag = 1 THEN ''
																					 WHEN ExtractSQLFilter = '' AND IncrementalFlag = 0 AND @Parallelization = 1 AND @TargetFileFlag = 0 THEN 'WHERE ' + CASE WHEN @Partition = 0 OR (@Partition = 1 AND @UseModulusFlag = 1) THEN CASE
																																																																						WHEN @OracleFlag = 1 THEN 'MOD(' + @KeyColumn + ',' + @DefaultMaxDop + ') = ''@{item().RowN}'''
																																																																						ELSE @KeyColumn + ' % ' + @DefaultMaxDop + ' = ''@{item().RowN}'''
																																																																				   END
																																																			  WHEN @Partition = 1 AND @UseModulusFlag = 0 THEN '@{item().PartitionDefinition} >= ''@{item().PartitionLowerBound}'' AND @{item().PartitionDefinition} <= ''@{item().PartitionUpperBound}'''
																																																		 END
																					 WHEN ExtractSQLFilter = '' AND IncrementalFlag = 1 AND @Parallelization = 0 THEN ' WHERE ' + IncrementalValueColumnDefinition + ' > ' +   CASE
																																																		WHEN IncrementalFlag = 1 AND @OracleFlag = 1 AND IsDateFlag = 1 THEN 'TO_DATE(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'',''YYYYMMDDHH24MISS'')'
																																																		WHEN IncrementalFlag = 1 AND @OracleFlag = 0 AND ExtractPattern IN ('Standard','Navision','Replacement') AND IsDateFlag = 1 THEN 'convert(datetime, stuff(stuff(stuff(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'', 9, 0, '' ''), 12, 0, '':''), 15, 0, '':''))'
																																																		ELSE '''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'''
																																																	END
																					 WHEN ExtractSQLFilter = '' AND IncrementalFlag = 1 AND @Parallelization = 1 AND @TargetFileFlag = 0  THEN ' WHERE ' + IncrementalValueColumnDefinition + ' > ' +   CASE
																																																									WHEN IncrementalFlag = 1 AND @OracleFlag = 1 AND IsDateFlag = 1 THEN 'TO_DATE(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'',''YYYYMMDDHH24MISS'')'
																																																									WHEN IncrementalFlag = 1 AND @OracleFlag = 0 AND ExtractPattern IN ('Standard','Navision','Replacement') AND IsDateFlag = 1 THEN 'convert(datetime, stuff(stuff(stuff(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'', 9, 0, '' ''), 12, 0, '':''), 15, 0, '':''))'
																																																									ELSE '@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'
																																																								END  + CASE WHEN @Partition = 0 OR (@Partition = 1 AND @UseModulusFlag = 1) THEN CASE
																																																																														WHEN @OracleFlag = 1 THEN 'AND MOD(' + @KeyColumn + ',' + @DefaultMaxDop + ') = ''@{item().RowN}'''
																																																																														ELSE 'AND ' + @KeyColumn + ' % ' + @DefaultMaxDop + ' = ''@{item().RowN}'''
																																																																												   END
																																																											WHEN @Partition = 1 AND @UseModulusFlag = 0 THEN '@{item().PartitionDefinition} >= ''@{item().PartitionLowerBound}'' AND @{item().PartitionDefinition} <= ''@{item().PartitionUpperBound}'''
																																																									   END
																					 WHEN ExtractSQLFilter <> '' AND IncrementalFlag = 0 AND @Parallelization = 0 THEN 'WHERE ' + ExtractSQLFilter 
																					 WHEN ExtractSQLFilter <> '' AND IncrementalFlag = 0 AND @Parallelization = 1 AND @TargetFileFlag = 0  THEN 'WHERE ' + ExtractSQLFilter +  CASE WHEN @Partition = 0 OR (@Partition = 1 AND @UseModulusFlag = 1) THEN CASE
																																																																					WHEN @OracleFlag = 1 THEN 'AND MOD(' + @KeyColumn + ',' + @DefaultMaxDop + ') = ''@{item().RowN}'''
																																																																					ELSE 'AND ' + @KeyColumn + ' % ' + @DefaultMaxDop + ' = ''@{item().RowN}'''
																																																																				END
																																																		   WHEN @Partition = 1 AND @UseModulusFlag = 0 THEN '@{item().PartitionDefinition} >= ''@{item().PartitionLowerBound}'' AND @{item().PartitionDefinition} <= ''@{item().PartitionUpperBound}'''
																																																	  END
																					 WHEN ExtractSQLFilter <> '' AND IncrementalFlag = 1 AND @Parallelization = 0 THEN 'WHERE ' + ExtractSQLFilter + ' AND ' + IncrementalValueColumnDefinition + ' > ' +      CASE
																																																																	WHEN IncrementalFlag = 1 AND @OracleFlag = 1 AND IsDateFlag = 1 THEN 'TO_DATE(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'',''YYYYMMDDHH24MISS'')'
																																																																	WHEN IncrementalFlag = 1 AND @OracleFlag = 0 AND ExtractPattern IN ('Standard','Navision','Replacement') AND IsDateFlag = 1 THEN 'convert(datetime, stuff(stuff(stuff(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'', 9, 0, '' ''), 12, 0, '':''), 15, 0, '':''))'
																																																																	ELSE '@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'
																																																																END
																					 WHEN ExtractSQLFilter <> '' AND IncrementalFlag = 1 AND @Parallelization = 1 AND @TargetFileFlag = 0  THEN 'WHERE ' + ExtractSQLFilter + ' AND ' + IncrementalValueColumnDefinition + ' > ' +      CASE
																																																																	WHEN IncrementalFlag = 1 AND @OracleFlag = 1 AND IsDateFlag = 1 THEN 'TO_DATE(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'',''YYYYMMDDHH24MISS'')'
																																																																	WHEN IncrementalFlag = 1 AND @OracleFlag = 0 AND ExtractPattern IN ('Standard','Navision','Replacement') AND IsDateFlag = 1 THEN 'convert(datetime, stuff(stuff(stuff(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'', 9, 0, '' ''), 12, 0, '':''), 15, 0, '':''))'
																																																																	ELSE '@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'
																																																																END + CASE WHEN @Partition = 0 OR (@Partition = 1 AND @UseModulusFlag = 1) THEN CASE
																																																																																					WHEN @OracleFlag = 1 THEN 'AND MOD(' + @KeyColumn + ',' + @DefaultMaxDop + ') = ''@{item().RowN}'''
																																																																																					ELSE 'AND ' + @KeyColumn + ' % ' + @DefaultMaxDop + ' = ''@{item().RowN}'''
																																																																																				END
																																																																		   WHEN @Partition = 1 AND @UseModulusFlag = 0 THEN '@{item().PartitionDefinition} >= ''@{item().PartitionLowerBound}'' AND @{item().PartitionDefinition} <= ''@{item().PartitionUpperBound}'''
																					ELSE ''																																												  END
																				  END + @CRLF
	,@SQLDummyScript = 'SELECT ' + @Columns + ' FROM ' + @Schema + IIF(@Schema = '','','.') + '[' + IIF(@NavisionFlag = 1,'@{item().NavisionCompany}$','') + @Table + '] WHERE 1 = 2'
																																												 
FROM meta.TargetObjects		
LEFT JOIN
	meta.SourceObjectIncrementalSetup AS TargetObjectIncrementalSetup
		ON TargetObjectIncrementalSetup.SourceObjectID = TargetObjects.SourceObjectID
WHERE 
	TargetObjects.ID = @TargetObjectID


/**********************************************************************************************************************************************************************
8. Update FrameworkMetaDate
**********************************************************************************************************************************************************************/
IF @PrintSQL = 0
	BEGIN
		UPDATE FrameworkMetaData
		SET SQLScript = IIF(@RemoveBrackets = 1 OR @OracleFlag = 1 OR @MySQLFlag = 1,REPLACE(REPLACE(@SQLScript,'[',''),']',''),@SQLScript),
			AzureDWSQLScript = IIF(@RemoveBrackets = 1 OR @OracleFlag = 1 OR @MySQLFlag = 1,REPLACE(REPLACE(@SQLDummyScript,'[',''),']',''),@SQLDummyScript)
		FROM meta.FrameworkMetaData
		WHERE TargetObjectID = @TargetObjectID
	END
ELSE
	BEGIN
		PRINT(IIF(@RemoveBrackets = 1 OR @OracleFlag = 1 OR @MySQLFlag = 1,REPLACE(REPLACE(LEFT(@SQLScript,4000),'[',''),']',''),LEFT(@SQLScript,4000)))
		PRINT(IIF(@RemoveBrackets = 1 OR @OracleFlag = 1 OR @MySQLFlag = 1,REPLACE(REPLACE(SUBSTRING(@SQLScript,4001,4000),'[',''),']',''),SUBSTRING(@SQLScript,4001,4000)))
		PRINT(IIF(@RemoveBrackets = 1 OR @OracleFlag = 1 OR @MySQLFlag = 1,REPLACE(REPLACE(SUBSTRING(@SQLScript,8001,4000),'[',''),']',''),SUBSTRING(@SQLScript,8001,4000)))
		PRINT(IIF(@RemoveBrackets = 1 OR @OracleFlag = 1 OR @MySQLFlag = 1,REPLACE(REPLACE(LEFT(@SQLDummyScript,4000),'[',''),']',''),LEFT(@SQLDummyScript,4000)))
		PRINT(IIF(@RemoveBrackets = 1 OR @OracleFlag = 1 OR @MySQLFlag = 1,REPLACE(REPLACE(SUBSTRING(@SQLDummyScript,4001,4000),'[',''),']',''),SUBSTRING(@SQLDummyScript,4001,4000)))
		PRINT(IIF(@RemoveBrackets = 1 OR @OracleFlag = 1 OR @MySQLFlag = 1,REPLACE(REPLACE(SUBSTRING(@SQLDummyScript,8001,4000),'[',''),']',''),SUBSTRING(@SQLDummyScript,8001,4000)))
	END

SET @InnerCounter = 1

SET @Schema = ''

SET @ExtractSchema = ''

SET @Columns = ''

SET @Counter = @Counter + 1

END

DELETE FROM @InformationSchema
DELETE FROM @Schemas


SET @Table = ''

SET @OuterCounter = @OuterCounter + 1

END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[MaintainTargetCreateTableScript]...';


GO



/**********************************************************************************************************************************************************************
The purpose of this scripts is to create the create table script for extract tables
***********************************************************************************************************************************************************************/



CREATE PROCEDURE [meta].[MaintainTargetCreateTableScript] 

@TargetObjectID INT,
@PrintSQL BIT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/
DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10)
DECLARE @DatabaseNameExtract NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameExtract')
DECLARE @ExtractCCIFlag NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'ExtractCCIFlag')
DECLARE @ExtractCCIHistoryFlag NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'ExtractCCIHistoryFlag')
DECLARE @EnterpriseEditionFlag NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'EnterpriseEditionFlag')
DECLARE @SeparateHistoryFlag NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'SeparateHistoryLayerFlag')


/**********************************************************************************************************************************************************************
1. Update FrameworkMetaData table with IDs
***********************************************************************************************************************************************************************/
INSERT INTO meta.FrameworkMetaData
(TargetObjectID)

SELECT 
	TargetObjects.ID 
FROM 
	meta.TargetObjects 
LEFT JOIN 
	meta.FrameworkMetaData 
		ON FrameworkMetaData.TargetObjectID = TargetObjects.ID 
WHERE 
	FrameworkMetaData.BusinessMatrixID IS NULL
	AND FrameworkMetaData.SourceObjectID IS NULL
	AND	FrameworkMetaData.TargetObjectID IS NULL
	AND TargetObjects.ID  = @TargetObjectID

DELETE FROM meta.FrameworkMetaData WHERE TargetObjectID NOT IN (SELECT ID FROM meta.TargetObjects) AND TargetObjectID IS NOT NULL;

/**********************************************************************************************************************************************************************
2. Create and insert data into table variables
**********************************************************************************************************************************************************************/
DECLARE @InformationSchemaTables TABLE (TargetObjectID INT, SchemaName NVARCHAR(128), ObjectName NVARCHAR(128), FileSystemName NVARCHAR(128),TargetConnectionName NVARCHAR(128), FolderName NVARCHAR(128), FileFormat NVARCHAR(128), FileExtension NVARCHAR(128), TargetAzureSqlDWFlag BIT, NavisionFlag BIT, OrdinalPosition INT)
INSERT @InformationSchemaTables SELECT TargetObjectID,TargetExtractSchemaName, SourceObjectName, TargetFileSystemName, TargetConnectionName, TargetFolderName, TargetAzureFileTypeName, TargetFileExtension, TargetAzureSqlDWFlag, SourceNavisionFlag, ROW_NUMBER() OVER ( ORDER BY TargetObjectID) FROM meta.TargetObjectDefinitions WHERE TargetObjectID = @TargetObjectID GROUP BY TargetObjectID,TargetExtractSchemaName, SourceObjectName,TargetFileSystemName,TargetConnectionName,TargetFolderName,TargetAzureFileTypeName,TargetAzureSqlDWFlag,SourceNavisionFlag,TargetFileExtension

/**********************************************************************************************************************************************************************
3. Create Loop counter variables
**********************************************************************************************************************************************************************/
DECLARE @OuterCounter INT = 1
DECLARE @MaxTable INT = (SELECT MAX(OrdinalPosition) FROM @InformationSchemaTables)


/**********************************************************************************************************************************************************************
4. Create outer loop
**********************************************************************************************************************************************************************/
DECLARE @Table NVARCHAR(100)
DECLARE @ExtractSchema NVARCHAR(100)
DECLARE @NavisionFlag BIT
DECLARE @AzureSQLDWFlag BIT
DECLARE @FileName NVARCHAR(128)
DECLARE @FileFormat NVARCHAR(128)
DECLARE @FileSystem NVARCHAR(128)
DECLARE @TargetConnectionName NVARCHAR(128)

WHILE @OuterCounter <= @MaxTable

BEGIN

	SELECT
	  @TargetObjectID = TargetObjectID
	 ,@Table = ObjectName
	 ,@ExtractSchema = SchemaName
	 ,@NavisionFlag = NavisionFlag
	 ,@AzureSQLDWFlag = TargetAzureSqlDWFlag
	 ,@FileName = IIF(FolderName = '','/','/' + FolderName +'/') + ObjectName + '.' + FileExtension
	 ,@FileFormat = FileFormat
	 ,@TargetConnectionName = TargetConnectionName
	 ,@FileSystem = FileSystemName
	FROM 
		@InformationSchemaTables
	WHERE 
		@OuterCounter = OrdinalPosition


/**********************************************************************************************************************************************************************
5. Create and insert data into table variables
**********************************************************************************************************************************************************************/
DECLARE @InformationSchema TABLE (SourceConnectionID INT, TableName NVARCHAR(128),ColumnName NVARCHAR(128), SchemaName NVARCHAR(128), OrdinalPosition INT,DataType NVARCHAR(128), CharacterMaximumLength NVARCHAR(128), NumericPrecisionNumber INT ,SourceSystem NVARCHAR(128), OriginalDataType NVARCHAR(128), KeySequence INT, HistoryFlag BIT)


INSERT @InformationSchema EXEC('WITH SourceData AS 
(SELECT 
   SourceConnectionID
  ,[TableName]
  ,MetaData.[ColumnName]
  ,[SchemaName]
  ,[OrdinalPositionNumber]
  ,[FullDataTypeName]
  ,[MaximumLenghtNumber]
  ,[NumericPrecisionNumber]
  ,[SourceSystemTypeName]
  ,IIF(TargetColumns.ColumnName IS NULL,0,1) AS TableHasColumnFilerFlag
  ,IIF(TargetColumns2.ColumnName IS NULL,0,1) AS ColumnFilerFlag
  ,[OriginalDataTypeName]
  ,[KeySequenceNumber]
  ,IncrementalFlag  
   FROM 
		meta.ExtractInformationSchemaDefinitions AS MetaData
   INNER JOIN
		meta.TargetObjects
			ON TargetObjects.SourceObjectID = MetaData.SourceObjectID
   LEFT JOIN
		meta.SourceColumns AS TargetColumns
			ON TargetObjects.SourceObjectID = TargetColumns.SourceObjectID
   LEFT JOIN
		meta.SourceColumns AS TargetColumns2
			ON MetaData.ColumnName = TargetColumns2.ColumnName
			AND TargetObjects.SourceObjectID = TargetColumns2.SourceObjectID 
   WHERE TargetObjects.ID = ''' + @TargetObjectID + ''' 
   AND MetaData.ColumnName <> ''DWCreatedDate'')

SELECT   
   SourceConnectionID
  ,[TableName]
  ,[ColumnName]
  ,[SchemaName]
  ,ROW_NUMBER() OVER (PARTITION BY SourceConnectionID,TableName ORDER BY [OrdinalPositionNumber]) AS [OrdinalPositionNumber]
  ,[FullDataTypeName]
  ,[MaximumLenghtNumber]
  ,[NumericPrecisionNumber]
  ,[SourceSystemTypeName]
  ,[OriginalDataTypeName]
  ,[KeySequenceNumber]
  ,IncrementalFlag
FROM SourceData
WHERE TableHasColumnFilerFlag = ColumnFilerFlag
GROUP BY SourceConnectionID
  ,[TableName]
  ,[ColumnName]
  ,[SchemaName]
  ,[FullDataTypeName]
  ,[MaximumLenghtNumber]
  ,[NumericPrecisionNumber]
  ,[SourceSystemTypeName]
  ,[OrdinalPositionNumber]
  ,[OriginalDataTypeName]
  ,[KeySequenceNumber]
  ,IncrementalFlag')



/**********************************************************************************************************************************************************************
2. Create Loop counter variables
**********************************************************************************************************************************************************************/
DECLARE @Counter INT
DECLARE @MaxColumns INT 

SELECT 
		@Counter = 1
	   ,@MaxColumns = (SELECT MAX(OrdinalPosition) FROM @InformationSchema)


/**********************************************************************************************************************************************************************
3. Create Table SQL
**********************************************************************************************************************************************************************/
DECLARE @PlaceholderColumns NVARCHAR(MAX)
DECLARE @Columns NVARCHAR(MAX)
DECLARE @TableScript NVARCHAR(MAX)
DECLARE @PlaceholderPrimaryKeyColumns NVARCHAR(MAX)
DECLARE @PrimaryKeyColumns NVARCHAR(MAX)
DECLARE @HistoryFlag INT
DECLARE @SQLScriptDrop NVARCHAR(MAX)
DECLARE @SQLScriptCreate NVARCHAR(MAX)
DECLARE @ClusteredColumnStoreIndexScript NVARCHAR(MAX)
DECLARE @ClusteredColumnStoreIndexScriptHistory NVARCHAR(MAX)
DECLARE @HistoryTable NVARCHAR(100) = IIF(@SeparateHistoryFlag = 1,@Table,@Table + '_History')
DECLARE @HistorySchema NVARCHAR(50) = IIF(@SeparateHistoryFlag = 1,@ExtractSchema + 'History',@ExtractSchema)
DECLARE @SQL NVARCHAR(MAX)

WHILE @Counter <= @MaxColumns

	BEGIN

			SELECT 
				 @PlaceholderColumns = IIF(@Counter = 1,'',',') + '[' + ColumnName + '] ' + CASE 
																								WHEN @AzureSQLDWFlag = 1 AND @FileFormat = 'DelimitedText' AND DataType <> 'varbinary' THEN 'NVARCHAR(500)'
																								WHEN @AzureSQLDWFlag = 1 AND @FileFormat = 'DelimitedText' AND DataType = 'varbinary' THEN 'NVARCHAR(MAX)'
																								WHEN @AzureSQLDWFlag = 1 AND @FileFormat <> 'DelimitedText' AND DataType = 'varbinary' THEN 'VARBINARY(MAX)'
																								WHEN @AzureSQLDWFlag = 1 AND DataType = 'UNIQUEIDENTIFIER' THEN 'NVARCHAR (128)'
																								ELSE DataType
																							END + ' NULL' + @CRLF 

			FROM @InformationSchema
			WHERE OrdinalPosition = @Counter


			SELECT 
				@PlaceholderPrimaryKeyColumns = IIF(KeySequence = 1,'',IIF(KeySequence IS NULL,'',',')) + IIF(KeySequence IS NULL,'','[' + ColumnName + ']')
			FROM @InformationSchema
			WHERE KeySequence = @Counter
			AND KeySequence IS NOT NULL
			ORDER BY KeySequence



		SET @Columns = CONCAT(@Columns,@PlaceholderColumns)

		SET @PrimaryKeyColumns = CONCAT(@PrimaryKeyColumns,@PlaceholderPrimaryKeyColumns)

		SET @PlaceholderColumns = ''

		SET @PlaceholderPrimaryKeyColumns = ''

		SET @Counter = @Counter + 1


	END

	SET @HistoryFlag = (SELECT DISTINCT HistoryFlag FROM @InformationSchema)
 
	SET @SQLScriptDrop =
	'
	IF object_id(''[' + @ExtractSchema + '].[' + @Table + ']'') IS NOT NULL
	BEGIN
		DROP ' + IIF(@AzureSQLDWFlag = 1,'EXTERNAL ','') + 'TABLE ['+ @ExtractSchema + '].[' + @Table + ']
	END '

	SET @SQLScriptCreate = 
	'BEGIN 
		CREATE ' + IIF(@AzureSQLDWFlag = 1,'EXTERNAL ','') + 'TABLE ['+ @ExtractSchema + '].[' + @Table + ']' + @CRLF + '(' + @Columns + IIF(@NavisionFlag = 1,',DWNavisionCompany NVARCHAR(50)','') + @CRLF +
	CASE 
		WHEN @PrimaryKeyColumns <> '' AND @AzureSQLDWFlag = 0 THEN 'CONSTRAINT [PK_' + @Table + '] PRIMARY KEY NONCLUSTERED (' + @PrimaryKeyColumns + IIF(@NavisionFlag = 1,',DWNavisionCompany','') + ') NOT ENFORCED) ' 
		WHEN @AzureSQLDWFlag = 1 THEN ') WITH (
												LOCATION=''' + @FileName + ''',
												DATA_SOURCE = ' + @TargetConnectionName + @FileSystem + ',
												FILE_FORMAT = ' + @FileFormat + 'Format
											)'
		ELSE ''
	END + @CRLF + 'END'
	+ @CRLF + @CRLF +
	IIF( @HistoryFlag= 1,
	'IF object_id(''[' + @HistorySchema + '].[' + @HistoryTable + ']'') IS NOT NULL
	BEGIN
		DROP TABLE ['+ @HistorySchema + '].[' + @HistoryTable + ']
	END
	BEGIN
	CREATE TABLE ['+ @HistorySchema + '].[' + @HistoryTable + ']' + @CRLF + '(' + @Columns +'
	,[DWIsCurrent] BIT
	,[DWValidFromDate] DATETIME
	,[DWValidToDate] DATETIME
	,[DWCreatedDate] DATETIME
	,[DWModifiedDate] DATETIME
	,[DWIsDeletedInSource] BIT
	,[DWDeletedInSourceDate] DATETIME' + IIF(@NavisionFlag = 1,',DWNavisionCompany NVARCHAR(50)','') + @CRLF +
	IIF(@PrimaryKeyColumns <> '' AND @AzureSQLDWFlag = 0,'CONSTRAINT [PK_' + @Table + '_History] PRIMARY KEY NONCLUSTERED (' + @PrimaryKeyColumns + ',DWValidFromDate' + IIF(@NavisionFlag = 1,',DWNavisionCompany','') + '))' + 'END',') END'),'')

	SET @ClusteredColumnStoreIndexScript =  'IF NOT EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id(''' + @ExtractSchema + '.' + @Table + ''') AND NAME = ''CCI_'+ @Table + ''')' + @CRLF +
																							'BEGIN CREATE CLUSTERED COLUMNSTORE INDEX [CCI_' + @Table + '] ON ' + @ExtractSchema + '.[' + @Table + '] WITH (DROP_EXISTING = OFF, COMPRESSION_DELAY = 0)
																							END'

	SET @ClusteredColumnStoreIndexScriptHistory =  'IF NOT EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id(''' + @HistorySchema + '.' + @HistoryTable + ''') AND NAME = ''CCI_'+ @Table + '_History'')' + @CRLF +
																							'BEGIN CREATE CLUSTERED COLUMNSTORE INDEX [CCI_' + @Table + '_History] ON ' + @HistorySchema + '.[' + @HistoryTable + '] WITH (DROP_EXISTING = OFF, COMPRESSION_DELAY = 0)
																							END'

	SET @SQL = CONCAT(@SQLScriptCreate,IIF(@ExtractCCIFlag = 1 AND @EnterpriseEditionFlag = 1 AND @AzureSQLDWFlag = 0,@ClusteredColumnStoreIndexScript,IIF(@HistoryFlag = 1 AND @ExtractCCIHistoryFlag = 1 AND @EnterpriseEditionFlag = 1 AND @AzureSQLDWFlag = 0,@ClusteredColumnStoreIndexScriptHistory,'')))
	
	IF @PrintSQL = 0
		BEGIN
			UPDATE meta.FrameworkMetaData
			SET CreateTableSQLScript = @SQL,
				DropTableSQLScript = @SQLScriptDrop
			WHERE
				TargetObjectID = @TargetObjectID
		END
	ELSE
		BEGIN
			PRINT(@SQL)
			PRINT(@SQLScriptDrop)
		END

	SET @PrimaryKeyColumns = ''

	SET @ExtractSchema = ''

	SET @Columns = ''

	SET @OuterCounter = @OuterCounter + 1

	DELETE FROM @InformationSchema

END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[ReplaceSourceObjectHistory]...';


GO
CREATE PROCEDURE [meta].[ReplaceSourceObjectHistory] 

 @ExtractTable  NVARCHAR(200),--Input is the extract table with schema
 @PrintSQL BIT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/

DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10) 
DECLARE @TableSchema NVARCHAR(100) = LEFT(@ExtractTable,CHARINDEX('.',@ExtractTable,0)-1)
DECLARE @Table NVARCHAR(100) = REPLACE(REPLACE(REPLACE(@ExtractTable,CONCAT(@TableSchema,'.'),''),'[',''),']','')
DECLARE @DatabaseNameExtract NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameExtract')
DECLARE @DatabaseNameMeta NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameMeta')
DECLARE @DatabaseNameHistory NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameHistory')
DECLARE @IsCloudFlag NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'IsCloudFlag')
DECLARE @SeparateHistoryFlag NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'SeparateHistoryLayerFlag')
DECLARE @HistoryTable NVARCHAR(100) = IIF(@SeparateHistoryFlag = 1 AND @IsCloudFlag = 1,@Table,@Table + '_History')
DECLARE @HistorySchema NVARCHAR(50) = IIF(@SeparateHistoryFlag = 1 AND @IsCloudFlag = 1,@TableSchema + '_history',@TableSchema)
DECLARE @DatabaseCollation NVARCHAR(100) = (SELECT CONVERT (varchar, DATABASEPROPERTYEX('' + @DatabaseNameMeta + '','collation')))

/**********************************************************************************************************************************************************************
1. Create and insert data into table variables
**********************************************************************************************************************************************************************/

DECLARE @InformationSchema TABLE (DatabaseName NVARCHAR(128), TableName NVARCHAR(128), ColumnName NVARCHAR(128), OrdinalPosition INT, PrimaryKey INT)
DECLARE @ColumnDefaults TABLE (DataType NVARCHAR(50),DefaultValue NVARCHAR(250))

/*Generates the combined information schema*/
INSERT @InformationSchema EXEC('SELECT ''Extract'' AS DATABASE_NAME
										,COLUMNS.TABLE_NAME
										,COLUMNS.COLUMN_NAME
										,COLUMNS.ORDINAL_POSITION
										,CASE WHEN KEY_COLUMN_USAGE.COLUMN_NAME IS NULL THEN 0 
											  ELSE 1 
									     END AS PRIMARY_KEY
								FROM 
									[' + @DatabaseNameExtract + '].INFORMATION_SCHEMA.COLUMNS
								LEFT JOIN 
									[' + @DatabaseNameExtract + '].INFORMATION_SCHEMA.KEY_COLUMN_USAGE
										ON COLUMNS.TABLE_NAME = KEY_COLUMN_USAGE.TABLE_NAME 
										AND COLUMNS.COLUMN_NAME = KEY_COLUMN_USAGE.COLUMN_NAME
										AND COLUMNS.TABLE_SCHEMA = KEY_COLUMN_USAGE.TABLE_SCHEMA
								WHERE 
									COLUMNS.TABLE_NAME = ''' + @Table + ''' 
									AND (COLUMNS.COLUMN_NAME NOT LIKE ''DW%'' 
									OR COLUMNS.COLUMN_NAME = ''DWNavisionCompany'')
									AND COLUMNS.TABLE_SCHEMA NOT LIKE ''%View%''
									AND COLUMNS.TABLE_SCHEMA = ''' + @TableSchema + '''
						

								UNION ALL

								SELECT ''History'' AS DATABASE_NAME
										,COLUMNS.TABLE_NAME
										,COLUMNS.COLUMN_NAME
										,COLUMNS.ORDINAL_POSITION
										,CASE WHEN KEY_COLUMN_USAGE.COLUMN_NAME IS NULL THEN 0 
											  ELSE 1 
										 END AS PRIMARY_KEY
								FROM 
									[' + @DatabaseNameExtract + '].INFORMATION_SCHEMA.COLUMNS
								LEFT JOIN 
									[' + @DatabaseNameExtract + '].INFORMATION_SCHEMA.KEY_COLUMN_USAGE
										ON COLUMNS.TABLE_NAME = KEY_COLUMN_USAGE.TABLE_NAME 
										AND COLUMNS.COLUMN_NAME = KEY_COLUMN_USAGE.COLUMN_NAME
										AND COLUMNS.TABLE_SCHEMA = KEY_COLUMN_USAGE.TABLE_SCHEMA
								WHERE 
									COLUMNS.TABLE_NAME = ''' + @Table + ''' + ''_History''
									AND (COLUMNS.COLUMN_NAME NOT LIKE ''DW%'' 
									OR COLUMNS.COLUMN_NAME = ''DWNavisionCompany'')
									AND COLUMNS.TABLE_SCHEMA = ''' + @TableSchema + '''')



/**********************************************************************************************************************************************************************
2. Create Loop counter and support variables
**********************************************************************************************************************************************************************/

DECLARE @ColumnsExtract INT --Number of columns from Extract
DECLARE @ColumnsHistory INT --Number of columns from History
DECLARE @Counter INT --Just a counter
DECLARE @ColumnsID INT --Number of key columns



SELECT 
	@ColumnsExtract = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE DatabaseName = 'Extract'),
	@Counter = 1,
	@ColumnsID = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE PrimaryKey = 1 AND DatabaseName = 'Extract'),
	@ColumnsHistory = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE DatabaseName = 'History')


/**********************************************************************************************************************************************************************
4. Create columns from extract and output column part
**********************************************************************************************************************************************************************/

DECLARE @PlaceholderColumnNameExtract NVARCHAR(MAX) --Placeholder for the columns from Extract
DECLARE @ColumnNameExtract NVARCHAR(MAX) --Holds the value of @ColumnNameExtract for each loop

WHILE @Counter <= @ColumnsExtract

BEGIN 

	SELECT	@PlaceholderColumnNameExtract = '[' + ColumnName + ']' + CASE 
																		WHEN @Counter != @ColumnsExtract 
																			THEN ',' 
																		ELSE '' 
																	END + @CRLF     
	FROM 
		@InformationSchema
	WHERE 
			DatabaseName = 'Extract' 
		AND TableName = @Table 
		AND OrdinalPosition = @Counter

	SET @ColumnNameExtract = CONCAT(@ColumnNameExtract,@PlaceholderColumnNameExtract)

	SET @PlaceholderColumnNameExtract = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1


/**********************************************************************************************************************************************************************
7. Fill out the dynamic SQL script variables
**********************************************************************************************************************************************************************/

DECLARE @Parameters NVARCHAR(MAX) --Holds the parameter part of the Merge Join Script
DECLARE @ReplacementSQL NVARCHAR(MAX) --Holds the INSERT INTO script

SET @Parameters =
'DECLARE @CurrentDateTime datetime
DECLARE @MinDateTime datetime
DECLARE @MaxDateTime datetime
DECLARE @BooleanTrue bit
DECLARE @BooleanFalse bit
DECLARE @DateToDateTime datetime


SELECT
	@CurrentDateTime = cast(getdate() as datetime),
	@MinDateTime = cast(''1900-01-01'' as datetime),
	@MaxDateTime = cast(''9999-12-31'' as datetime),
	@BooleanTrue = cast(1 as bit),
	@BooleanFalse = cast(0 as bit),
	@DateToDateTime = dateadd(ms,-3,  getdate())
'

SET @ReplacementSQL = @Parameters + @CRLF + @CRLF + 'INSERT INTO  [' + @DatabaseNameHistory + '].[' + @HistorySchema + '].[' + @HistoryTable +'] WITH (TABLOCK)' + @CRLF +
'( ' + + @ColumnNameExtract + 
',[DWIsCurrent]
,[DWValidFromDate]
,[DWValidToDate]
,[DWCreatedDate]
,[DWModifiedDate]
,[DWIsDeletedInSource]
,[DWDeletedInSourceDate]
)

SELECT 
' + @ColumnNameExtract + 
',@BooleanTrue
,@MinDateTime
,@MaxDateTime
,@CurrentDateTime
,@CurrentDateTime
,@BooleanFalse
,@MinDateTime

FROM [' + @DatabaseNameExtract + '].[' + @TableSchema + '].[' + @Table + '] '

/**********************************************************************************************************************************************************************
9. Execute dynamic SQL script variables
**********************************************************************************************************************************************************************/

IF @PrintSQL = 0

	BEGIN
		
		EXEC(@ReplacementSQL)
		
	END

ELSE

	BEGIN		
		
		PRINT(LEFT(@ReplacementSQL,4000)) + @CRLF + @CRLF
		PRINT(SUBSTRING(@ReplacementSQL,4001,8000)) + @CRLF + @CRLF
		PRINT(SUBSTRING(@ReplacementSQL,8001,12000)) + @CRLF + @CRLF
		PRINT(SUBSTRING(@ReplacementSQL,12001,16000)) + @CRLF + @CRLF
		
	END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[ExtractTruncateTable]...';


GO
CREATE PROCEDURE [meta].[ExtractTruncateTable]

 @TableName NVARCHAR(128)
,@ExtractSchemaName NVARCHAR(100)

AS

SET NOCOUNT ON

EXEC('TRUNCATE TABLE [' + @ExtractSchemaName + '].[' + @TableName + ']')

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[FactPatternsReplacement]...';


GO
/**********************************************************************************************************************************************************************
The purpose of this scripts is to insert delta rows in the fact temp table
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[FactPatternsReplacement]

@Table NVARCHAR(128),--Input is the fact name without schema
@DestinationSchema NVARCHAR(128),
@CleanUpPartitionsFlag BIT,
@PrintSQL BIT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/

DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10)
DECLARE @DatabaseNameStage NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameStage')
DECLARE @DatabaseNameDW NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW')
DECLARE @SurrogateKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'SurrogateKeySuffix')
DECLARE @BusinessKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'BusinessKeySuffix')
DECLARE @IsCloudFlag BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'IsCloudFlag')
DECLARE @PrimaryKeys TABLE (TableName NVARCHAR(128), ColumnName NVARCHAR(128))
DECLARE @StageSchemaTable TABLE (SchemaName NVARCHAR(10)) 
INSERT @StageSchemaTable EXEC('SELECT DISTINCT TABLE_SCHEMA FROM [' + @DatabaseNameStage + '].INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''' + @Table + ''' AND TABLE_SCHEMA IN (''dbo'',''stage'')')
DECLARE @StageSchema NVARCHAR(10) = (SELECT IIF(@IsCloudFlag = 1,'stage',(SELECT SchemaName FROM @StageSchemaTable))) --If on-premise and stageschema has not been changed

/**********************************************************************************************************************************************************************
1. Create and insert data into table variables
***********************************************************************************************************************************************************************/

DECLARE @InformationSchema TABLE (DatabaseName NVARCHAR(128),TableName NVARCHAR(128), ColumnName NVARCHAR(128), OrdinalPosition INT, DataType NVARCHAR(128), PrimaryKey INT)
/*Generates the combined information schema*/
INSERT @InformationSchema EXEC('WITH PrimaryKeys AS
								(
								SELECT DISTINCT
										tables.name AS TableName
									   ,all_columns.name AS ColumnName
									FROM
									   [' + @DatabaseNameDW + '].sys.tables
									INNER JOIN 
									   [' + @DatabaseNameDW + '].sys.all_columns 
											ON all_columns.object_id=tables.object_id
									INNER JOIN 
									   [' + @DatabaseNameDW + '].sys.extended_properties
											ON extended_properties.major_id=tables.object_id 
											AND extended_properties.minor_id=all_columns.column_id 
											AND extended_properties.class=1
									WHERE
									   extended_properties.name = ''PrimaryKeyColumn''
									   AND tables.name = ''' + @Table + '''
								)

								SELECT  ''DW''
										,COLUMNS.TABLE_NAME
										,COLUMNS.COLUMN_NAME
										,ROW_NUMBER() OVER (ORDER BY COLUMNS.TABLE_NAME) AS ORDINAL_POSITION
										,COLUMNS.DATA_TYPE
										,CASE WHEN PrimaryKeys.ColumnName IS NULL THEN 0 ELSE 1 END AS PRIMARY_KEY
								FROM 
									[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.COLUMNS
								LEFT JOIN
									PrimaryKeys
										ON PrimaryKeys.ColumnName = COLUMNS.COLUMN_NAME
								WHERE 
									    COLUMNS.TABLE_NAME = ''' + @Table + ''' 
									AND COLUMNS.TABLE_SCHEMA IN (''fact'',''bridge'')
									AND COLUMNS.COLUMN_NAME NOT LIKE ''DW%''
									AND COLUMNS.COLUMN_NAME != ''LastValueLoaded'''
								
								)

/**********************************************************************************************************************************************************************
2. Create Loop counter variables and SCD2FromSource variable
***********************************************************************************************************************************************************************/

DECLARE @Counter INT 
DECLARE @MaxColumns INT  --Number of columns from stage
DECLARE @MaxSCDJoinColumns INT --Max position of composite SCD2 key columns
DECLARE @MaxJoinColumns INT --Max position of key columns from fact/bridge
DECLARE @MaxColumnsKeys INT --Max position of primary key columns i fact/bridge
DECLARE @MaxColumnsFact INT --Number of columns in fact/bridge
DECLARE @MinKeyCounter INT
DECLARE @PrimaryKeyColumn NVARCHAR(500)


SELECT 
	   @Counter = 1
	  ,@MaxColumns = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE DatabaseName = 'DW' )
	  ,@MaxColumnsKeys = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE PrimaryKey = 1 AND DatabaseName = 'DW')
	  ,@MinKeyCounter  = (SELECT MIN(OrdinalPosition) FROM @InformationSchema WHERE PrimaryKey = 1 AND DatabaseName = 'DW')
	  ,@PrimaryKeyColumn = (SELECT TOP 1 ColumnName FROM @InformationSchema WHERE PrimaryKey = 1 AND DatabaseName = 'DW')

/**********************************************************************************************************************************************************************
3. Create the select part 
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderInsertColumns VARCHAR(MAX) = ''
DECLARE @InsertColumns VARCHAR(MAX) = ''
DECLARE @PlaceholderSelectDelta VARCHAR(MAX) = ''
DECLARE @SelectDelta VARCHAR(MAX) = ''

WHILE @Counter <= @MaxColumns

BEGIN

	SELECT @PlaceholderInsertColumns	= IIF(@Counter = 1,'',',') + '[' + InformationSchema.ColumnName + ']' + @CRLF
		  ,@PlaceholderSelectDelta  = IIF(@Counter = 1,'',',') + CASE 
																	WHEN ColumnName NOT LIKE '%ID' AND ColumnName NOT LIKE '%Code' AND ColumnName NOT LIKE '%Flag'AND ColumnName NOT LIKE '%Number' AND Datatype IN ('Decimal','Numeric','int','bigint','float','smallint') THEN '-'
																	ELSE ''
																 END + 'fact.[' + InformationSchema.ColumnName + ']' + @CRLF
	FROM 
		@InformationSchema AS InformationSchema	
	WHERE 
		@Counter = InformationSchema.OrdinalPosition 
		AND InformationSchema.DatabaseName = 'DW'

	SET @InsertColumns = CONCAT(@InsertColumns,@PlaceholderInsertColumns)
	SET @SelectDelta = CONCAT(@SelectDelta,@PlaceholderSelectDelta)

	SET @PlaceholderInsertColumns = ''
	SET @PlaceholderSelectDelta = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1


/**********************************************************************************************************************************************************************
5. Fill out dynamic SQL variables
***********************************************************************************************************************************************************************/
DECLARE @VariablesSQL NVARCHAR(MAX)
DECLARE @WhereSQL NVARCHAR(MAX) 
DECLARE @NewDelta NVARCHAR(MAX)
DECLARE @DeleteFromFact NVARCHAR(MAX) --Holds the SCD1 part of the Merge Join Script
DECLARE @SQL NVARCHAR(MAX)

SET @VariablesSQL = '
DECLARE @MinDate NVARCHAR(50)
DECLARE @MaxDate NVARCHAR(50)

SET @MinDate = (SELECT MIN([' + @PrimaryKeyColumn + ']) FROM [' + @DatabaseNameDW + '].[' + @StageSchema + '].[' + @Table + '])
SET @MaxDate = (SELECT MAX([' + @PrimaryKeyColumn + ']) FROM [' + @DatabaseNameDW + '].[' + @StageSchema + '].[' + @Table + '])' + @CRLF + @CRLF

SET @WhereSQL = 'WHERE [' + @PrimaryKeyColumn + '] >= @MinDate AND [' + @PrimaryKeyColumn + '] <= @MaxDate'

SET @NewDelta = 
'INSERT INTO [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '_Temp] WITH (TABLOCK)
(' + ISNULL(@InsertColumns,'') + ',DWCreatedDate, DWModifiedDate)
 SELECT 
	' + ISNULL(@SelectDelta ,'')
	  + '
	  ,''1900-01-01''
	  ,''1900-01-01''
 FROM [' + @DatabaseNameDW + '].[' + @DestinationSchema +'].['+ @Table + '] AS fact'  + @CRLF + @WhereSQL + @CRLF 


SET @DeleteFromFact = '
DELETE fact WITH (TABLOCK)
FROM
	[' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '] AS fact'  + @CRLF + @WhereSQL


SET @SQL = IIF(@CleanUpPartitionsFlag = 0,CONCAT('BEGIN TRAN ',@VariablesSQL,@NewDelta,@DeleteFromFact,' COMMIT TRAN'),CONCAT('BEGIN TRAN ',@VariablesSQL,@DeleteFromFact,' COMMIT TRAN'))

/**********************************************************************************************************************************************************************
6. Execute dynamic SQL variables
***********************************************************************************************************************************************************************/

IF @PrintSQL = 0

	BEGIN
		
		EXEC(@SQL)

	END

ELSE

	BEGIN

		IF @CleanUpPartitionsFlag = 0

			BEGIN

				PRINT('BEGIN TRAN ') + @CRLF + @CRLF
				PRINT(@VariablesSQL)
				PRINT(@NewDelta) + @CRLF + @CRLF
				PRINT(@DeleteFromFact) + @CRLF + @CRLF
				PRINT(' COMMIT TRAN ') + @CRLF + @CRLF

			END

	    ELSE

			BEGIN
			    PRINT(@VariablesSQL) + @CRLF + @CRLF
				PRINT(@DeleteFromFact)

			END
			
	END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[MaintainExtractCreatePartitionScript]...';


GO


/**********************************************************************************************************************************************************************
The purpose of this scripts is to create the source Partition SQL for extract packages
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[MaintainExtractCreatePartitionScript] 

@SourceObjectID INT,
@PrintSQL BIT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/
DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10)
DECLARE @DatabaseNameExtract NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameExtract')
DECLARE @DefaultMaxDop NVARCHAR(3) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DefaultMaxDop')
	
/**********************************************************************************************************************************************************************
1. Update FrameworkMetaData table with IDs
***********************************************************************************************************************************************************************/
INSERT INTO meta.FrameworkMetaData
(SourceObjectID)

SELECT 
	SourceObjects.ID 
FROM 
	meta.SourceObjects 
LEFT JOIN 
	meta.FrameworkMetaData 
		ON FrameworkMetaData.SourceObjectID = SourceObjects.ID 
WHERE 
	FrameworkMetaData.BusinessMatrixID IS NULL
	AND FrameworkMetaData.SourceObjectID IS NULL
	AND FrameworkMetaData.TargetObjectID IS NULL
	AND SourceObjects.ID = @SourceObjectID

DELETE FROM meta.FrameworkMetaData WHERE SourceObjectID NOT IN (SELECT ID FROM meta.SourceObjects) AND SourceObjectID IS NOT NULL;

/**********************************************************************************************************************************************************************
2. Create and insert data into table variables
**********************************************************************************************************************************************************************/
DECLARE @InformationSchemaTables TABLE (SourceObjectID INT, TableName NVARCHAR(128), ObjectName NVARCHAR(128),OrdinalPosition INT, ParallelizationFlag BIT, PartitionFlag BIT, UseModulusFlag BIT)
INSERT @InformationSchemaTables SELECT SourceObjectID, [Name], [ObjectName], ROW_NUMBER() OVER ( ORDER BY ObjectName), ParallelizationFlag, PartitionFlag, UseModulusFlag FROM meta.SourceObjectDefinitions WHERE SourceObjectID = @SourceObjectID GROUP BY SourceObjectID,Name,ObjectName, ParallelizationFlag, PartitionFlag, UseModulusFlag

/**********************************************************************************************************************************************************************
3. Create Loop counter variables
**********************************************************************************************************************************************************************/
DECLARE @OuterCounter INT = 1
DECLARE @MaxTable INT = (SELECT MAX(OrdinalPosition) FROM @InformationSchemaTables)


/**********************************************************************************************************************************************************************
4. Create outer loop
**********************************************************************************************************************************************************************/
DECLARE @Parallelization BIT
DECLARE @PartitionFlag BIT 
DECLARE @UseModulusFlag BIT




WHILE @OuterCounter <= @MaxTable

BEGIN

	SELECT
	 @PartitionFlag = PartitionFlag
	,@SourceObjectID = SourceObjectID
	,@UseModulusFlag = UseModulusFlag
	FROM 
	@InformationSchemaTables
	WHERE 
	@OuterCounter = OrdinalPosition



/**********************************************************************************************************************************************************************
5. Create and insert data into table variables
**********************************************************************************************************************************************************************/
DECLARE @InformationSchema TABLE (TableName NVARCHAR(128), PartitionDefinition NVARCHAR(max),PartitionLowerBound NVARCHAR(100), PartitionUpperBound NVARCHAR(100), OrdinalPosition INT)

INSERT @InformationSchema 
EXEC('
	SELECT [Name]
		 , REPLACE(SourceObjectPartition.PartitionValueColumnDefinition,'''''''','''''''''''')
		 , PartitionLowerBound
		 , PartitionUpperBound 
		 , ROW_NUMBER() OVER ( ORDER BY ObjectName) 
    FROM 
		meta.SourceObjectDefinitions 
	INNER JOIN 
		meta.SourceObjectPartition 
			ON SourceObjectPartition.SourceObjectID = SourceObjectDefinitions.SourceObjectID 
	WHERE 
		PartitionFlag = 1
		AND SourceObjectDefinitions.SourceObjectID = ' + @SourceObjectID)

/**********************************************************************************************************************************************************************
6. Create Loop counter variables
**********************************************************************************************************************************************************************/
DECLARE @Counter INT
DECLARE @MaxPartitions INT 

SELECT 
	@Counter = 1
   ,@MaxPartitions = (SELECT MAX(OrdinalPosition) FROM @InformationSchema)


/**********************************************************************************************************************************************************************
7. Create loop
**********************************************************************************************************************************************************************/
DECLARE @SQL NVARCHAR(MAX)
DECLARE @PlaceholderSQL NVARCHAR(MAX)
DECLARE @DefaultPartitionSQL NVARCHAR(MAX) = 'WITH Dataset AS (SELECT ROW_NUMBER() OVER ( ORDER BY object_id) AS RowN  FROM sys.all_objects) SELECT 0 AS RowN, ''Dummy'' AS PartitionDefinition, 0 AS PartitionLowerBound, 0 AS PartitionUpperBound  UNION ALL SELECT RowN , ''Dummy'' AS PartitionDefinition, RowN AS PartitionLowerBound, RowN AS PartitionUpperBound FROM Dataset WHERE RowN < (SELECT VariableValue FROM meta.Variables WHERE VariableName = ''DefaultMaxDop'')'

WHILE @Counter <= @MaxPartitions

	BEGIN

		SELECT 
			@PlaceholderSQL = 'SELECT ' + CAST(OrdinalPosition AS NVARCHAR(20)) + ' AS RowN, ''' + PartitionDefinition + ''' AS PartitionDefinition, ' + PartitionLowerBound + ' AS PartitionLowerBound , ' + PartitionUpperBound + ' AS PartitionUpperBound ' + IIF(@Counter = @MaxPartitions,'',' UNION ALL') + @CRLF 
		FROM
			@InformationSchema
		WHERE
			OrdinalPosition = @Counter

		SET @SQL = CONCAT(@SQL,@PlaceholderSQL)

		SET @PlaceholderSQL = ''

		SET @Counter = @Counter + 1

	END


/**********************************************************************************************************************************************************************
8. Update FrameworkMetaDate
**********************************************************************************************************************************************************************/
IF @PrintSQL = 0
	BEGIN
		IF @PartitionFlag = 1 AND @UseModulusFlag = 0
				BEGIN
				   UPDATE meta.FrameworkMetaData
				   SET PartitionSQLScript = @SQL
				   WHERE SourceObjectID = @SourceObjectID
				END
			ELSE
				BEGIN
				   UPDATE meta.FrameworkMetaData
				   SET PartitionSQLScript = @DefaultPartitionSQL
				   WHERE SourceObjectID = @SourceObjectID 
				END
	END
ELSE
	BEGIN
		IF @PartitionFlag = 1 AND @UseModulusFlag = 0
				BEGIN
				  PRINT(@SQL)
				END
			ELSE
				BEGIN
				  PRINT(@DefaultPartitionSQL)
				END
	END

		SET @PlaceholderSQL = ''

		SET @SQL = ''

		SET @Counter = 1


	DELETE FROM @InformationSchema


	SET @PartitionFlag = NULL
	SET @SourceObjectID = NULL
	SET @UseModulusFlag = NULL

	SET @OuterCounter = @OuterCounter + 1

END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[MaintainExtractCreateSchemas]...';


GO

CREATE PROCEDURE [meta].[MaintainExtractCreateSchemas]

@ExtractSchemaName NVARCHAR(100),
@PrintSQL BIT

AS

/**********************************************************************************************************************************************************************
1. Create Schemas
**********************************************************************************************************************************************************************/
DECLARE @ExtractHistorySchemas NVARCHAR(50) = @ExtractSchemaName + '_history'
DECLARE @CreateSchemasSQL NVARCHAR(MAX)
DECLARE @CreateHistorySchemasSQL NVARCHAR(MAX)

SET @CreateSchemasSQL = 'CREATE SCHEMA ' + @ExtractSchemaName
SET @CreateHistorySchemasSQL = 'CREATE SCHEMA ' + @ExtractHistorySchemas

IF @PrintSQL = 0

	BEGIN 
		IF NOT EXISTS (SELECT name FROM sys.schemas WHERE name = @ExtractSchemaName)
			BEGIN 
				EXEC(@CreateSchemasSQL)
			END
		IF NOT EXISTS (SELECT name FROM sys.schemas WHERE name = @ExtractHistorySchemas)
			BEGIN 
				EXEC(@CreateHistorySchemasSQL)
			END
	END
ELSE
	BEGIN
		IF NOT EXISTS (SELECT name FROM sys.schemas WHERE name = @ExtractSchemaName)
			BEGIN 
				PRINT(@CreateSchemasSQL)
			END
		IF NOT EXISTS (SELECT name FROM sys.schemas WHERE name = @ExtractHistorySchemas)
			BEGIN 
				PRINT(@CreateHistorySchemasSQL)
			END
	END
GO
PRINT N'Creating [meta].[MaintainExtractCreateSourceScript]...';


GO


/**********************************************************************************************************************************************************************
The purpose of this scripts is to create the source SQL for extract packages
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[MaintainExtractCreateSourceScript] 

@SourceObjectID INT,
@PrintSQL BIT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/
DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10)
DECLARE @DatabaseNameExtract NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameExtract')
DECLARE @DefaultMaxDop NVARCHAR(3) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DefaultMaxDop')
	
/**********************************************************************************************************************************************************************
1. Update FrameworkMetaData table with IDs
***********************************************************************************************************************************************************************/
INSERT INTO meta.FrameworkMetaData
(SourceObjectID)

SELECT 
	SourceObjects.ID 
FROM 
	meta.SourceObjects 
LEFT JOIN 
	meta.FrameworkMetaData 
		ON FrameworkMetaData.SourceObjectID = SourceObjects.ID 
WHERE 
	FrameworkMetaData.BusinessMatrixID IS NULL
	AND FrameworkMetaData.SourceObjectID IS NULL	
	AND FrameworkMetaData.TargetObjectID IS NULL
	AND SourceObjects.ID = @SourceObjectID

DELETE FROM meta.FrameworkMetaData WHERE SourceObjectID NOT IN (SELECT ID FROM meta.SourceObjects) AND SourceObjectID IS NOT NULL;

/**********************************************************************************************************************************************************************
2. Create and insert data into table variables
**********************************************************************************************************************************************************************/
DECLARE @InformationSchemaTables TABLE (SourceObjectID INT, TableName NVARCHAR(128), ObjectName NVARCHAR(128),OrdinalPosition INT, ParallelizationFlag BIT, PartitionFlag BIT, UseModulusFlag BIT, PartitionValueColumnDefinition NVARCHAR(200))
INSERT @InformationSchemaTables SELECT SourceObjectID,[Name], [ObjectName], ROW_NUMBER() OVER ( ORDER BY ObjectName), ParallelizationFlag, PartitionFlag, UseModulusFlag, PartitionValueColumnDefinition FROM meta.SourceObjectDefinitions WHERE SourceObjectID = @SourceObjectID GROUP BY SourceObjectID,Name,ObjectName, ParallelizationFlag, PartitionFlag, UseModulusFlag, PartitionValueColumnDefinition

/**********************************************************************************************************************************************************************
3. Create Loop counter variables
**********************************************************************************************************************************************************************/
DECLARE @OuterCounter INT = 1
DECLARE @MaxTable INT = (SELECT MAX(OrdinalPosition) FROM @InformationSchemaTables)


/**********************************************************************************************************************************************************************
4. Create outer loop
**********************************************************************************************************************************************************************/
DECLARE @Table NVARCHAR(50)  
DECLARE @ObjectName NVARCHAR(50)  
DECLARE @Parallelization BIT
DECLARE @Partition BIT
DECLARE @UseModulusFlag BIT
DECLARE @PartitionValueColumnDefinition NVARCHAR(200)

WHILE @OuterCounter <= @MaxTable

BEGIN

SELECT
 @Table = TableName
,@SourceObjectID = SourceObjectID
,@ObjectName = ObjectName
,@Parallelization = ParallelizationFlag
,@Partition = PartitionFlag
,@UseModulusFlag = UseModulusFlag
,@PartitionValueColumnDefinition = PartitionValueColumnDefinition
FROM 
@InformationSchemaTables
WHERE 
@OuterCounter = OrdinalPosition



/**********************************************************************************************************************************************************************
5. Create and insert data into table variables
**********************************************************************************************************************************************************************/
DECLARE @Schemas TABLE (SourceConnectionID INT, SchemaName NVARCHAR(128), ExtractSchemaName NVARCHAR(128), OrdinalPosition INT)
DECLARE @InformationSchema TABLE (SourceConnectionID INT, TableName NVARCHAR(128),ColumnName NVARCHAR(128), SchemaName NVARCHAR(128), OrdinalPosition INT,DataType NVARCHAR(128), CharacterMaximumLength NVARCHAR(128), NumericPrecisionNumber INT ,SourceSystem NVARCHAR(128), OriginalDataType NVARCHAR(128), KeySequence INT)


INSERT @InformationSchema EXEC('WITH SourceData AS 
(SELECT 
   SourceConnectionID
  ,[TableName]
  ,MetaData.[ColumnName]
  ,[SchemaName]
  ,[OrdinalPositionNumber]
  ,[DataTypeName]
  ,[MaximumLenghtNumber]
  ,[NumericPrecisionNumber]
  ,[SourceSystemTypeName]
  ,IIF(SourceColumns.ColumnName IS NULL,0,1) AS TableHasColumnFilerFlag
  ,IIF(SourceColumns2.ColumnName IS NULL,0,1) AS ColumnFilerFlag
  ,[OriginalDataTypeName]
  ,[KeySequenceNumber]
  
   FROM 
		meta.ExtractInformationSchemaDefinitions AS MetaData
   LEFT JOIN
		meta.SourceColumns
			ON MetaData.SourceObjectID = SourceColumns.SourceObjectID
   LEFT JOIN
		meta.SourceColumns AS SourceColumns2
			ON MetaData.ColumnName = SourceColumns2.ColumnName
			AND MetaData.SourceObjectID = SourceColumns2.SourceObjectID 
   WHERE MetaData.SourceObjectID = ''' + @SourceObjectID + ''' 
   AND MetaData.ColumnName <> ''DWCreatedDate'')

SELECT   
   SourceConnectionID
  ,[TableName]
  ,[ColumnName]
  ,[SchemaName]
  ,ROW_NUMBER() OVER (PARTITION BY SourceConnectionID,TableName ORDER BY [OrdinalPositionNumber]) AS [OrdinalPositionNumber]
  ,[DataTypeName]
  ,[MaximumLenghtNumber]
  ,[NumericPrecisionNumber]
  ,[SourceSystemTypeName]
  ,[OriginalDataTypeName]
  ,[KeySequenceNumber]
FROM SourceData
WHERE TableHasColumnFilerFlag = ColumnFilerFlag
GROUP BY SourceConnectionID
  ,[TableName]
  ,[ColumnName]
  ,[SchemaName]
  ,[DataTypeName]
  ,[MaximumLenghtNumber]
  ,[NumericPrecisionNumber]
  ,[SourceSystemTypeName]
  ,[OrdinalPositionNumber]
  ,[OriginalDataTypeName]
  ,[KeySequenceNumber]')



INSERT @Schemas EXEC('SELECT SourceConnectionID, SchemaName, ExtractSchemaName,ROW_NUMBER() OVER (ORDER BY ExtractSchemaName)
FROM 
meta.ExtractInformationSchemaDefinitions AS MetaData
WHERE
MetaData.SourceObjectID = ''' + @SourceObjectID + '''
GROUP BY SourceConnectionID,ExtractSchemaName,SchemaName')

/**********************************************************************************************************************************************************************
6. Create Loop counter variables
**********************************************************************************************************************************************************************/
DECLARE @Counter INT
DECLARE @MaxColumns INT 
DECLARE @InnerCounter INT
DECLARE @MaxSchemas INT

SELECT 
@Counter = 1
   ,@InnerCounter = 1
   ,@MaxColumns = (SELECT MAX(OrdinalPosition) FROM @InformationSchema)
   ,@MaxSchemas = (SELECT MAX(OrdinalPosition) FROM @Schemas)


/**********************************************************************************************************************************************************************
7. Create loop
**********************************************************************************************************************************************************************/
DECLARE @SourceTable NVARCHAR(MAX)
DECLARE @PlaceholderColumns NVARCHAR(MAX)
DECLARE @Columns NVARCHAR(MAX)
DECLARE @TableScript NVARCHAR(MAX)
DECLARE @Schema NVARCHAR(MAX)
DECLARE @ExtractSchema NVARCHAR(MAX)
DECLARE @ConnectionID INT
DECLARE @NavisionFlag BIT
DECLARE @RemoveBrackets BIT
DECLARE @OracleFlag BIT
DECLARE @MySQLFlag BIT
DECLARE @SQLScript NVARCHAR(MAX)
DECLARE @KeyColumn NVARCHAR(MAX) = IIF(@UseModulusFlag = 1 AND @Partition = 1, @PartitionValueColumnDefinition,(SELECT '[' + ColumnName + ']' FROM @InformationSchema WHERE KeySequence = 1))



WHILE @Counter <= @MaxSchemas

BEGIN

SELECT 
@Schema = ISNULL(SchemaName,''),
@ExtractSchema = ExtractSchemaName,
@ConnectionID = SourceConnectionID
FROM @Schemas
WHERE @Counter = OrdinalPosition 

SET @NavisionFlag = (SELECT NavisionFlag FROM meta.SourceConnections WHERE ID = @ConnectionID)
SET @RemoveBrackets = (SELECT RemoveBracketsFlag FROM meta.SourceConnections WHERE ID = @ConnectionID)
SET @OracleFlag = IIF((SELECT ConnectionType FROM meta.SourceConnections WHERE ID = @ConnectionID) = 'Oracle',1,0)
SET @MySQLFlag = IIF((SELECT ConnectionType FROM meta.SourceConnections WHERE ID = @ConnectionID) = 'MySQL',1,0)

/**********************************************************************************************************************************************************************
8. Create inner loop
**********************************************************************************************************************************************************************/


WHILE @InnerCounter <= @MaxColumns

BEGIN

	SELECT 
	@PlaceholderColumns = IIF(@InnerCounter = 1,'',',') 
													+ CASE 
														WHEN NumericPrecisionNumber > 36 THEN 'CAST([' + ColumnName + '] AS DECIMAL(36,12)) AS [' + ColumnName + ']'
														WHEN @MySQLFlag = 1 AND OriginalDataType = 'TIME' THEN 'CAST(' + ColumnName + ' AS CHAR) AS ' + ColumnName 
														WHEN @NavisionFlag = 1 AND ColumnName = 'timestamp' THEN 'CAST([' + ColumnName + '] AS BIGINT) AS [' + ColumnName + ']'
														ELSE '[' + ColumnName + ']'
													  END
													+ @CRLF				
	FROM @InformationSchema
	WHERE OrdinalPosition = @InnerCounter
	AND SchemaName = @Schema
	AND SourceConnectionID = @ConnectionID

	SET @Columns = CONCAT(@Columns,@PlaceholderColumns)
	SET @PlaceholderColumns = ''

	SET @InnerCounter = @InnerCounter + 1
	--Jacob �ndring:
	-- @OracleFlag=1 i stedet for ConnectionTye='Oracle'
END

SELECT
	 @SQLScript = 'SELECT ' + @Columns + IIF(@NavisionFlag = 1,',''@{item().NavisionCompany}'' AS DWNavisionCompany','') + ' FROM ' + @Schema + IIF(@Schema = '','','.') + '[' + IIF(@NavisionFlag = 1,'@{item().NavisionCompany}$','') + @Table + ']' + @CRLF + 
																				  CASE 
																					 WHEN ExtractSQLFilter = '' AND IncrementalFlag = 0 AND @Parallelization = 0 THEN ''
																					 WHEN ExtractSQLFilter = '' AND IncrementalFlag = 0 AND @Parallelization = 1 THEN 'WHERE ' + CASE WHEN @Partition = 0 OR (@Partition = 1 AND @UseModulusFlag = 1) THEN CASE
																																																																WHEN @OracleFlag = 1 THEN 'MOD(' + @KeyColumn + ',' + @DefaultMaxDop + ') = ''@{item().RowN}'''
																																																																ELSE @KeyColumn + ' % ' + @DefaultMaxDop + ' = ''@{item().RowN}'''
																																																														   END
																																													  WHEN @Partition = 1 AND @UseModulusFlag = 0 THEN '@{item().PartitionDefinition} >= ''@{item().PartitionLowerBound}'' AND @{item().PartitionDefinition} <= ''@{item().PartitionUpperBound}'''
																																												 END
																					 WHEN ExtractSQLFilter = '' AND IncrementalFlag = 1 AND @Parallelization = 0 THEN ' WHERE ' + IncrementalValueColumnDefinition + ' > ' +   CASE
																																																		WHEN IncrementalFlag = 1 AND @OracleFlag = 1 AND IsDateFlag = 1 THEN 'TO_DATE(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'',''YYYYMMDDHH24MISS'')'
																																																		WHEN IncrementalFlag = 1 AND @OracleFlag = 0 AND ExtractPattern IN ('Standard','Navision','Replacement') AND IsDateFlag = 1 THEN 'convert(datetime, stuff(stuff(stuff(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'', 9, 0, '' ''), 12, 0, '':''), 15, 0, '':''))'
																																																		ELSE '''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'''
																																																	END
																					 WHEN ExtractSQLFilter = '' AND IncrementalFlag = 1 AND @Parallelization = 1 THEN ' WHERE ' + IncrementalValueColumnDefinition + ' > ' +   CASE
																																																									WHEN IncrementalFlag = 1 AND @OracleFlag = 1 AND IsDateFlag = 1 THEN 'TO_DATE(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'',''YYYYMMDDHH24MISS'')'
																																																									WHEN IncrementalFlag = 1 AND @OracleFlag = 0 AND ExtractPattern IN ('Standard','Navision','Replacement') AND IsDateFlag = 1 THEN 'convert(datetime, stuff(stuff(stuff(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'', 9, 0, '' ''), 12, 0, '':''), 15, 0, '':''))'
																																																									ELSE '@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'
																																																								END  + CASE WHEN @Partition = 0 OR (@Partition = 1 AND @UseModulusFlag = 1) THEN CASE
																																																																														WHEN @OracleFlag = 1 THEN 'AND MOD(' + @KeyColumn + ',' + @DefaultMaxDop + ') = ''@{item().RowN}'''
																																																																														ELSE 'AND ' + @KeyColumn + ' % ' + @DefaultMaxDop + ' = ''@{item().RowN}'''
																																																																												   END
																																																											WHEN @Partition = 1 AND @UseModulusFlag = 0 THEN '@{item().PartitionDefinition} >= ''@{item().PartitionLowerBound}'' AND @{item().PartitionDefinition} <= ''@{item().PartitionUpperBound}'''
																																																									   END
																					 WHEN ExtractSQLFilter <> '' AND IncrementalFlag = 0 AND @Parallelization = 0 THEN 'WHERE ' + ExtractSQLFilter 
																					 WHEN ExtractSQLFilter <> '' AND IncrementalFlag = 0 AND @Parallelization = 1 THEN 'WHERE ' + ExtractSQLFilter +  CASE WHEN @Partition = 0 OR (@Partition = 1 AND @UseModulusFlag = 1) THEN CASE
																																																																					WHEN @OracleFlag = 1 THEN 'AND MOD(' + @KeyColumn + ',' + @DefaultMaxDop + ') = ''@{item().RowN}'''
																																																																					ELSE 'AND ' + @KeyColumn + ' % ' + @DefaultMaxDop + ' = ''@{item().RowN}'''
																																																																				END
																																																		   WHEN @Partition = 1 AND @UseModulusFlag = 0 THEN '@{item().PartitionDefinition} >= ''@{item().PartitionLowerBound}'' AND @{item().PartitionDefinition} <= ''@{item().PartitionUpperBound}'''
																																																	  END
																					 WHEN ExtractSQLFilter <> '' AND IncrementalFlag = 1 AND @Parallelization = 0 THEN 'WHERE ' + ExtractSQLFilter + ' AND ' + IncrementalValueColumnDefinition + ' > ' +      CASE
																																																																	WHEN IncrementalFlag = 1 AND @OracleFlag = 1 AND IsDateFlag = 1 THEN 'TO_DATE(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'',''YYYYMMDDHH24MISS'')'
																																																																	WHEN IncrementalFlag = 1 AND @OracleFlag = 0 AND ExtractPattern IN ('Standard','Navision','Replacement') AND IsDateFlag = 1 THEN 'convert(datetime, stuff(stuff(stuff(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'', 9, 0, '' ''), 12, 0, '':''), 15, 0, '':''))'
																																																																	ELSE '@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'
																																																																END
																					 WHEN ExtractSQLFilter <> '' AND IncrementalFlag = 1 AND @Parallelization = 1 THEN 'WHERE ' + ExtractSQLFilter + ' AND ' + IncrementalValueColumnDefinition + ' > ' +      CASE
																																																																	WHEN IncrementalFlag = 1 AND @OracleFlag = 1 AND IsDateFlag = 1 THEN 'TO_DATE(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'',''YYYYMMDDHH24MISS'')'
																																																																	WHEN IncrementalFlag = 1 AND @OracleFlag = 0 AND ExtractPattern IN ('Standard','Navision','Replacement') AND IsDateFlag = 1 THEN 'convert(datetime, stuff(stuff(stuff(''@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'', 9, 0, '' ''), 12, 0, '':''), 15, 0, '':''))'
																																																																	ELSE '@{activity(''Lookup_LastValueLoaded'').output.firstRow.LastValueLoaded}'
																																																																END + CASE WHEN @Partition = 0 OR (@Partition = 1 AND @UseModulusFlag = 1) THEN CASE
																																																																																					WHEN @OracleFlag = 1 THEN 'AND MOD(' + @KeyColumn + ',' + @DefaultMaxDop + ') = ''@{item().RowN}'''
																																																																																					ELSE 'AND ' + @KeyColumn + ' % ' + @DefaultMaxDop + ' = ''@{item().RowN}'''
																																																																																				END
																																																																		   WHEN @Partition = 1 AND @UseModulusFlag = 0 THEN '@{item().PartitionDefinition} >= ''@{item().PartitionLowerBound}'' AND @{item().PartitionDefinition} <= ''@{item().PartitionUpperBound}'''
																																																																	  END
																				  END + @CRLF
																																												 
FROM meta.SourceObjects		
LEFT JOIN
	meta.SourceObjectIncrementalSetup
		ON SourceObjectIncrementalSetup.SourceObjectID = SourceObjects.ID
WHERE SourceObjects.ID = @SourceObjectID


/**********************************************************************************************************************************************************************
8. Update FrameworkMetaDate
**********************************************************************************************************************************************************************/

IF @PrintSQL = 0
	BEGIN
		UPDATE FrameworkMetaData
		SET SQLScript = IIF(@RemoveBrackets = 1 OR @OracleFlag = 1 OR @MySQLFlag = 1,REPLACE(REPLACE(@SQLScript,'[',''),']',''),@SQLScript)
		FROM meta.FrameworkMetaData
		INNER JOIN
			meta.SourceObjects
				ON SourceObjects.ID = FrameworkMetaData.SourceObjectID
				AND SourceObjects.SourceConnectionID = @ConnectionID
		LEFT JOIN
			meta.SourceObjectIncrementalSetup
				ON SourceObjectIncrementalSetup.SourceObjectID = SourceObjects.ID
		WHERE SourceObjects.ID = @SourceObjectID
	END
ELSE
	BEGIN
		PRINT(IIF(@RemoveBrackets = 1 OR @OracleFlag = 1 OR @MySQLFlag = 1,REPLACE(REPLACE(LEFT(@SQLScript,4000),'[',''),']',''),LEFT(@SQLScript,4000)))
		PRINT(IIF(@RemoveBrackets = 1 OR @OracleFlag = 1 OR @MySQLFlag = 1,REPLACE(REPLACE(SUBSTRING(@SQLScript,4001,4000),'[',''),']',''),SUBSTRING(@SQLScript,4001,4000)))
		PRINT(IIF(@RemoveBrackets = 1 OR @OracleFlag = 1 OR @MySQLFlag = 1,REPLACE(REPLACE(SUBSTRING(@SQLScript,8001,4000),'[',''),']',''),SUBSTRING(@SQLScript,8001,4000)))
	END

SET @InnerCounter = 1

SET @Schema = ''

SET @ExtractSchema = ''

SET @Columns = ''

SET @Counter = @Counter + 1

END

DELETE FROM @InformationSchema
DELETE FROM @Schemas


SET @Table = ''

SET @OuterCounter = @OuterCounter + 1

END
GO
PRINT N'Creating [meta].[MaintainTarget]...';


GO


CREATE PROCEDURE [meta].[MaintainTarget]

@TargetObjectID INT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
1. Create Extract Tables
**********************************************************************************************************************************************************************/
DECLARE @ExecuteCreateTable NVARCHAR(MAX)
DECLARE @ExecuteCreateSourceScript NVARCHAR(MAX)
DECLARE @ExecuteCreateConnectionScript NVARCHAR(MAX)


SELECT 
	 @ExecuteCreateTable = 'EXECUTE meta.[MaintainTargetCreateTableScript] @TargetObjectID = ''' + CAST(@TargetObjectID AS NVARCHAR(20)) + ''', @PrintSQL = 0'
	,@ExecuteCreateSourceScript = 'EXECUTE meta.[MaintainTargetCreateSourceScript] @TargetObjectID = ''' + CAST(@TargetObjectID AS NVARCHAR(20)) + ''', @PrintSQL = 0'
	,@ExecuteCreateConnectionScript = 'EXECUTE meta.[MaintainTargetCreateConnectionScript] @TargetObjectID = ''' + CAST(@TargetObjectID AS NVARCHAR(20)) + ''', @PrintSQL = 0'

EXEC(@ExecuteCreateTable)
EXEC(@ExecuteCreateSourceScript)
EXEC(@ExecuteCreateConnectionScript)

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[MaintainDWUpdateTable]...';


GO


/**********************************************************************************************************************************************************************
The purpose of this scripts is to create and execute the update table between stage and dw. 
***********************************************************************************************************************************************************************/


CREATE PROCEDURE [meta].[MaintainDWUpdateTable]

@Table NVARCHAR(100),--Input is the table name without schema
@DestinationSchema NVARCHAR(10),--Input is the destination schema (dim, fact or bridge)
@PrintSQL BIT--Enter 1 if you want to print the dynamic SQL and 0 if you want to execute the dynamic SQL

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/

DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10) 
DECLARE @DatabaseNameStage NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameStage')
DECLARE @DatabaseNameDW NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW')
DECLARE @DatabaseNameMeta NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameMeta')
DECLARE @SurrogateKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'SurrogateKeySuffix')
DECLARE @BusinessKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'BusinessKeySuffix')
DECLARE @FactIsIncremental BIT = (SELECT FactAndBridgeIncrementalFlag FROM meta.BusinessMatrix WHERE TableName = @Table AND DestinationSchema = @DestinationSchema)
DECLARE @LoadPattern NVARCHAR(50) = (SELECT LoadPattern FROM meta.BusinessMatrix WHERE TableName = @Table)
DECLARE @IsCloudFlag BIT = IIF((SELECT VariableValue FROM meta.Variables WHERE VariableName = 'IsCloudFlag') = '1',1,0)
DECLARE @StageSchemaTable TABLE (SchemaName NVARCHAR(10)) 
INSERT @StageSchemaTable EXEC('SELECT DISTINCT TABLE_SCHEMA FROM [' + @DatabaseNameStage + '].INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''' + @Table + ''' AND TABLE_SCHEMA IN (''dbo'',''stage'')')
DECLARE @StageSchema NVARCHAR(10) = (SELECT IIF(@IsCloudFlag = 1,'stage',(SELECT SchemaName FROM @StageSchemaTable))) --If on-premise and stageschema has not been changed
DECLARE @DatabaseCollation NVARCHAR(100) = (SELECT CONVERT (varchar, DATABASEPROPERTYEX('' + @DatabaseNameMeta + '','collation')))
DECLARE @CreateTruncateProperty BIT = (SELECT TruncateBeforeDeployFlag FROM meta.BusinessMatrix WHERE TableName = @Table AND DestinationSchema = @DestinationSchema)


/**********************************************************************************************************************************************************************
1. Create and insert data into table variables
***********************************************************************************************************************************************************************/

DECLARE @InformationSchema TABLE (DatabaseName NVARCHAR(128), TableName NVARCHAR(128), ColumnName NVARCHAR(128), OrdinalPosition INT, DataType NVARCHAR(128), CharacterMaximumLenght INT, NumericPrecision INT, NumericScale INT, PrimaryKey INT, DefaultConstraintName NVARCHAR(128))
DECLARE @DWRelations TABLE (TableName NVARCHAR(128), DimensionName NVARCHAR(128), TableColumnName NVARCHAR(128), DimensionColumnMappingName NVARCHAR(128), RolePlayingDimensionName NVARCHAR(128), IsSCD2DimensionFlag NVARCHAR(10), IsSCD2CompositeKeyDimensionFlag NVARCHAR(10), ColumnOrdinalPosition INT, IsNewDimensionFlag NVARCHAR(128), DefaultErrorValue NVARCHAR(128))
DECLARE @DimensionCombinedKeys TABLE (TableName NVARCHAR(128), ColumnName NVARCHAR(128), DimensionTable NVARCHAR(128), OrdinalPosition INT)
DECLARE @ColumnDefaults TABLE (DataType NVARCHAR(50),DefaultValue NVARCHAR(250))
DECLARE @PrimaryKeys TABLE (ColumnName NVARCHAR(128), OrdinalPosition INT)
DECLARE @ExistingPrimaryKeys TABLE (TableName NVARCHAR(128), ColumnName NVARCHAR(128))
DECLARE @CreatePrimaryKeys TABLE (ColumnName NVARCHAR(128), OrdinalPosition INT)
DECLARE @DropPrimaryKeys TABLE (ColumnName NVARCHAR(128), OrdinalPosition INT)
DECLARE @PrimaryDimensionKeys TABLE (ColumnName NVARCHAR(128), OrdinalPosition INT)
DECLARE @SCD2Columns TABLE (ColumnName NVARCHAR(128))
DECLARE @ExistingSCD2Columns TABLE (TableName NVARCHAR(128), ColumnName NVARCHAR(128))
DECLARE @CreateSCD2Columns TABLE (ColumnName NVARCHAR(128), OrdinalPosition INT)
DECLARE @DropSCD2Columns TABLE (ColumnName NVARCHAR(128), OrdinalPosition INT)
DECLARE @TableIsIncremental TABLE (TableName NVARCHAR(128))
DECLARE @ExistingTruncateProperty TABLE (TableName NVARCHAR(128))

/*Generates the combined information schema*/

INSERT @InformationSchema EXEC('--Create dataset with default constraints
								WITH DefaultConstraints AS
								(
								SELECT  objects.name AS TABLE_NAME 
										,all_columns.Name AS COLUMN_NAME
										,default_constraints.[name] AS DEFAULT_CONSTRAINT_NAME
								FROM 
									[' + @DatabaseNameDW + '].sys.default_constraints
								INNER JOIN 
									[' + @DatabaseNameDW + '].sys.objects
										ON objects.object_id = default_constraints.parent_object_id
								INNER JOIN 
									[' + @DatabaseNameDW + '].sys.all_columns 
										ON all_columns.object_id = objects.object_id
										AND all_columns.column_id = default_constraints.parent_column_id
								WHERE 
									objects.name = ''' + @Table + '''
								)
								
								SELECT  ''Stage'' AS DATABASE_NAME
										,COLUMNS.TABLE_NAME
										--If destinations shcema is fact or bridge key columns from stage is renamed to ID in order to compare column names
										,CASE 
											WHEN ''' + @DestinationSchema + ''' IN (''fact'',''bridge'') AND COLUMNS.COLUMN_NAME LIKE ''%' + @BusinessKeySuffix + ''' 
												THEN REPLACE(COLUMNS.COLUMN_NAME,''' + @BusinessKeySuffix + ''',''' + @SurrogateKeySuffix + ''') 
										    ELSE COLUMNS.COLUMN_NAME 
										 END AS COLUMN_NAME
										,COLUMNS.ORDINAL_POSITION
										,CASE 
											WHEN ''' + @DestinationSchema + ''' IN (''fact'',''bridge'') AND COLUMNS.COLUMN_NAME LIKE ''%' + @BusinessKeySuffix + ''' 
												THEN ''int'' 
											ELSE DATA_TYPE 
										 END AS DATA_TYPE
										,CHARACTER_MAXIMUM_LENGTH
										,NUMERIC_PRECISION
										,NUMERIC_SCALE
										,CASE 
											WHEN KEY_COLUMN_USAGE.COLUMN_NAME IS NULL 
												THEN 0 
										    ELSE 1 
										 END AS PRIMARY_KEY
										,DEFAULT_CONSTRAINT_NAME
								FROM 
									[' + @DatabaseNameStage + '].INFORMATION_SCHEMA.COLUMNS
								LEFT JOIN 
									[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.KEY_COLUMN_USAGE
										ON COLUMNS.TABLE_NAME = KEY_COLUMN_USAGE.TABLE_NAME 
										AND COLUMNS.COLUMN_NAME = KEY_COLUMN_USAGE.COLUMN_NAME
								LEFT JOIN 
									DefaultConstraints
										ON COLUMNS.TABLE_NAME = DefaultConstraints.TABLE_NAME
										AND CASE WHEN ''' + @DestinationSchema + ''' IN (''fact'',''bridge'') AND COLUMNS.COLUMN_NAME LIKE ''%' + @BusinessKeySuffix + ''' THEN REPLACE(COLUMNS.COLUMN_NAME,''' + @BusinessKeySuffix + ''',''' + @SurrogateKeySuffix + ''') 
												 ELSE COLUMNS.COLUMN_NAME 
											END = DefaultConstraints.COLUMN_NAME
								WHERE 
										COLUMNS.TABLE_NAME = ''' + @Table + ''' 
									AND COLUMNS.COLUMN_NAME NOT LIKE ''DW%''
									AND COLUMNS.TABLE_SCHEMA = ''' + @StageSchema + '''

								UNION ALL

								SELECT ''DW'' AS DATABASE_NAME
										,COLUMNS.TABLE_NAME
										,COLUMNS.COLUMN_NAME
										,ORDINAL_POSITION
										,DATA_TYPE
										,CHARACTER_MAXIMUM_LENGTH
										,NUMERIC_PRECISION
										,NUMERIC_SCALE
										,0
										,DEFAULT_CONSTRAINT_NAME
								FROM 
									[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.COLUMNS
								LEFT JOIN 
									DefaultConstraints
										ON COLUMNS.TABLE_NAME = DefaultConstraints.TABLE_NAME
										AND COLUMNS.COLUMN_NAME = DefaultConstraints.COLUMN_NAME
								WHERE 
										COLUMNS.TABLE_NAME = ''' + @Table + ''' 
									AND TABLE_SCHEMA = ''' + @DestinationSchema + ''' 
									AND COLUMNS.COLUMN_NAME NOT LIKE ''DW%''
									AND CASE WHEN ''' + @DestinationSchema + ''' <> ''bridge'' THEN COLUMNS.COLUMN_NAME 
									         ELSE ''1'' 
								        END <>
									    CASE WHEN ''' + @DestinationSchema + ''' <> ''bridge'' THEN ''' + @Table + '' + @SurrogateKeySuffix + ''' 
									         ELSE ''2'' 
										END')

INSERT @DWRelations EXEC meta.CreateDWRelations @Table					

/*Populates @DimensionCombinedKeys to check if combined keys are used and in which dimensions they are used*/

INSERT @DimensionCombinedKeys SELECT 
										DWRelations.TableName
									  ,	DWRelations.TableColumnName
									  ,	DWRelations.RolePlayingDimensionName
									  , InformationSchema.OrdinalPosition
									  
								FROM 
									@DWRelations AS DWRelations
								INNER JOIN
									@InformationSchema AS InformationSchema
										ON InformationSchema.ColumnName = REPLACE(DWRelations.TableColumnName,@BusinessKeySuffix,@SurrogateKeySuffix)
										AND InformationSchema.DatabaseName = 'Stage'
								WHERE --Only dimensions with composite keys are maintained
									DWRelations.RolePlayingDimensionName IN (
								SELECT 
										RolePlayingDimensionName
								FROM 
									@DWRelations
								WHERE 
									TableColumnName  LIKE RolePlayingDimensionName + '%'
								GROUP BY
										RolePlayingDimensionName
								HAVING
									COUNT(*) > 1)
								AND TableColumnName  LIKE RolePlayingDimensionName + '%'

INSERT @PrimaryDimensionKeys  EXEC('SELECT 
										 COLUMN_NAME
										,ROW_NUMBER() OVER (ORDER BY COLUMN_NAME) 
										
								FROM 
									[' + @DatabaseNameStage + '].INFORMATION_SCHEMA.COLUMNS
								WHERE 
									    TABLE_NAME = ''' + @Table + ''' 
									AND TABLE_SCHEMA = ''' + @StageSchema + '''
									AND COLUMN_NAME LIKE ''%Key''')
									
							

INSERT @ColumnDefaults EXEC('SELECT REPLACE([name],''Default'','''') AS DataType
								   ,CONVERT(NVARCHAR(128),value) AS DefaultValue
							 FROM 
								sys.extended_properties
							 WHERE 
								[name] IN (''DefaultDate'',''DefaultDimensionMemberID'',''DefaultNumber'',''DefaultString'',''DefaultBit'')')	

/*Populate table variables used foa assigning and removing extended column properties*/

INSERT @ExistingPrimaryKeys   EXEC('SELECT DISTINCT
										tables.name
									   ,all_columns.name 
									FROM
									   [' + @DatabaseNameDW + '].sys.tables
									INNER JOIN 
									   [' + @DatabaseNameDW + '].sys.schemas
										ON schemas.schema_id = tables.schema_id
									INNER JOIN 
									   [' + @DatabaseNameDW + '].sys.all_columns 
											ON all_columns.object_id=tables.object_id
									INNER JOIN 
									   [' + @DatabaseNameDW + '].sys.extended_properties
											ON extended_properties.major_id=tables.object_id 
											AND extended_properties.minor_id=all_columns.column_id 
											AND extended_properties.class=1
									WHERE
									   extended_properties.name = ''PrimaryKeyColumn''
									   AND schemas.name = ''' + @DestinationSchema + '''
									   AND tables.name = ''' + @Table + '''')
								
INSERT @PrimaryKeys SELECT PrimaryKeyColumnName AS ColumnName,ROW_NUMBER() OVER (ORDER BY PrimaryKeyColumnName) AS OrdinalPosition FROM meta.BusinessMatrixIncrementalSetup INNER JOIN meta.BusinessMatrix ON BusinessMatrix.ID = BusinessMatrixIncrementalSetup.BusinessMatrixID WHERE BusinessMatrix.TableName = @Table AND BusinessMatrix.FactAndBridgeIncrementalFlag = 1	 

INSERT @CreatePrimaryKeys SELECT 
							 PK.ColumnName
						   , ROW_NUMBER() OVER (ORDER BY PK.ColumnName) AS OrdinalPosition 
						  FROM 
							@PrimaryKeys AS PK
						  LEFT JOIN 
							@ExistingPrimaryKeys AS Existing 
								ON Existing.ColumnName =  PK.ColumnName
						  WHERE 
							Existing.ColumnName IS NULL		

INSERT @DropPrimaryKeys	  SELECT 
							 Existing.ColumnName
						   , ROW_NUMBER() OVER (ORDER BY Existing.ColumnName) AS OrdinalPosition  
						  FROM 
							@ExistingPrimaryKeys AS Existing 
						  LEFT JOIN 
							@PrimaryKeys AS New 
								ON New.ColumnName = Existing.ColumnName 
						  WHERE 
							New.ColumnName IS NULL

INSERT @ExistingSCD2Columns   EXEC('SELECT DISTINCT
										tables.name
									   ,all_columns.name 
									FROM
									   [' + @DatabaseNameDW + '].sys.tables
									INNER JOIN 
									   [' + @DatabaseNameDW + '].sys.all_columns 
											ON all_columns.object_id=tables.object_id
									INNER JOIN 
									   [' + @DatabaseNameDW + '].sys.extended_properties
											ON extended_properties.major_id=tables.object_id 
											AND extended_properties.minor_id=all_columns.column_id 
											AND extended_properties.class=1
									WHERE
									   extended_properties.name = ''SCDColumn''
									   AND tables.name = ''' + @Table + '''')

INSERT @SCD2Columns EXEC('WITH AllColumns AS

						  (
						  SELECT COLUMN_NAME COLLATE ' + @DatabaseCollation + ' AS COLUMN_NAME
						  FROM 
							[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.COLUMNS
						  WHERE
							TABLE_SCHEMA = ''dim''
							AND TABLE_NAME = ''' + @Table + '''
							AND COLUMN_NAME NOT LIKE ''DW%''

						  )
						  
						  
						  
						  SELECT DISTINCT IIF(SCD2ColumnName = ''*'',COLUMN_NAME,SCD2ColumnName)
						  FROM 
							[meta].[BusinessMatrixSCD2Setup] 
						  INNER JOIN 
							[meta].[BusinessMatrix] 
								ON BusinessMatrixSCD2Setup.BusinessMatrixID = BusinessMatrix.ID
						  LEFT JOIN
							AllColumns
								ON SCD2ColumnName = ''*''
						  WHERE 
							TableName = ''' + @Table + '''
							AND DestinationSchema = ''dim''
							AND SCD2ColumnName <> ''''
							AND BusinessMatrix.SCD2DimensionFlag = 1')

INSERT @CreateSCD2Columns SELECT 
							 SCD2.ColumnName
						   , ROW_NUMBER() OVER (ORDER BY SCD2.ColumnName) AS OrdinalPosition 
						  FROM 
							@SCD2Columns AS SCD2
						  LEFT JOIN 
							@ExistingSCD2Columns AS Existing 
								ON Existing.ColumnName =  SCD2.ColumnName
						  WHERE 
							Existing.ColumnName IS NULL		

INSERT @DropSCD2Columns	  SELECT 
							 Existing.ColumnName
						   , ROW_NUMBER() OVER (ORDER BY Existing.ColumnName) AS OrdinalPosition  
						  FROM 
							@ExistingSCD2Columns AS Existing 
						  LEFT JOIN 
							@SCD2Columns AS New 
								ON New.ColumnName = Existing.ColumnName 
						  WHERE 
							New.ColumnName IS NULL

INSERT @TableIsIncremental   EXEC('SELECT DISTINCT
										tables.name
									FROM
									   [' + @DatabaseNameDW + '].sys.tables								
									INNER JOIN 
									   [' + @DatabaseNameDW + '].sys.extended_properties
											ON extended_properties.major_id=tables.object_id 
									WHERE
									   extended_properties.name = ''IncrementalFactOrBridgeFlag''
									   AND tables.name = ''' + @Table + '''')

							
INSERT @ExistingTruncateProperty EXEC('SELECT DISTINCT
											tables.name
									  FROM
										[' + @DatabaseNameDW + '].sys.tables									
										INNER JOIN
										[' + @DatabaseNameDW + '].sys.schemas
												ON 	schemas.schema_id = tables.schema_id	
										INNER JOIN
											[' + @DatabaseNameDW + '].sys.extended_properties AS TableProperties
											ON TableProperties.major_id=tables.object_id 										
											AND TableProperties.class=1
									  WHERE
											tables.name = ''' + @Table + '''
											AND TableProperties.name = ''TruncateBeforeDeploy''
											AND schemas.name = ''' + @DestinationSchema + '''')

										


/**********************************************************************************************************************************************************************
2. Create Loop counter variables
***********************************************************************************************************************************************************************/

DECLARE @Columns AS INT --Holds the number of columns in the table
DECLARE @Counter AS INT --Just a counter for the loop
DECLARE @NumberOfPrimaryKeyColumns INT
DECLARE @NumberOfPrimaryKeyColumnsToDrop AS INT --Holds the number of columns in the table
DECLARE @NumberOfPrimaryDimensionColumns AS INT --Holds the number of columns in the table
DECLARE @NumberOfSCD2Columns AS INT --Holds the number of columns in the table
DECLARE @NumberOfSCD2ColumnsToDrop AS INT --Holds the number of columns in the table
DECLARE @SCD2HistoryFromSourceKey BIT --If the dimension has the following columns DimensionNameIsCurrent, DimensionNameValidFromDate and DimensionNameValidToDate SCD2 history is created in the source

SELECT 
	@Columns = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE DatabaseName = 'Stage'), --Counts the number of columns in the table
	@Counter = 1,
	@NumberOfPrimaryKeyColumns = (SELECT MAX(OrdinalPosition) FROM @PrimaryKeys),
	@NumberOfPrimaryKeyColumnsToDrop = (SELECT MAX(OrdinalPosition) FROM @DropPrimaryKeys),
	@NumberOfPrimaryDimensionColumns = (SELECT MAX(OrdinalPosition) FROM @PrimaryDimensionKeys),
	@NumberOfSCD2Columns = (SELECT MAX(OrdinalPosition) FROM @CreateSCD2Columns),
	@NumberOfSCD2ColumnsToDrop = (SELECT MAX(OrdinalPosition) FROM @DropSCD2Columns),
	@SCD2HistoryFromSourceKey = (SELECT IIF(COUNT(ColumnName) = 3, 1, 0) FROM @InformationSchema WHERE REPLACE(ColumnName,@Table,'') IN ('IsCurrent', 'ValidFromDate', 'ValidToDate') AND DatabaseName = 'Stage' )


/**********************************************************************************************************************************************************************
3. Create variables for determine first change between stage and dw
***********************************************************************************************************************************************************************/

DECLARE @PositionFirstChangeNoCombinedKey INT --The ordinal position of the first change not looking at combined key columns
DECLARE @PositionFirstChangeCombinedKey INT --The ordinal position of the first change looking at combined Key columns
DECLARE @PositionFirstChange INT --The ordinal position of the first change
DECLARE @FirstNonKeyColumn INT --The ordinal position of the first non key column

SELECT
	@FirstNonKeyColumn = (SELECT TOP 1 OrdinalPosition FROM @InformationSchema WHERE DatabaseName = 'Stage' AND ColumnName NOT LIKE '%' + @SurrogateKeySuffix ORDER BY OrdinalPosition) ,
	@PositionFirstChangeNoCombinedKey = (SELECT TOP 1 Stage.OrdinalPosition
										 FROM 
											@InformationSchema AS Stage
										 LEFT JOIN 
											(SELECT * FROM @InformationSchema WHERE DatabaseName = 'DW') AS DW 
												ON Stage.ColumnName = DW.ColumnName
										 WHERE 
											Stage.DatabaseName = 'Stage' 
											AND DW.ColumnName IS NULL 
											AND (Stage.ColumnName NOT IN (SELECT REPLACE(ColumnName,@BusinessKeySuffix,@SurrogateKeySuffix) FROM @DimensionCombinedKeys))
										 ORDER BY Stage.OrdinalPosition
											), --Determines the position of the first change for non combined key columns


	@PositionFirstChangeCombinedKey = (SELECT TOP 1 OrdinalPosition 
									   FROM
											@DimensionCombinedKeys 
									   WHERE 
											DimensionTable + @SurrogateKeySuffix NOT IN (SELECT ColumnName FROM @InformationSchema WHERE DatabaseName = 'DW')
									   ORDER BY OrdinalPosition), --Determines the position for the first change for combined key columns


	@PositionFirstChange = CASE 
								WHEN @PositionFirstChangeNoCombinedKey IS NOT NULL AND @PositionFirstChangeNoCombinedKey > ISNULL(@PositionFirstChangeCombinedKey,1000) AND @DestinationSchema = 'fact' 
									THEN @PositionFirstChangeCombinedKey
    							WHEN @PositionFirstChangeNoCombinedKey IS NULL AND @DestinationSchema = 'fact' 
									THEN @PositionFirstChangeCombinedKey
								ELSE @PositionFirstChangeNoCombinedKey 
						   END --Determines the position of the first change

/**********************************************************************************************************************************************************************
4. Create new column names part
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderColumnNameUpdateTable AS NVARCHAR(MAX) 
DECLARE @ColumnNameUpdateTable AS NVARCHAR(MAX)

SET @Counter = @PositionFirstChange

WHILE @Counter <= @Columns

BEGIN

	SELECT @PlaceholderColumnNameUpdateTable = --Check if it is the first column 
											   CASE 
													WHEN Stage.OrdinalPosition = @PositionFirstChange 
														THEN ''
													ELSE ','
											   END 

											   +
											   --If the destination schema is bridge or fact key columns is handled seperatly
											   CASE 
													WHEN @DestinationSchema IN ('fact','bridge') AND Stage.ColumnName LIKE '%' + @SurrogateKeySuffix AND Stage.ColumnName NOT IN (SELECT ColumnName FROM @DimensionCombinedKeys)
														THEN  '[' + REPLACE(Stage.ColumnName,@BusinessKeySuffix,@SurrogateKeySuffix) + '] INT NOT NULL DEFAULT(' + (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DefaultDimensionMemberID') + ')'
													WHEN @DestinationSchema IN ('fact','bridge') AND Stage.ColumnName LIKE '%' + @SurrogateKeySuffix AND Stage.ColumnName IN (SELECT ColumnName FROM @DimensionCombinedKeys)
														THEN  '[' + (SELECT DISTINCT DimensionTable FROM @DimensionCombinedKeys AS Dimensions WHERE Stage.ColumnName = Dimensions.ColumnName) + @SurrogateKeySuffix +'] INT NOT NULL DEFAULT(' + (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DefaultDimensionMemberID') + ')'
													ELSE  '[' + Stage.ColumnName + '] ' + UPPER(Stage.DataType) + CASE 
																													  WHEN Stage.DataType LIKE '%int%' 
																														 THEN ''
																													  WHEN Stage.DataType IN ('nvarchar', 'varchar', 'nchar', 'char') AND Stage.CharacterMaximumLenght = -1 
																														 THEN '(MAX)'
																													  WHEN Stage.CharacterMaximumLenght IS NOT NULL 
																														 THEN ' (' + CAST(Stage.CharacterMaximumLenght AS NVARCHAR(50)) + ')'
																													  WHEN Stage.NumericPrecision IS NOT NULL 
																														 THEN ' (' + CAST(Stage.NumericPrecision AS NVARCHAR(50)) + ', ' + CAST(Stage.NumericScale AS NVARCHAR(50))+ ')'
																													  ELSE '' 
																												  END 																																										
											   END + CASE 
														WHEN @DestinationSchema IN ('fact','bridge') AND Stage.ColumnName IN (SELECT ColumnName FROM @PrimaryKeys)
															THEN ' NOT NULL'
														ELSE ''
													 END
                                      + @CRLF
				                
	FROM 
		@InformationSchema AS Stage
	LEFT JOIN 
		(SELECT * FROM @InformationSchema WHERE DatabaseName = 'DW') AS DW 
			ON Stage.ColumnName = DW.ColumnName
	WHERE 
			Stage.DatabaseName = 'Stage' 
		AND DW.ColumnName IS NULL 
		AND Stage.OrdinalPosition = @Counter 
		AND Stage.ColumnName NOT LIKE 'DW%' 
		
	SET @ColumnNameUpdateTable = CONCAT(@ColumnNameUpdateTable,CASE --If the column already exist in @ColumnNameUpdateTable or the DW table a blank is inserted into @ColumnNameUpdateTable
																	WHEN ISNULL(CHARINDEX (REPLACE(@PlaceholderColumnNameUpdateTable,',','') , @ColumnNameUpdateTable),0) <> 0 OR SUBSTRING(@PlaceholderColumnNameUpdateTable,CHARINDEX('[',@PlaceholderColumnNameUpdateTable,0)+1,CASE WHEN CHARINDEX(']',@PlaceholderColumnNameUpdateTable,0) = 0 THEN 0
																																																																						WHEN CHARINDEX(',',@PlaceholderColumnNameUpdateTable,0) = 0  THEN CHARINDEX(']',@PlaceholderColumnNameUpdateTable,0)-2
																																																																						ELSE CHARINDEX(']',@PlaceholderColumnNameUpdateTable,0)-3 
																																																																				   END ) IN (SELECT ColumnName FROM @InformationSchema WHERE DatabaseName = 'DW') THEN '' 
																	ELSE @PlaceholderColumnNameUpdateTable 
															   END)
	
	SET @PlaceholderColumnNameUpdateTable = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1


/**********************************************************************************************************************************************************************
5. Generates the columns for the alter datatype script. If there is a default constraint on the column, the constraint is dropped and recreated
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderColumnNameUpdateTableDataType AS NVARCHAR(MAX) 
DECLARE @ColumnNameUpdateTableDataType AS NVARCHAR(MAX) 

WHILE @Counter <= @Columns

BEGIN

	SELECT @PlaceholderColumnNameUpdateTableDataType = --If there is a constraint the constraint must be droppet
													   CASE 
															WHEN Stage.DefaultConstraintName IS NULL 
																THEN '' 
															ELSE 'ALTER TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].[' + @Table + '] '  + 'DROP CONSTRAINT [' + Stage.DefaultConstraintName + '] ' 
													   END 
												   
													   + @CRLF + 
													   --Alter the column
													   'ALTER TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].[' + @Table + '] '  + 'ALTER COLUMN [' + Stage.ColumnName + '] ' + UPPER(Stage.DataType) +   CASE 
																																																							   WHEN Stage.DataType LIKE '%int%' 
																																																								  THEN ''
																																																							   WHEN Stage.DataType IN ('nvarchar', 'varchar', 'nchar', 'char') AND Stage.CharacterMaximumLenght = -1 
																																																								  THEN '(MAX)'
																																																							   WHEN Stage.CharacterMaximumLenght IS NOT NULL 
																																																								  THEN ' (' + CAST(Stage.CharacterMaximumLenght AS NVARCHAR(50)) + ')'
																																																							   WHEN Stage.NumericPrecision IS NOT NULL 
																																																								  THEN ' (' + CAST(Stage.NumericPrecision AS NVARCHAR(50)) + ', ' + CAST(Stage.NumericScale AS NVARCHAR(50))+ ')'
																																																							   ELSE '' 
																																																						  END + CASE 
																																																									WHEN @DestinationSchema IN ('fact','bridge') AND Stage.ColumnName IN (SELECT ColumnName FROM @PrimaryKeys) 
																																																										THEN ' NOT NULL'
																																																									ELSE ''
																																																								END 
												  
													   + @CRLF +
													   --Add the constraint again
													   CASE 
															WHEN Stage.DefaultConstraintName IS NULL 
																THEN '' 
															ELSE 'ALTER TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].[' + @Table + '] '  + ISNULL('ADD CONSTRAINT [' + Stage.DefaultConstraintName + '] DEFAULT (''' + (SELECT DefaultValue FROM @ColumnDefaults WHERE DataType = CASE WHEN Stage.DataType LIKE 'Date%' THEN 'Date' 
																																																																								   WHEN Stage.DataType LIKE '%char%' THEN 'String'
																																																																								   WHEN Stage.DataType = 'bit' THEN 'Bit'
																																																																								   ELSE 'Number'
																																																																								END) + ''') FOR [' + Stage.ColumnName + ']','')
																																			  
													   END 
												   
													   + @CRLF
                                   
	FROM 
		@InformationSchema Stage
	WHERE 
			Stage.DatabaseName = 'Stage' 
		AND Stage.OrdinalPosition = @Counter 
		AND Stage.ColumnName NOT LIKE '%' + @SurrogateKeySuffix
		AND Stage.PrimaryKey = 0

	SET @ColumnNameUpdateTableDataType = CONCAT(@ColumnNameUpdateTableDataType,@PlaceholderColumnNameUpdateTableDataType)

	SET @PlaceholderColumnNameUpdateTableDataType = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
6. Create Primary Key Columns
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderPrimaryKeyColumns NVARCHAR(MAX)
DECLARE @PrimaryKeyColumns NVARCHAR(MAX)

WHILE @Counter <= @NumberOfPrimaryKeyColumns

BEGIN

	SELECT @PlaceholderPrimaryKeyColumns = CASE WHEN @Counter = 1 THEN '' ELSE ',' END + ColumnName
	FROM 
		@PrimaryKeys
	WHERE
		OrdinalPosition = @Counter

SET @PrimaryKeyColumns = CONCAT(@PrimaryKeyColumns,@PlaceholderPrimaryKeyColumns)

SET @PlaceholderPrimaryKeyColumns = ''

SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
7. Create Primary Key Columns
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderPrimaryDimensionKeyColumns NVARCHAR(MAX)
DECLARE @PrimaryDimensionKeyColumns NVARCHAR(MAX)

WHILE @Counter <= @NumberOfPrimaryDimensionColumns

BEGIN

	SELECT @PlaceholderPrimaryDimensionKeyColumns = CASE WHEN @Counter = 1 THEN '' ELSE ',' END + ColumnName
	FROM 
		@PrimaryDimensionKeys
	WHERE
		OrdinalPosition = @Counter

SET @PrimaryDimensionKeyColumns = CONCAT(@PrimaryDimensionKeyColumns,@PlaceholderPrimaryDimensionKeyColumns)

SET @PlaceholderPrimaryDimensionKeyColumns = ''

SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
8. Drop SCD2 properties
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderSCD2Drop NVARCHAR(MAX)
DECLARE @SCD2Drop NVARCHAR(MAX)

WHILE @Counter <= @NumberOfSCD2ColumnsToDrop

BEGIN

	SELECT @PlaceholderSCD2Drop = 'EXEC [' + @DatabaseNameDW + '].sys.sp_dropextendedproperty @name=N''SCDColumn'',@level0type = N''Schema'', @level0name = ''dim'' ,@level1type = N''Table'',  @level1name = ''' + @Table + ''' ,@level2type = N''Column'', @level2name = ''' + ColumnName + '''' + @CRLF
	FROM 
		@DropSCD2Columns
	WHERE
		OrdinalPosition = @Counter

SET @SCD2Drop = CONCAT(@SCD2Drop,@PlaceholderSCD2Drop)

SET @PlaceholderSCD2Drop = ''

SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
9. Create SCD2 properties
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderSCD2Create NVARCHAR(MAX)
DECLARE @SCD2Create NVARCHAR(MAX)

WHILE @Counter <= @NumberOfSCD2Columns

BEGIN

	SELECT @PlaceholderSCD2Create = 'EXEC [' + @DatabaseNameDW + '].sys.sp_addextendedproperty @name=N''SCDColumn'', @value=N''SCD2'' ,@level0type = N''Schema'', @level0name = ''dim'' ,@level1type = N''Table'',  @level1name = ''' + @Table + ''' ,@level2type = N''Column'', @level2name = ''' + ColumnName + '''' + @CRLF
	FROM 
		@CreateSCD2Columns
	WHERE
		OrdinalPosition = @Counter

SET @SCD2Create = CONCAT(@SCD2Create,@PlaceholderSCD2Create)

SET @PlaceholderSCD2Create = ''

SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
10. Drop PK properties
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderPKDrop NVARCHAR(MAX)
DECLARE @PKDrop NVARCHAR(MAX)

WHILE @Counter <= @NumberOfPrimaryKeyColumnsToDrop

BEGIN

	SELECT @PlaceholderPKDrop = 'EXEC [' + @DatabaseNameDW + '].sys.sp_dropextendedproperty @name=N''PrimaryKeyColumn'',@level0type = N''Schema'', @level0name = ''' + @DestinationSchema + ''' ,@level1type = N''Table'',  @level1name = ''' + @Table + ''' ,@level2type = N''Column'', @level2name = ''' + ColumnName + '''' + @CRLF
	FROM 
		@DropPrimaryKeys
	WHERE
		OrdinalPosition = @Counter

SET @PKDrop = CONCAT(@PKDrop,@PlaceholderPKDrop)

SET @PlaceholderPKDrop = ''

SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
11. Create PK properties
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderPKCreate NVARCHAR(MAX)
DECLARE @PKCreate NVARCHAR(MAX)

WHILE @Counter <= @NumberOfPrimaryKeyColumns

BEGIN

	SELECT @PlaceholderPKCreate = 'EXEC [' + @DatabaseNameDW + '].sys.sp_addextendedproperty @name=N''PrimaryKeyColumn'', @value=N''PK'' ,@level0type = N''Schema'', @level0name = ''' + @DestinationSchema + ''' ,@level1type = N''Table'',  @level1name = ''' + @Table + ''' ,@level2type = N''Column'', @level2name = ''' + ColumnName + '''' + @CRLF
	FROM 
		@CreatePrimaryKeys
	WHERE
		OrdinalPosition = @Counter

SET @PKCreate = CONCAT(@PKCreate,@PlaceholderPKCreate)

SET @PlaceholderPKCreate = ''

SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
12. Fill out the dynamic SQL script variables
***********************************************************************************************************************************************************************/

DECLARE @UpdateTableScript NVARCHAR(MAX) --Variable for the final alter table script for adding columns
DECLARE @UpdatePrimaryKeyScript NVARCHAR(MAX) --Variable for the final create fact primary key script
DECLARE @UpdatePrimaryDimensionKeyScript NVARCHAR(MAX) --Variable for the final create fact primary key script
DECLARE @UpdateDataTypesScript AS NVARCHAR(MAX) --Variable for the final alter table script for changing columns
DECLARE @UpdateIncrementalFlag NVARCHAR(MAX)
DECLARE @DropTruncateBeforeDeploy NVARCHAR(MAX)
DECLARE @CreateTruncateBeforeDeploy NVARCHAR(MAX)

SET @UpdateTableScript = CASE 
							WHEN @PositionFirstChange IS NULL 
								THEN NULL 
							ELSE 'ALTER TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].[' + @Table + ']'  + CHAR(13) + CHAR(10) + 'ADD ' + @ColumnNameUpdateTable 
						 END

SET @UpdatePrimaryKeyScript = IIF(@IsCloudFlag = 1,'','USE [' + @DatabaseNameDW + ']') + @CRLF + 'IF NOT EXISTS(SELECT * FROM sys.indexes WHERE object_id = object_id(''' + @DestinationSchema + '.' + @Table + ''') AND NAME = ''PK_'+ @Table + ''')
							   BEGIN
							   ALTER TABLE  [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].[' + @Table + ']' + @CRLF +
							   'ADD CONSTRAINT PK_' + @Table + ' PRIMARY KEY NONCLUSTERED (' + @PrimaryKeyColumns + ')' + @CRLF +
							   'END'

SET @UpdatePrimaryDimensionKeyScript = IIF(@IsCloudFlag = 1,'','USE [' + @DatabaseNameDW + ']') + @CRLF + 							   
							   'DROP INDEX NCI_' + @Table + ' ON ' + '[' + @DatabaseNameDW + '].[' + @DestinationSchema + '].[' + @Table + ']'  + @CRLF +
							   'CREATE NONCLUSTERED INDEX NCI_' + @Table + ' ON ' +  '[' + @DatabaseNameDW + '].[' + @DestinationSchema + '].[' + @Table + '] (' + @PrimaryDimensionKeyColumns + IIF(@SCD2HistoryFromSourceKey = 1,',' + @Table + 'ValidFromDate)',',DWValidFromDate)') + @CRLF 

SET @UpdateDataTypesScript = @ColumnNameUpdateTableDataType

SET @UpdateIncrementalFlag = IIF(NOT EXISTS (SELECT * FROM @TableIsIncremental) AND @FactIsIncremental = 1,'EXEC [' + @DatabaseNameDW + '].sys.sp_addextendedproperty @name=N''IncrementalFactOrBridgeFlag'', @value=N''1'' ,@level0type = N''Schema'', @level0name = ''' + @DestinationSchema + ''' ,@level1type = N''Table'',  @level1name = ''' + @Table + '''','')
	
SET @DropTruncateBeforeDeploy = IIF(EXISTS(SELECT * FROM @ExistingTruncateProperty),'EXEC [' + @DatabaseNameDW + '].sys.sp_dropextendedproperty @name=N''TruncateBeforeDeploy'',@level0type = N''Schema'', @level0name = ''' + @DestinationSchema + ''' ,@level1type = N''Table'',  @level1name = ''' + @Table + '''','')
SET @CreateTruncateBeforeDeploy = IIF(@CreateTruncateProperty = 1,'EXEC [' + @DatabaseNameDW + '].sys.sp_addextendedproperty @name=N''TruncateBeforeDeploy'',@value = N''True'',@level0type = N''Schema'', @level0name = ''' + @DestinationSchema + ''' ,@level1type = N''Table'',  @level1name = ''' + @Table + '''','')

/**********************************************************************************************************************************************************************
13. Execute dynamic SQL
***********************************************************************************************************************************************************************/

IF @PrintSQL = 0

	BEGIN

		--If an NOT NULL column is added to a fact or bridge the destination table is truncated
		IF @UpdateTableScript LIKE '%NOT NULL%' OR @UpdateTableScript LIKE '%Key]%'--Tables where a NOT NULL column is addded
			BEGIN 
				EXEC('DROP TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].[' + @Table + ']')  
				EXEC meta.[MaintainDWCreateTableAndView] @Table, @DestinationSchema, 0
			END
		ELSE 
			BEGIN
				EXEC(@UpdateTableScript)
				EXEC(@UpdateIncrementalFlag)
				EXEC(@SCD2Drop)
				EXEC(@SCD2Create)
				EXEC(@PKDrop)
				EXEC(@PKCreate)
				EXEC(@UpdateDataTypesScript)
				EXEC(@DropTruncateBeforeDeploy)
				EXEC(@CreateTruncateBeforeDeploy)
			END

		IF @FactIsIncremental = 1 AND  @PrimaryKeyColumns IS NOT NULL AND @LoadPattern = 'Standard'
			BEGIN
				EXEC(@UpdatePrimaryKeyScript)
			END

	END

ELSE

	BEGIN
		
		IF @UpdateTableScript LIKE '%NOT NULL%' OR @UpdateTableScript LIKE '%Key]%'--Tables where a NOT NULL column is addded
			BEGIN 
				PRINT('DROP TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].[' + @Table + ']')  + @CRLF + @CRLF
				EXEC meta.[MaintainDWCreateTableAndView] @Table, @DestinationSchema, 1 
			END
		ELSE 
			BEGIN
				PRINT(@UpdateTableScript) + @CRLF + @CRLF
				PRINT(@UpdateIncrementalFlag) + @CRLF + @CRLF
				PRINT(@SCD2Drop) + @CRLF + @CRLF
				PRINT(@SCD2Create) + @CRLF + @CRLF
				PRINT(@PKDrop) + @CRLF + @CRLF
				PRINT(@PKCreate) + @CRLF + @CRLF
				PRINT(@UpdateDataTypesScript)  + @CRLF + @CRLF
				PRINT(@DropTruncateBeforeDeploy)  + @CRLF + @CRLF
				PRINT(@CreateTruncateBeforeDeploy)  + @CRLF + @CRLF
			END

		IF @FactIsIncremental = 1 AND  @PrimaryKeyColumns IS NOT NULL AND @LoadPattern = 'Standard'
			BEGIN
				PRINT(@UpdatePrimaryKeyScript) + @CRLF + @CRLF
			END

	END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[UpdateFrameworkMetaData]...';


GO


CREATE PROCEDURE [meta].[UpdateFrameworkMetaData]

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/

DECLARE @DatabaseNameDW NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW')
DECLARE @TableName VARCHAR(100)
DECLARE @SurrogateKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'SurrogateKeySuffix')
DECLARE @BusinessKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'BusinessKeySuffix')


/**********************************************************************************************************************************************************************
1. Create Loop counter variables
***********************************************************************************************************************************************************************/

DECLARE @Counter INT
DECLARE @MaxIDFact INT 
DECLARE @MaxIDDim INT 

SELECT 
	@Counter = 1,
	@MaxIDFact = (SELECT MAX(ID) FROM meta.BusinessMatrix WHERE DestinationSchema IN ('fact','bridge')),
	@MaxIDDim  = (SELECT MAX(ID) FROM meta.BusinessMatrix WHERE DestinationSchema IN ('dim'))

/**********************************************************************************************************************************************************************
2. Update BimlMetaData table
***********************************************************************************************************************************************************************/
INSERT INTO meta.FrameworkMetaData
(BusinessMatrixID)

SELECT 
	BusinessMatrix.ID 
FROM 
	meta.BusinessMatrix 
LEFT JOIN 
	meta.FrameworkMetaData 
		ON FrameworkMetaData.BusinessMatrixID = BusinessMatrix.ID 
WHERE 
	FrameworkMetaData.BusinessMatrixID IS NULL
	AND FrameworkMetaData.SourceObjectID IS NULL
	AND FrameworkMetaData.TargetObjectID IS NULL

DELETE
FROM 
	meta.FrameworkMetaData 
WHERE
	BusinessMatrixID NOT IN (SELECT ID FROM meta.BusinessMatrix) AND BusinessMatrixID IS NOT NULL;

/**********************************************************************************************************************************************************************
3. Create and execute etl.LoadFact for all facts and bridges. This poputes the column SQLScript in the businessmatrix with the source script for all facts and bridges.
   The column SQLScripts is created by BIML
***********************************************************************************************************************************************************************/

DECLARE @FactLoadIsIncrementalLoad NVARCHAR(100)
DECLARE @CounterChar NVARCHAR(100)

WHILE @Counter <= @MaxIDFact

BEGIN

	SELECT 
		   @TableName = TableName,
		   @FactLoadIsIncrementalLoad = CAST(FactAndBridgeIncrementalFlag AS VARCHAR(1)),
		   @CounterChar = CAST(@Counter AS VARCHAR(100))
	FROM 
		meta.BusinessMatrix
	WHERE 
			ID = @Counter 
		AND DestinationSchema IN ('fact','bridge')

IF @TableName <> ''

BEGIN

	EXEC('DECLARE	@PrintSQL' + @CounterChar + ' NVARCHAR(MAX)
		  EXEC [meta].[CreateFactSourceScript]
			@Table = N''' + @TableName + ''',
			@PrintSQL = @PrintSQL' + @CounterChar + ' OUTPUT
		  UPDATE FrameworkMetaData
		  SET SQLScript = @PrintSQL' + @CounterChar + '
		  FROM 
				meta.FrameworkMetaData
		  INNER JOIN
				meta.BusinessMatrix
					ON BusinessMatrix.ID = FrameworkMetaData.BusinessMatrixID
		  WHERE TableName = N''' + @TableName + '''')
	END

	SET @TableName = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
4. Update the BusinessMatrix with the sql used in dimension lookup. 
***********************************************************************************************************************************************************************/

DECLARE @InformationSchema TABLE (TableName NVARCHAR(128), ColumnName NVARCHAR(128),DataType NVARCHAR(128))
DECLARE @DimIDColumn NVARCHAR(MAX)
DECLARE @DimKeyColumns NVARCHAR(MAX)
DECLARE @DimComma NVARCHAR(10)

WHILE @Counter <= @MaxIDDim

BEGIN

	SELECT 
		@TableName = TableName
	FROM 
		meta.BusinessMatrix
	WHERE 
		ID = @Counter
		AND DestinationSchema = 'dim' 

IF @TableName <> ''

	BEGIN
			DELETE FROM @InformationSchema

			INSERT @InformationSchema EXEC('SELECT TABLE_NAME
												  ,COLUMN_NAME
												  ,DATA_TYPE
											FROM 
												[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.COLUMNS
											WHERE 
												TABLE_NAME = ''' + @TableName + ''' 
											AND COLUMN_NAME LIKE ''%' + @BusinessKeySuffix + ''' 
											AND TABLE_SCHEMA = ''dim''
											AND COLUMN_NAME NOT IN (''WeekKey'',''MonthKey'',''QuarterKey'')')

			SET @DimIDColumn = @TableName + @SurrogateKeySuffix

				SELECT
					  @DimKeyColumns = COALESCE(@DimKeyColumns + ', ','') + CASE 
																				WHEN DataType LIKE '%char%' 
																					THEN 'UPPER(' + ColumnName + ') AS [' + ColumnName + ']'
																				ELSE ColumnName 
																			END
				FROM 
					@InformationSchema
				WHERE 
					TableName = @TableName

				SET @DimComma = CASE 
									WHEN @Counter = 1 
										THEN ', ' 
									ELSE '' 
								END

				EXEC('UPDATE FrameworkMetaData
					  SET SQLScript = ''SELECT ' + @DimIDColumn + @DimComma + @DimKeyColumns + ' FROM dim.' + @TableName + '''
					  FROM 
							meta.FrameworkMetaData
					  INNER JOIN
							meta.BusinessMatrix
								ON BusinessMatrix.ID = FrameworkMetaData.BusinessMatrixID
					  WHERE TableName = ''' + @TableName + ''' AND DestinationSchema = ''dim''')

	END

	SET @Counter = @Counter + 1

	SET @DimIDColumn = ''
	SET @DimKeyColumns = ''
	SET @TableName = ''

END

SET @Counter = 1


/**********************************************************************************************************************************************************************
5. Create the dataset with all relations in the DW. The table DWRelations is created by BIML.
***********************************************************************************************************************************************************************/

IF OBJECT_ID('meta.DWRelations', 'U') IS NOT NULL 

TRUNCATE TABLE meta.DWRelations

WHILE @Counter <= @MaxIDFact

BEGIN

	SELECT 
			@TableName = TableName

	FROM 
		meta.BusinessMatrix
	WHERE 
			ID = @Counter 
		AND DestinationSchema IN ('fact','bridge')

IF @TableName <> ''

BEGIN

INSERT meta.[DWRelations]
EXEC meta.CreateDWRelations @Table = @TableName

END

SET @Counter = @Counter + 1

SET @TableName = ''


END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[MaintainDW]...';


GO

/**********************************************************************************************************************************************************************
The purpose of this scripts is execute the maintaindw scripts in the correct order
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[MaintainDW]

@MasterTable VARCHAR(100),
@MasterDestinationSchema VARCHAR(10)

AS

SET NOCOUNT ON

DECLARE @DatabaseNameDW NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW')
DECLARE @ViewName AS VARCHAR(MAX) = meta.SplitCamelCase(@MasterTable)
DECLARE @DropTableFlag BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'MaintainDWDropTableFlag')
DECLARE @DropViewFlag BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'MaintainDWDropViewFlag')
DECLARE @UpdateViewFlag BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'MaintainDWUpdateViewFlag')
DECLARE @TableExists TABLE (TABLE_NAME VARCHAR(50)) --Table variable used to check if the table exists in the DW
DECLARE @TempTableExists TABLE (TABLE_NAME VARCHAR(50)) --Table variable used to check if the table exists in the DW
DECLARE @ViewExists TABLE (TABLE_NAME VARCHAR(50)) --Table variable used to check if the table exists in the DW
DECLARE @TempViewExists TABLE (TABLE_NAME VARCHAR(50)) --Table variable used to check if the table exists in the DW
DECLARE @IsCloudFlag BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'IsCloudFlag')
DECLARE @ExistsInBM BIT = (SELECT IIF(TableName IS NULL,0,1) FROM meta.BusinessMatrix WHERE DestinationSchema = @MasterDestinationSchema AND TableName = @MasterTable)

INSERT @TableExists EXEC('SELECT TABLE_NAME FROM [' + @DatabaseNameDW + '].INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''' + @MasterTable + ''' AND TABLE_SCHEMA = ''' + @MasterDestinationSchema + '''')

INSERT @TempTableExists EXEC('SELECT TABLE_NAME FROM [' + @DatabaseNameDW + '].INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''' + @MasterTable + '_Temp'' AND TABLE_SCHEMA = ''' + @MasterDestinationSchema + '''')

INSERT @ViewExists EXEC('SELECT TABLE_NAME FROM [' + @DatabaseNameDW + '].INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''' + @ViewName + ''' AND TABLE_SCHEMA = ''' + @MasterDestinationSchema + 'View''')

INSERT @TempViewExists EXEC('SELECT TABLE_NAME FROM [' + @DatabaseNameDW + '].INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''' + @ViewName + '_Temp'' AND TABLE_SCHEMA = ''' + @MasterDestinationSchema + 'View''')


/**********************************************************************************************************************************************************************
1. Drop table and view
***********************************************************************************************************************************************************************/
IF @ExistsInBM = 1 --SafetyNet in order to prevent the procedure to run in production
	BEGIN
		IF @DropTableFlag = 1 AND EXISTS(SELECT * FROM @TableExists)               
			BEGIN
				EXEC('DROP TABLE [' + @DatabaseNameDW + '].[' +  @MasterDestinationSchema + '].[' + @MasterTable + ']')
			END

		IF @DropTableFlag = 1 AND EXISTS(SELECT * FROM @TempTableExists)               
			BEGIN
				EXEC('DROP TABLE [' + @DatabaseNameDW + '].[' +  @MasterDestinationSchema + '].[' + @MasterTable + '_Temp]')
			END

		IF @DropViewFlag = 1 AND EXISTS (SELECT * FROM @ViewExists)

			DECLARE @DropViewSQL NVARCHAR(MAX) = IIF(@IsCloudFlag = 1,'','USE [' + @DatabaseNameDW + ']') + 'DROP VIEW [' +  @MasterDestinationSchema + 'View].[' + @ViewName + ']'

			BEGIN
				EXEC(@DropViewSQL)
			END

		IF @DropViewFlag = 1 AND EXISTS (SELECT * FROM @TempViewExists)
		
			DECLARE @DropTempViewSQL NVARCHAR(MAX) = IIF(@IsCloudFlag = 1,'','USE [' + @DatabaseNameDW + ']') + 'DROP VIEW [' +  @MasterDestinationSchema + 'View].[' + @ViewName + '_Temp]'

			BEGIN
				EXEC(@DropTempViewSQL)
			END

		--Repopulate @TableExists and @ViewExists after potential drop
		DELETE FROM @TableExists
		DELETE FROM @ViewExists

		INSERT @TableExists EXEC('SELECT TABLE_NAME FROM [' + @DatabaseNameDW + '].INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''' + @MasterTable + ''' AND TABLE_SCHEMA = ''' + @MasterDestinationSchema + '''')
		INSERT @ViewExists EXEC('SELECT TABLE_NAME FROM [' + @DatabaseNameDW + '].INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''' + @ViewName + ''' AND TABLE_SCHEMA = ''' + @MasterDestinationSchema + 'View''')

/**********************************************************************************************************************************************************************
2. Execute 
***********************************************************************************************************************************************************************/


		IF NOT EXISTS (SELECT * FROM @ViewExists) AND EXISTS(SELECT * FROM @TableExists) --If table exists and view doesn't the table has to be updated prior to the view is created

			BEGIN
				EXECUTE meta.[MaintainDWUpdateTable] @Table = @MasterTable, @DestinationSchema = @MasterDestinationSchema, @PrintSQL = 0
				EXECUTE meta.[MaintainDWCreateTableAndView] @Table = @MasterTable,@DestinationSchema = @MasterDestinationSchema, @PrintSQL = 0

				IF @UpdateViewFlag = 1
					BEGIN
						EXECUTE meta.[MaintainDWUpdateView] @Table = @MasterTable, @DestinationSchema = @MasterDestinationSchema, @PrintSQL = 0
					END
			END

		ELSE
			BEGIN
				EXECUTE meta.[MaintainDWCreateTableAndView] @Table = @MasterTable,@DestinationSchema = @MasterDestinationSchema, @PrintSQL = 0
				EXECUTE meta.[MaintainDWUpdateTable] @Table = @MasterTable, @DestinationSchema = @MasterDestinationSchema, @PrintSQL = 0
				IF @UpdateViewFlag = 1
					BEGIN
						EXECUTE meta.[MaintainDWUpdateView] @Table = @MasterTable, @DestinationSchema = @MasterDestinationSchema, @PrintSQL = 0
					END
			END
	END
ELSE
	BEGIN
		PRINT('No entry in Business Matrix')
	END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[LoadDimension]...';


GO


/**********************************************************************************************************************************************************************
The purpose of this scripts is to create and execute the merge join statement between stage tables and dimensions. The script has the following charateristics:
- All columns is by default treated as SCD1.
- If a column is entered into the table etl.BusinessMatrixSCDSetup the column is treated as SCD2
- NULL values is changed to the default value entered ind the table application.Variables 
- The dimension unknown value is dropped and re-created to make sure there is no empty columns
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[LoadDimension]

@Table  NVARCHAR(100), --Input is the dimensions name without schema
@LoadIsIncremental BIT,
@DisableMaintainDWFlag BIT,
@PrintSQL BIT

AS

SET NOCOUNT ON

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/
DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10) --Linebreak
DECLARE @DatabaseNameStage NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameStage')
DECLARE @DatabaseNameDW NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW')
DECLARE @SurrogateKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'SurrogateKeySuffix')
DECLARE @BusinessKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'BusinessKeySuffix')
DECLARE @FactEngineIsSQLFlag BIT = IIF((SELECT VariableValue FROM meta.Variables WHERE VariableName = 'FactLoadEngine') = 'SQL',1,0)
DECLARE @IsCloudFlag BIT = IIF((SELECT VariableValue FROM meta.Variables WHERE VariableName = 'IsCloudFlag') = '1',1,0)
DECLARE @StageSchemaTable TABLE (SchemaName NVARCHAR(10)) 
INSERT @StageSchemaTable EXEC('SELECT DISTINCT TABLE_SCHEMA FROM [' + @DatabaseNameStage + '].INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''' + @Table + ''' AND TABLE_SCHEMA IN (''dbo'',''stage'')')
DECLARE @StageSchema NVARCHAR(10) = (SELECT IIF(@IsCloudFlag = 1,'stage',(SELECT SchemaName FROM @StageSchemaTable))) --If on-premise and stageschema has not been changed

/**********************************************************************************************************************************************************************
Execute MaintainDW if LoadEngine is SQL
***********************************************************************************************************************************************************************/
IF @IsCloudFlag = 1 AND @DisableMaintainDWFlag = 0
	BEGIN
		EXEC meta.MaintainDW @MasterTable = @Table, @MasterDestinationSchema = 'dim'
		WAITFOR DELAY '00:00:02' --To prevent deadlock when running the procedure in parallel
	END

/**********************************************************************************************************************************************************************
1. Create and insert data into table variables
**********************************************************************************************************************************************************************/

DECLARE @InformationSchema TABLE (DatabaseName NVARCHAR(128), TableName NVARCHAR(128), ColumnName NVARCHAR(128), OrdinalPosition INT, DataType NVARCHAR(128))
DECLARE @SCD2Columns TABLE (SCD2Columns NVARCHAR(500))
DECLARE @ColumnDefaults TABLE (DataType NVARCHAR(50),DefaultValue NVARCHAR(250))

/*Generates a dataset with the combined information schema*/
INSERT @InformationSchema EXEC(
							'SELECT 
								 ''Stage'' AS DatabaseName
								,TABLE_NAME
								,COLUMN_NAME
								,ORDINAL_POSITION
								,DATA_TYPE
							 FROM 
								[' + @DatabaseNameStage + '].INFORMATION_SCHEMA.COLUMNS
							 WHERE 
								TABLE_NAME = ''' + @Table + ''' 
								AND COLUMN_NAME NOT LIKE ''DW%'' 
								AND	TABLE_SCHEMA = ''' + @StageSchema + '''


							 UNION ALL

							 SELECT  
								 ''DW'' AS DatabaseName
								,TABLE_NAME
								,COLUMN_NAME
								,ORDINAL_POSITION
								,DATA_TYPE
							 FROM 
								[' + @DatabaseNameDW + '].INFORMATION_SCHEMA.COLUMNS
							 WHERE 
								TABLE_NAME = ''' + @Table + ''' 
								AND	TABLE_SCHEMA = ''dim'''
						)

/*Generates a dataset with the SCD2 columns*/
INSERT @SCD2Columns	EXEC('  SELECT DISTINCT
								all_columns.name 
							FROM
								[' + @DatabaseNameDW + '].sys.tables
							INNER JOIN 
								[' + @DatabaseNameDW + '].sys.schemas
									ON schemas.schema_id = tables.schema_id
							INNER JOIN 
								[' + @DatabaseNameDW + '].sys.all_columns 
									ON all_columns.object_id=tables.object_id
							INNER JOIN 
								[' + @DatabaseNameDW + '].sys.extended_properties
									ON extended_properties.major_id=tables.object_id 
									AND extended_properties.minor_id=all_columns.column_id 
									AND extended_properties.class=1
							WHERE
								extended_properties.name = ''SCDColumn''
								AND schemas.name = ''dim''
								AND tables.name = ''' + @Table + '''')

/*Generates a dataset with the column default values*/
INSERT @ColumnDefaults EXEC('SELECT REPLACE([name],''Default'','''') AS DataType
								   ,CONVERT(NVARCHAR(128),value) AS DefaultValue
							 FROM 
								sys.extended_properties
							 WHERE 
								[name] IN (''DefaultDate'',''DefaultDimensionMemberID'',''DefaultNumber'',''DefaultString'',''DefaultBit'')')


/**********************************************************************************************************************************************************************
2. Create Loop counter variables and SCD2HistoryVariable
**********************************************************************************************************************************************************************/

DECLARE @Counter INT --Just a counter
DECLARE @NumberOfColumnsStage INT --Number of columns from stage
DECLARE @NumberOfColumnsDim INT --Number of columns from dim
DECLARE @NumberOfColumnsSCD1 INT --Number of SCD1 columns
DECLARE @NumberOfColumnsNonKeySCD1 INT --Number of SCD1 nonkey columns
DECLARE @NumberOfColumnsSCD2 INT --Number of SCD2 columns
DECLARE @NumberOfKeyColumns INT --Number of key columns
DECLARE @SCD2HistoryFromSourceKey NVARCHAR(MAX) --If the dimension has the following columns DimensionNameIsCurrent, DimensionNameValidFromDate and DimensionNameValidToDate SCD2 history is created in the source

SELECT 
	@Counter = 1,
	@NumberOfKeyColumns = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE DatabaseName = 'Stage' AND ColumnName LIKE '%' + @BusinessKeySuffix),
	@NumberOfColumnsStage = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE DatabaseName = 'Stage'),
	@NumberOfColumnsDim =  (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE DatabaseName = 'DW'),
	@NumberOfColumnsSCD1 = (SELECT MAX(OrdinalPosition) FROM @InformationSchema AS InformationSchema LEFT JOIN @SCD2Columns AS SCD ON SCD.SCD2Columns = InformationSchema.ColumnName WHERE DatabaseName = 'Stage' AND SCD.SCD2Columns IS NULL),
	@NumberOfColumnsNonKeySCD1 = (SELECT MAX(OrdinalPosition) FROM @InformationSchema AS InformationSchema LEFT JOIN @SCD2Columns AS SCD ON SCD.SCD2Columns = InformationSchema.ColumnName WHERE DatabaseName = 'Stage' AND SCD.SCD2Columns IS NULL AND InformationSchema.ColumnName NOT LIKE '%' + @BusinessKeySuffix),
	@NumberOfColumnsSCD2 = (SELECT MAX(OrdinalPosition) FROM @InformationSchema AS InformationSchema INNER JOIN @SCD2Columns SCD ON SCD.SCD2Columns = InformationSchema.ColumnName WHERE DatabaseName = 'Stage'),
	@SCD2HistoryFromSourceKey = (SELECT IIF(COUNT(ColumnName) = 3, ' AND [source].[' + @Table + 'ValidFromDate] = [target].[' + @Table + 'ValidFromDate]', NULL) FROM @InformationSchema WHERE REPLACE(ColumnName,@Table,'') IN ('IsCurrent', 'ValidFromDate', 'ValidToDate') AND DatabaseName = 'Stage' )


/**********************************************************************************************************************************************************************
3. Create Merge Keys part and Merge Ouput part
**********************************************************************************************************************************************************************/

DECLARE @PlaceholderKeys NVARCHAR(MAX) --Placeholder used in the loop generating the business keys used in the Merge Join script
DECLARE @Keys NVARCHAR(MAX) --Holds the value of @PlaceholderKeys for each loop
DECLARE @PlaceholderMergeOutput NVARCHAR(MAX) --Placeholder for the MergeOutput part of the script
DECLARE @MergeOutput NVARCHAR(MAX) --Holds the value of @PlaceholderMergeOutput for each loop

WHILE @Counter <= @NumberOfKeyColumns BEGIN

	SELECT 
		@PlaceholderKeys = '[source].[' + ColumnName + '] = [target].[' + ColumnName + ']'  + CASE WHEN @Counter != @NumberOfKeyColumns THEN ' AND ' ELSE '' END,
		@PlaceholderMergeOutput = 'MERGE_OUTPUT.[' + ColumnName + '] IS NOT NULL'  + CASE WHEN @Counter != @NumberOfKeyColumns THEN ' AND ' ELSE '' END  
	FROM 
		@InformationSchema 
	WHERE 
		DatabaseName = 'Stage' and
		ColumnName LIKE '%' + @BusinessKeySuffix and
		OrdinalPosition = @Counter

	SET @Keys = CONCAT(@Keys,@PlaceholderKeys)
	SET @MergeOutput = CONCAT(@MergeOutput,@PlaceholderMergeOutput)

	SET @PlaceholderKeys = ''
	SET @PlaceholderMergeOutput = ''

	SET @Counter = @Counter + 1

END

SET @Keys = @Keys + ISNULL(@SCD2HistoryFromSourceKey,'') --If SCD2 history is created in source ValidFromDate is used as key

SET @Counter = 1

/**********************************************************************************************************************************************************************
4. Create Column from Source part which handles null values, columns from stage and output column part
**********************************************************************************************************************************************************************/

DECLARE @PlaceholderColumnNameStage NVARCHAR(MAX) 
DECLARE @ColumnNameStage NVARCHAR(MAX) 
DECLARE @PlaceholderColumnNameSource NVARCHAR(MAX) 
DECLARE @ColumnNameSource NVARCHAR(MAX) 
DECLARE @PlaceholderOutput NVARCHAR(MAX) 
DECLARE @Output NVARCHAR(MAX) 

WHILE @Counter <= @NumberOfColumnsStage BEGIN 

	SELECT 
		@PlaceholderColumnNameSource = 
			CASE 
				WHEN DataType LIKE '%char%' AND ColumnName NOT LIKE '%' + @BusinessKeySuffix AND ColumnName NOT LIKE '%Code'
				THEN 'ISNULL([' + ColumnName + '],''' + (SELECT DefaultValue FROM @ColumnDefaults WHERE DataType = 'String') + ''') AS [' + ColumnName + ']'
				WHEN DataType IN ('int','tinyint','bigint','smallint','decimal','numeric','float','double','money') AND ColumnName NOT LIKE '%' + @BusinessKeySuffix AND ColumnName NOT LIKE '%Code'
				THEN 'ISNULL([' + ColumnName + '],''' + (SELECT DefaultValue FROM @ColumnDefaults WHERE DataType = 'Number') + ''') AS [' + ColumnName + ']'
				WHEN DataType LIKE '%date%' AND ColumnName NOT LIKE '%' + @BusinessKeySuffix AND ColumnName NOT LIKE '%Code'
				THEN 'ISNULL([' + ColumnName + '],''' + (SELECT DefaultValue FROM @ColumnDefaults WHERE DataType = 'Date') + ''') AS [' + ColumnName + ']'
				WHEN DataType = 'bit' AND ColumnName NOT LIKE '%' + @BusinessKeySuffix AND ColumnName NOT LIKE '%Code'
				THEN 'ISNULL([' + ColumnName + '],''' + (SELECT DefaultValue FROM @ColumnDefaults WHERE DataType = 'Bit') + ''') AS [' + ColumnName + ']'
				WHEN ColumnName LIKE '%Code'
				THEN 'ISNULL([' + ColumnName + '],''' + (SELECT DefaultValue FROM @ColumnDefaults WHERE DataType = 'DimensionMemberID') + ''') AS [' + ColumnName + ']'
				ELSE '[' + ColumnName + ']' 
			END + 
			CASE 
				WHEN @Counter != @NumberOfColumnsStage 
				THEN ',' 
				ELSE '' 
			END + @CRLF,
		@PlaceholderColumnNameStage = 
			'[' + ColumnName + ']' + 
			CASE 
				WHEN @Counter != @NumberOfColumnsStage 
				THEN ',' 
				ELSE '' 
			END + @CRLF,
		@PlaceholderOutput = 
			'[source].[' + ColumnName + '] AS [' + ColumnName +']' + 
			CASE 
				WHEN @Counter != @NumberOfColumnsStage 
				THEN ', ' 
				ELSE '' 
			END + @CRLF    
	FROM 
		@InformationSchema
	WHERE 
		DatabaseName = 'Stage' and
		OrdinalPosition = @Counter

	SET @ColumnNameSource = CONCAT(@ColumnNameSource,@PlaceholderColumnNameSource)
	SET @PlaceholderColumnNameSource = ''
	SET @ColumnNameStage = CONCAT(@ColumnNameStage,@PlaceholderColumnNameStage)
	SET @PlaceholderColumnNameStage = ''
	SET @Output = CONCAT(@Output,@PlaceholderOutput)
	SET @PlaceholderOutput = ''
	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
5.Create update part and match part for SCD1 columns
**********************************************************************************************************************************************************************/

DECLARE @PlaceholderUpdateSCD1 NVARCHAR(MAX) 
DECLARE @UpdateSCD1 NVARCHAR(MAX) 
DECLARE @PlaceholderMatchSCD1 NVARCHAR(MAX) 
DECLARE @MatchSCD1 NVARCHAR(MAX) 

WHILE @Counter <= @NumberOfColumnsStage BEGIN 

	SELECT 
		@PlaceholderMatchSCD1 =  
			'([target].[' + ColumnName + '] <> [source].[' + ColumnName + ']) OR ([target].[' + ColumnName + '] IS NULL AND [source].[' + ColumnName + '] IS NOT NULL) OR ([target].[' + ColumnName + '] IS NOT NULL AND [source].[' + ColumnName + '] IS NULL)' + 
			CASE 
				WHEN @Counter != @NumberOfColumnsNonKeySCD1 
				THEN ' OR ' 
				ELSE '' 
			END +  @CRLF ,
		@PlaceholderUpdateSCD1 = 
			'[target].[' + ColumnName + '] = [source].[' + ColumnName + '],' +  @CRLF
	FROM 
		@InformationSchema AS InformationSchema 
	LEFT JOIN 
		@SCD2Columns AS SCD ON 
			SCD.SCD2Columns = InformationSchema.ColumnName
	WHERE 
		DatabaseName = 'Stage' and
		OrdinalPosition = @Counter and
		SCD.SCD2Columns IS NULL and 
		ColumnName NOT LIKE '%' + @BusinessKeySuffix

	SET @MatchSCD1 = CONCAT(@MatchSCD1,@PlaceholderMatchSCD1)
	SET @PlaceholderMatchSCD1 = ''
	SET @UpdateSCD1 = CONCAT(@UpdateSCD1,@PlaceholderUpdateSCD1)
	SET @PlaceholderUpdateSCD1 = ''
	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
6.Create match part for SCD2 columns
**********************************************************************************************************************************************************************/

DECLARE @PlaceholderMatchSCD2 NVARCHAR(MAX) 
DECLARE @MatchSCD2 NVARCHAR(MAX) 

WHILE @Counter <= @NumberOfColumnsStage BEGIN 

	SELECT 
		@PlaceholderMatchSCD2 =  
			'([target].[' + ColumnName + '] <> [source].[' + ColumnName + '] OR ([target].[' + ColumnName + '] IS NULL AND [source].[' + ColumnName + '] IS NOT NULL) OR ([target].[' + ColumnName + '] IS NOT NULL AND [source].[' + ColumnName + '] IS NULL))' + 
			CASE 
				WHEN @Counter != @NumberOfColumnsSCD2 
				THEN ' OR ' 
				ELSE '' 
			END + @CRLF
	FROM 
		@InformationSchema AS InformationSchema 
	INNER JOIN
		@SCD2Columns AS SCD on
			SCD.SCD2Columns = InformationSchema.ColumnName
	WHERE 
		DatabaseName = 'Stage' and
		OrdinalPosition = @Counter

	SET @MatchSCD2 = CONCAT(@MatchSCD2,@PlaceholderMatchSCD2)
	SET @PlaceholderMatchSCD2 = ''
	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
7. Create columns for insert unknown value
**********************************************************************************************************************************************************************/

DECLARE @PlaceholderColumnUnknownValue NVARCHAR(MAX) 
DECLARE @ColumnUnknownValue NVARCHAR(MAX) 

WHILE @Counter <= @NumberOfColumnsDim BEGIN 

	SELECT 
		@PlaceholderColumnUnknownValue =
			',''' + 
			CASE 
				WHEN ColumnDefaults.DefaultValue IS NOT NULL THEN ColumnDefaults.DefaultValue								
				WHEN InformationSchema.DataType = 'uniqueidentifier' THEN 'GUID'                                           
				ELSE ''
			END + '''' + @CRLF 
	FROM 
		@InformationSchema AS InformationSchema LEFT JOIN 
		@ColumnDefaults AS ColumnDefaults ON 
			ColumnDefaults.DataType = 
			CASE 
				WHEN InformationSchema.DataType LIKE 'Date%' THEN 'Date' 
				WHEN InformationSchema.DataType LIKE '%char%' THEN 'String'
				WHEN InformationSchema.DataType = 'bit'THEN 'Bit' 
				WHEN ColumnName LIKE '%Key' OR ColumnName LIKE '%Code' THEN 'DimensionMemberID'
				WHEN InformationSchema.DataType = 'uniqueidentifier' THEN 'GUID' 
				ELSE 'Number'
			END
	WHERE 
		DatabaseName = 'Stage' AND 
		OrdinalPosition = @Counter

	SET @ColumnUnknownValue = CONCAT(@ColumnUnknownValue,@PlaceholderColumnUnknownValue)
	SET @PlaceholderColumnUnknownValue = ''
	SET @Counter = @Counter + 1

END

/**********************************************************************************************************************************************************************
8. Fill out the dynamic SQL script variables
**********************************************************************************************************************************************************************/

DECLARE @InsertUnknownScript NVARCHAR(MAX) 
DECLARE @ParametersScript NVARCHAR(MAX) 
DECLARE @SCD1Script NVARCHAR(MAX)
DECLARE @SCD2Script NVARCHAR(MAX) 
DECLARE @SCDFullScript NVARCHAR(MAX) 

-- Insert unknown
SET @InsertUnknownScript = '
SET IDENTITY_INSERT [' + @DatabaseNameDW + '].[dim].[' + @Table + '] ON

DELETE FROM [' + @DatabaseNameDW + '].[dim].[' + @Table + '] WHERE ' + @Table + @SurrogateKeySuffix + ' = ' + (SELECT DefaultValue FROM @ColumnDefaults WHERE DataType = 'DimensionMemberID') + '
INSERT [' + @DatabaseNameDW + '].[dim].[' + @Table + '] (' + @CRLF +
	'[' + @Table + @SurrogateKeySuffix + '],' + @CRLF  +
	@ColumnNameStage + '
	,[DWIsCurrent]
	,[DWValidFromDate]
	,[DWValidToDate]
	,[DWCreatedDate]
	,[DWModifiedDate]
	,[DWIsDeleted]
)
SELECT ' + 
	(SELECT DefaultValue FROM @ColumnDefaults WHERE DataType = 'DimensionMemberID') + @CRLF +
	 REPLACE(@ColumnUnknownValue, '''GUID''','NEWID()') + '
	,1
	,''1900-01-01''
	,''9999-12-31''
	,GETDATE()
	,GETDATE()
	,0

SET IDENTITY_INSERT [' + @DatabaseNameDW + '].[dim].[' + @Table + '] OFF
'

-- Set parameters
SET @ParametersScript = '
DECLARE @CurrentDateTime datetime
DECLARE @MinDateTime datetime
DECLARE @MaxDateTime datetime
DECLARE @BooleanTrue bit
DECLARE @BooleanFalse bit
DECLARE @DateToDateTime datetime

SELECT
	@CurrentDateTime = cast(getdate() as datetime),
	@MinDateTime = cast(''1900-01-01'' as datetime),
	@MaxDateTime = cast(''9999-12-31'' as datetime),
	@BooleanTrue = cast(1 as bit),
	@BooleanFalse = cast(0 as bit),
	@DateToDateTime = dateadd(ms,-3,  getdate())
'

-- SCD 1
SET @SCD1Script = 

'
-- ==================================================
-- SCD1
-- ==================================================

MERGE [' + @DatabaseNameDW + '].[dim].['+ @Table + '] as [target] USING
(

SELECT 
' + @ColumnNameSource + 'FROM [' + @DatabaseNameStage + '].[' + @StageSchema + '].[' + @Table + '] 

) as [source]

-- Selects source rows in order to compare them to [target]

ON
(
' + @Keys + '
)

WHEN NOT MATCHED BY TARGET THEN

INSERT 
(
' + @ColumnNameStage + 
',[DWIsCurrent]
,[DWValidFromDate]
,[DWValidToDate]
,[DWCreatedDate]
,[DWModifiedDate]
,[DWIsDeleted]
)

VALUES 
(
' + @ColumnNameStage + 
',@BooleanTrue
,@MinDateTime
,@MaxDateTime
,@CurrentDateTime
,@CurrentDateTime
,@BooleanFalse
)
'
+ CASE WHEN @NumberOfColumnsNonKeySCD1 IS NULL THEN '' ELSE 'WHEN MATCHED AND 
(
' + @MatchSCD1 +')

THEN UPDATE

SET 
'+  @UpdateSCD1 + '[target].[DWModifiedDate] = @CurrentDateTime
' END

+ CASE WHEN @LoadIsIncremental = 1 THEN '' ELSE '
WHEN NOT MATCHED BY SOURCE AND 
[target].[' + @Table + @SurrogateKeySuffix + '] > 0
AND 
(
([DWIsCurrent] = @BooleanTrue OR ([DWIsCurrent] IS NULL AND @BooleanTrue IS NULL))
)
THEN UPDATE

SET
[target].[DWIsDeleted] = @BooleanTrue
' END + ';'

--SCD 2
SET @SCD2Script =
'

-- ==================================================
-- SCD2
-- ==================================================

INSERT INTO [' + @DatabaseNameDW + '].[dim].[' + @Table +']
(' + @ColumnNameStage + 
',[DWIsCurrent]
,[DWValidFromDate]
,[DWValidToDate]
,[DWCreatedDate]
,[DWModifiedDate]
,[DWIsDeleted]
)
SELECT 
' + @ColumnNameStage + 
',[DWIsCurrent]
,[DWValidFromDate]
,[DWValidToDate]
,[DWCreatedDate]
,[DWModifiedDate]
,[DWIsDeleted]
FROM
(
MERGE [' + @DatabaseNameDW + '].[dim].[' + @Table +'] as [target]
USING
(
SELECT 
' + @ColumnNameSource + 'FROM  [' + @DatabaseNameStage + '].[' + @StageSchema + '].[' + @Table + ']
	) as [source]
	
ON
(
' + @Keys + '
)

WHEN NOT MATCHED BY TARGET

THEN INSERT
(' + @ColumnNameStage + 
',[DWIsCurrent]
,[DWValidFromDate]
,[DWValidToDate]
,[DWCreatedDate]
,[DWModifiedDate]
,[DWIsDeleted])

VALUES
(' + @ColumnNameStage + ',@BooleanTrue
,@MinDateTime
,@MaxDateTime
,@CurrentDateTime
,@CurrentDateTime
,@BooleanFalse
	)

WHEN MATCHED AND
(
([DWIsCurrent] = @BooleanTrue OR ([DWIsCurrent] IS NULL AND @BooleanTrue IS NULL))
)
AND
( ' + @MatchSCD2 + ' )

THEN UPDATE
SET  	[DWIsCurrent] = @BooleanFalse,
		[DWValidToDate] = @DateToDateTime
	
OUTPUT $Action as [MERGE_ACTION_942b9586-8926-4710-a7b0-9eb75b98f9b0],
' + @Output + ',@BooleanTrue AS [DWIsCurrent], 
@CurrentDateTime AS [DWValidFromDate],
@MaxDateTime AS [DWValidToDate],
@CurrentDateTime AS [DWCreatedDate],
@CurrentDateTime AS [DWModifiedDate],
@BooleanFalse AS [DWIsDeleted]

)MERGE_OUTPUT
WHERE MERGE_OUTPUT.[MERGE_ACTION_942b9586-8926-4710-a7b0-9eb75b98f9b0] = ''UPDATE''
	AND ' + @MergeOutput + '
;
'

SET @SCDFullScript = CONCAT(@ParametersScript,CASE WHEN @NumberOfColumnsSCD1 IS NULL THEN NULL ELSE @SCD1Script END,CASE WHEN @NumberOfColumnsSCD2 IS NULL THEN NULL ELSE @SCD2Script END)

/**********************************************************************************************************************************************************************
9. Execute dynamic SQL script variables
**********************************************************************************************************************************************************************/

IF @PrintSQL = 0

	BEGIN

		EXEC(@InsertUnknownScript)
		EXEC(@SCDFullScript)

	END

ELSE

	BEGIN
PRINT(@InsertUnknownScript) + @CRLF + @CRLF
		PRINT(@ParametersScript) + @CRLF + @CRLF
		PRINT(CASE WHEN @NumberOfColumnsSCD1 IS NULL THEN NULL ELSE LEFT(@SCD1Script,4000) END) + @CRLF + @CRLF
		PRINT(CASE WHEN @NumberOfColumnsSCD1 IS NULL THEN NULL ELSE SUBSTRING(@SCD1Script,4001,8000) END) + @CRLF + @CRLF
		PRINT(CASE WHEN @NumberOfColumnsSCD1 IS NULL THEN NULL ELSE SUBSTRING(@SCD1Script,8001,12000)  END) + @CRLF + @CRLF
		PRINT(CASE WHEN @NumberOfColumnsSCD1 IS NULL THEN NULL ELSE SUBSTRING(@SCD1Script,12001,16000) END) + @CRLF + @CRLF
		PRINT(CASE WHEN @NumberOfColumnsSCD2 IS NULL THEN NULL ELSE LEFT(@SCD2Script,4000) END) + @CRLF + @CRLF
		PRINT(CASE WHEN @NumberOfColumnsSCD2 IS NULL THEN NULL ELSE SUBSTRING(@SCD2Script,4001,8000)  END) + @CRLF + @CRLF
		PRINT(CASE WHEN @NumberOfColumnsSCD2 IS NULL THEN NULL ELSE SUBSTRING(@SCD2Script,8001,12000)  END) + @CRLF + @CRLF
		PRINT(CASE WHEN @NumberOfColumnsSCD2 IS NULL THEN NULL ELSE SUBSTRING(@SCD2Script,12001,16000) END)
	END

SET NOCOUNT OFF
GO
PRINT N'Creating [meta].[LoadFact]...';


GO
/**********************************************************************************************************************************************************************
The purpose of this scripts is to create the SQL for fact and bridge loads
***********************************************************************************************************************************************************************/

CREATE PROCEDURE [meta].[LoadFact]
 
@Table NVARCHAR(128),--Input is the fact name without schema
@DestinationSchema NVARCHAR(10),--Input is fact og bridge schema
@LoadPattern NVARCHAR(50),--Input is the load pattern stated in the businessmatrix
@IncrementalFlag BIT, --Input is 1 if the load is incremental and 0 if it is a full load
@CleanUpPartitionsFlag BIT, --Input is 1 if you want to bypass the temp table in order du clean up add partitions in the cube else 0
@DisableMaintainDWFlag BIT, --Input is 1 if you want to bypass MaintainDW else 0. In job the parameter should always be 1
@PrintSQL BIT--Input is 1 if you want to Print the dynamic SQL

AS

/**********************************************************************************************************************************************************************
Support variables
***********************************************************************************************************************************************************************/

DECLARE @CRLF NVARCHAR(2) = CHAR(13) + CHAR(10)
DECLARE @DatabaseNameStage NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameStage')
DECLARE @DatabaseNameMeta NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameMeta')
DECLARE @DatabaseNameDW NVARCHAR(128) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'DatabaseNameDW')
DECLARE @SurrogateKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'SurrogateKeySuffix')
DECLARE @BusinessKeySuffix NVARCHAR(10) = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'BusinessKeySuffix')
DECLARE @IncrementalFactTable TABLE (TableName NVARCHAR(128)) 
INSERT @IncrementalFactTable EXEC('SELECT DISTINCT 
											tables.name 
								   FROM 
										[' + @DatabaseNameDW + '].sys.tables 
								   LEFT JOIN 
										[' + @DatabaseNameDW + '].sys.extended_properties AS TableProperties 
											ON TableProperties.major_id = tables.object_id 
								   WHERE 
										tables.name = ''' + @Table + ''' 
										AND TableProperties.name = ''IncrementalFactOrBridgeFlag''')
DECLARE @IncrementalFact BIT = IIF((SELECT * FROM @IncrementalFactTable) IS NOT NULL,@IncrementalFlag,0)
DECLARE @IsIncrementalFact BIT = IIF((SELECT * FROM @IncrementalFactTable) IS NOT NULL,1,0)
DECLARE @FactEngineIsSQLFlag BIT = IIF((SELECT VariableValue FROM meta.Variables WHERE VariableName = 'FactLoadEngine') = 'SQL',1,0)
DECLARE @IsCloudFlag BIT = (SELECT VariableValue FROM meta.Variables WHERE VariableName = 'IsCloudFLag')
--DECLARE @StageSchemaTable TABLE (SchemaName NVARCHAR(10)) 
--INSERT @StageSchemaTable-- EXEC('SELECT DISTINCT TABLE_SCHEMA FROM [' + @DatabaseNameStage + '].INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME = ''' + @Table + '''')
DECLARE @StageSchema NVARCHAR(10) = 'stage' --(SELECT IIF(@IsCloudFlag = 1,'stage',(SELECT SchemaName FROM @StageSchemaTable))) --If on-premise and stageschema has not been changed


/**********************************************************************************************************************************************************************
Execute MaintainDW if LoadEngine is SQL
***********************************************************************************************************************************************************************/
IF @IsCloudFlag = 1 AND @DisableMaintainDWFlag = 0
	BEGIN
		EXEC meta.MaintainDW @MasterTable = @Table, @MasterDestinationSchema = @DestinationSchema
		WAITFOR DELAY '00:00:02' --To prevent deadlock when running the procedure in parallel
	END

/**********************************************************************************************************************************************************************
1. Create and insert data into table variables
***********************************************************************************************************************************************************************/

DECLARE @InformationSchema TABLE (DatabaseName NVARCHAR(128),TableName NVARCHAR(128), ColumnName NVARCHAR(128), OrdinalPosition INT, DataType NVARCHAR(128), PrimaryKey INT)
DECLARE @Dimensions TABLE (TableName NVARCHAR(128), DimensionTable NVARCHAR(128), ColumnName NVARCHAR(128),ColumnMapping NVARCHAR(128),RolePlayingDimension NVARCHAR(128),IsSCD2Dimension NVARCHAR(10), IsSCD2CompositeKeyDimension NVARCHAR(10),OrdinalPosition INT,NewDimension NVARCHAR(128), ErrorValue NVARCHAR(128))
DECLARE @SCDCombinedKeys TABLE (DimensionTable NVARCHAR(128), ColumnName NVARCHAR(128), ColumnMapping NVARCHAR(128),OrdinalPosition INT, RolePlayingDimension NVARCHAR(128),NewDimension NVARCHAR(128), ErrorValue NVARCHAR(128))
DECLARE @SCDFromSource TABLE (DimensionTable NVARCHAR(128))
/*Generates the combined information schema*/
INSERT @InformationSchema 
(
 DatabaseName
,TableName
,ColumnName
,OrdinalPosition
,DataType
,PrimaryKey
) 

EXEC('WITH PrimaryKeys AS
								(
									SELECT DISTINCT
										tables.name AS TableName
									   ,all_columns.name AS ColumnName
									FROM
									   [' + @DatabaseNameDW + '].sys.tables
									INNER JOIN
									   [' + @DatabaseNameDW + '].sys.schemas
											ON schemas.schema_id = tables.schema_id
									INNER JOIN 
									   [' + @DatabaseNameDW + '].sys.all_columns 
											ON all_columns.object_id=tables.object_id
									INNER JOIN 
									   [' + @DatabaseNameDW + '].sys.extended_properties
											ON extended_properties.major_id=tables.object_id 
											AND extended_properties.minor_id=all_columns.column_id 
											AND extended_properties.class=1
									WHERE
									   extended_properties.name = ''PrimaryKeyColumn''
									   AND tables.name = ''' + @Table + '''
									   AND schemas.name = ''' + @DestinationSchema + '''
								)

								SELECT  ''Stage'' AS DatabaseName
										,COLUMNS.TABLE_NAME AS TableName
										,COLUMNS.COLUMN_NAME AS ColumnName
										,COLUMNS.ORDINAL_POSITION
										,COLUMNS.DATA_TYPE AS DataType
										,CASE WHEN PrimaryKeys.ColumnName IS NULL THEN 0 ELSE 1 END AS PrimaryKey
										 
								FROM 
									[' + @DatabaseNameStage + '].INFORMATION_SCHEMA.COLUMNS
								LEFT JOIN 
									PrimaryKeys
										ON PrimaryKeys.ColumnName = COLUMNS.COLUMN_NAME
								WHERE 
									    COLUMNS.TABLE_NAME = ''' + @Table + ''' 
									AND COLUMNS.COLUMN_NAME NOT LIKE ''DW%''
									AND COLUMNS.TABLE_SCHEMA = ''' + @StageSchema + ''''	
								
								)
				
				
/*Generates the mapping dataset between fact/bridge and dimensions*/
INSERT @Dimensions 
(
  TableName
 ,DimensionTable
 ,ColumnName
 ,ColumnMapping
 ,RolePlayingDimension
 ,IsSCD2Dimension
 ,IsSCD2CompositeKeyDimension
 ,OrdinalPosition
 ,NewDimension
 ,ErrorValue
)

EXEC meta.CreateDWRelations @Table = @Table  


SELECT 
	  'DW' AS DatabaseName
	, InformationSchema.TableName
	, ISNULL(Dimensions.RolePlayingDimension + 'ID',InformationSchema.ColumnName) AS ColumnName
	, LEAD(Dimensions.RolePlayingDimension) OVER (PARTITION BY Dimensions.RolePlayingDimension ORDER BY InformationSchema.ColumnName) AS Lead
	, ROW_NUMBER() OVER ( ORDER BY InformationSchema.OrdinalPosition) AS OrdinalPosition
	, IIF(Dimensions.RolePlayingDimension IS NOT NULL,'int',InformationSchema.DataType) AS DataType
	, InformationSchema.PrimaryKey
	INTO #DW
FROM @InformationSchema AS InformationSchema
LEFT JOIN
	@Dimensions AS Dimensions
		ON Dimensions.ColumnName = InformationSchema.ColumnName
GROUP BY InformationSchema.DatabaseName
	, InformationSchema.TableName
	, Dimensions.RolePlayingDimension
	,InformationSchema.ColumnName
	,InformationSchema.OrdinalPosition
	, InformationSchema.DataType
	, InformationSchema.PrimaryKey

INSERT INTO @InformationSchema 
(
 DatabaseName
,TableName
,ColumnName
,OrdinalPosition
,DataType
,PrimaryKey
) 

SELECT DatabaseName, TableName, ColumnName, ROW_NUMBER() OVER ( ORDER BY OrdinalPosition), DataType, PrimaryKey FROM #DW WHERE Lead IS NULL



/*Generates a dataset with composite SCD keys*/
INSERT @SCDCombinedKeys 
(
  DimensionTable
 ,ColumnName
 ,ColumnMapping
 ,OrdinalPosition
 ,RolePlayingDimension
 ,NewDimension
 ,ErrorValue
 )
 
 SELECT Dimensions.DimensionTable
							  ,InformationSchema.ColumnName
							  ,Dimensions.ColumnMapping
							  ,ROW_NUMBER() OVER (ORDER BY CASE WHEN Dimensions.RolePlayingDimension IS NULL THEN Dimensions.DimensionTable 
																			  ELSE Dimensions.RolePlayingDimension 
														   END,InformationSchema.OrdinalPosition) AS ORDINAL_POSITION
							  ,CASE WHEN Dimensions.RolePlayingDimension IS NULL THEN Dimensions.DimensionTable 
									ELSE Dimensions.RolePlayingDimension 
							   END
							  ,CASE WHEN ROW_NUMBER() OVER (PARTITION BY CASE WHEN Dimensions.RolePlayingDimension IS NULL THEN Dimensions.DimensionTable 
																			  ELSE Dimensions.RolePlayingDimension 
																		 END ORDER BY Dimensions.DimensionTable,InformationSchema.OrdinalPosition)  = 1 THEN N'Yes' 
									ELSE N'No' 
							   END 
							  ,Dimensions.ErrorValue
						FROM 
							@InformationSchema AS InformationSchema
						LEFT JOIN 
							@Dimensions AS Dimensions
								ON Dimensions.ColumnName = InformationSchema.ColumnName					
						WHERE 
							Dimensions.IsSCD2Dimension = 'Yes' 
							AND InformationSchema.DatabaseName = 'Stage'

INSERT @SCDFromSource 
(DimensionTable)

EXEC('SELECT DISTINCT TABLE_NAME AS DimensionTable FROM [' + @DatabaseNameStage + '].INFORMATION_SCHEMA.COLUMNS WHERE REPLACE(COLUMN_NAME,TABLE_NAME,'''') IN (''IsCurrent'',''ValidFromDate'',''ValidToDate'') AND TABLE_SCHEMA = ''stage''') 				
			

SELECT Dimensions.TableName
	  ,Dimensions.DimensionTable
	  ,Dimensions.ColumnName
	  ,Dimensions.ColumnMapping
	  ,Dimensions.RolePlayingDimension
	  ,Dimensions.IsSCD2Dimension
	  ,Dimensions.IsSCD2CompositeKeyDimension
	  ,ROW_NUMBER() OVER (ORDER BY InformationSchema.OrdinalPosition, Dimensions.OrdinalPosition) AS OrdinalPosition
	  ,Dimensions.NewDimension
	  ,Dimensions.ErrorValue
INTO #Dimensions
FROM @Dimensions AS Dimensions
INNER JOIN
	@InformationSchema AS InformationSchema
		ON InformationSchema.ColumnName = Dimensions.RolePlayingDimension + 'ID'
		AND InformationSchema.DatabaseName = 'DW'

DELETE FROM @Dimensions

INSERT INTO @Dimensions
(
  TableName
 ,DimensionTable
 ,ColumnName
 ,ColumnMapping
 ,RolePlayingDimension
 ,IsSCD2Dimension
 ,IsSCD2CompositeKeyDimension
 ,OrdinalPosition
 ,NewDimension
 ,ErrorValue
)

SELECT TableName
	  ,DimensionTable
	  ,ColumnName
	  ,ColumnMapping
	  ,RolePlayingDimension
	  ,IsSCD2Dimension
	  ,IsSCD2CompositeKeyDimension
	  ,OrdinalPosition
	  ,NewDimension
	  ,ErrorValue
FROM #Dimensions




/**********************************************************************************************************************************************************************
2. Create Loop counter variables and SCD2FromSource variable
***********************************************************************************************************************************************************************/

DECLARE @Counter INT 
DECLARE @MaxColumns INT  --Number of columns from stage
DECLARE @MaxSCDJoinColumns INT --Max position of composite SCD2 key columns
DECLARE @MaxJoinColumns INT --Max position of key columns from fact/bridge
DECLARE @MaxColumnsKeys INT --Max position of primary key columns i fact/bridge
DECLARE @MaxColumnsFact INT --Number of columns in fact/bridge

SELECT 
	   @Counter = 1
	  ,@MaxColumns = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE DatabaseName = 'Stage' )
	  ,@MaxJoinColumns = (SELECT MAX(OrdinalPosition) FROM @Dimensions) 
	  ,@MaxSCDJoinColumns = (SELECT MAX(OrdinalPosition) FROM @SCDCombinedKeys) 
	  ,@MaxColumnsKeys = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE PrimaryKey = 1 AND DatabaseName = 'DW')
	  ,@MaxColumnsFact = (SELECT MAX(OrdinalPosition) FROM @InformationSchema WHERE DatabaseName = 'DW')
	 
/**********************************************************************************************************************************************************************
3. Create position and support variables
***********************************************************************************************************************************************************************/

DECLARE @HasCalendarKey INT 
DECLARE @PositionFirstNonSCDColumn INT
DECLARE @SCDExists INT --Min position of key column from stage which is not an SCD column

SELECT
	   @HasCalendarKey = CASE WHEN (SELECT COUNT(*) FROM @InformationSchema WHERE ColumnName = 'Calendar' + @BusinessKeySuffix) > 0 THEN 1 ELSE 0 END --Check if CalendarKey is present
	  ,@PositionFirstNonSCDColumn = (SELECT MIN(I.OrdinalPosition) FROM @InformationSchema I INNER JOIN @Dimensions D ON D.ColumnName = I.ColumnName WHERE IsSCD2Dimension = 'No') --Gives the position of the first non SCD column
	  ,@SCDExists = IIF(EXISTS((SELECT * FROM @SCDCombinedKeys)),1,0)

/**********************************************************************************************************************************************************************
4. Create the select part of the source code for SCD dimensions
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderSelectSCD NVARCHAR(MAX)
DECLARE @SelectSCD NVARCHAR(MAX)

WHILE @Counter <= @MaxColumns

BEGIN

	SELECT @PlaceholderSelectSCD = --Check if it is the first column
								   CASE 
										WHEN @Counter = @PositionFirstNonSCDColumn 
											THEN ' '
										ELSE ','
								   END
								   
								   +
								   
								   --SCD2Composite keys is handled seperatly. Char columns is UPPER cased and date columns is cast to datetime
								   CASE 
										WHEN IsSCD2CompositeKeyDimension = 'Yes' 
											THEN CASE 
													WHEN InformationSchema.DataType LIKE '%char%' 
														THEN  'UPPER([' + InformationSchema.TableName + '].[' + InformationSchema.ColumnName + ']) AS [' + InformationSchema.ColumnName + ']'
													WHEN InformationSchema.DataType LIKE '%date%' 
														THEN  'CAST([' + InformationSchema.TableName + '].[' + InformationSchema.ColumnName + '] AS DATETIME) AS [' + InformationSchema.ColumnName + ']'
													ELSE '[' + InformationSchema.TableName + '].[' + InformationSchema.ColumnName + ']' 
												 END
										ELSE CASE 
												WHEN InformationSchema.DataType LIKE '%char%' 
													THEN  'UPPER([' + InformationSchema.ColumnName + ']) AS [' + InformationSchema.ColumnName + ']'
												WHEN InformationSchema.DataType LIKE '%date%' 
													THEN  'CAST([' + InformationSchema.ColumnName + '] AS DATETIME) AS [' + InformationSchema.ColumnName + ']'
												ELSE '[' + InformationSchema.ColumnName + ']' 
											 END
									END

								   + 
								   
								   @CRLF
	FROM 
		@InformationSchema AS InformationSchema
	LEFT JOIN 
		@Dimensions AS Dimensions
			ON Dimensions.ColumnName = InformationSchema.ColumnName
	WHERE 
		    Dimensions.IsSCD2Dimension = 'No' 
		AND @Counter = InformationSchema.OrdinalPosition 
		AND InformationSchema.DatabaseName = 'Stage'


	SET @SelectSCD = CONCAT(@SelectSCD,@PlaceholderSelectSCD)

	SET @PlaceholderSelectSCD = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
5. Create the select part of the source code for non ID columns
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderSelect NVARCHAR(MAX) = ''
DECLARE @Select NVARCHAR(MAX) = ''


WHILE @Counter <= @MaxColumns

BEGIN

	SELECT @PlaceholderSelect = ', [' + @Table + '].[' + InformationSchema.ColumnName + ']' + @CRLF
	FROM 
		@InformationSchema AS InformationSchema
	LEFT JOIN 
		@Dimensions AS Dimensions
			ON Dimensions.ColumnName = InformationSchema.ColumnName
	WHERE 
		Dimensions.DimensionTable IS NULL 
		AND @Counter = InformationSchema.OrdinalPosition 
		AND InformationSchema.DatabaseName = 'Stage'

	SET @Select = CONCAT(@Select,@PlaceholderSelect)

	SET @PlaceholderSelect = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1



/**********************************************************************************************************************************************************************
6. Create the select SCD ID with error handling 
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderIDSCDMerge NVARCHAR(MAX) 
DECLARE @IDSCDMerge NVARCHAR(MAX)
DECLARE @PlaceholderIDSCDColumns NVARCHAR(MAX) 
DECLARE @IDSCDColumns NVARCHAR(MAX)
DECLARE @PlaceholderIDSCD NVARCHAR(MAX)
DECLARE @IDSCD NVARCHAR(MAX)

WHILE @Counter <= @MaxSCDJoinColumns	

BEGIN

	SELECT @PlaceholderIDSCDMerge = CASE 
									WHEN @Counter = @SCDExists 
										THEN '' 
									ELSE ',' 
									END 
				 
									+ 
								
									'ISNULL([' + RolePlayingDimension + '].[' + DimensionTable + @SurrogateKeySuffix + '],' + ErrorValue +') AS [' + RolePlayingDimension + @SurrogateKeySuffix + ']' + @CRLF	
		, @PlaceholderIDSCDColumns = CASE 
									WHEN @Counter = @SCDExists 
										THEN '' 
									ELSE ',' 
									END 
									+ '[' + RolePlayingDimension + @SurrogateKeySuffix + ']' + @CRLF
		, @PlaceholderIDSCD = ',[' + RolePlayingDimension + '].[' + DimensionTable + @SurrogateKeySuffix + ']' + CASE 
																								WHEN RolePlayingDimension <> DimensionTable 
																									THEN ' AS [' + RolePlayingDimension + @SurrogateKeySuffix + ']'
	  																							ELSE '' 
																							END + @CRLF
	FROM 
		@SCDCombinedKeys
	WHERE 
			@Counter = OrdinalPosition 
		AND NewDimension = 'Yes' 
    
	SET @IDSCDMerge = CONCAT(@IDSCDMerge,@PlaceholderIDSCDMerge)
	
	SET @IDSCDColumns = CONCAT(@IDSCDColumns,@PlaceholderIDSCDColumns)

	SET @IDSCD = CONCAT(@IDSCD,@PlaceholderIDSCD)

	SET @PlaceholderIDSCD = ''

	SET @PlaceholderIDSCDMerge = ''

	SET @PlaceholderIDSCDColumns = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1



/**********************************************************************************************************************************************************************
7. Create the select ID part for source code 
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderIDMerge NVARCHAR(MAX)
DECLARE @IDMerge NVARCHAR(MAX) 

WHILE @Counter <= @MaxJoinColumns

BEGIN

	SELECT 
		  @PlaceholderIDMerge = CASE 
									WHEN @SCDExists = 0 AND @Counter = 1 
										THEN '' 
									ELSE ',' 
									END 
				 
									+ 
								CASE 
									WHEN RolePlayingDimension IS NOT NULL 
										THEN 'ISNULL([' + RolePlayingDimension + '].[' + DimensionTable + @SurrogateKeySuffix + '],' + ErrorValue + ') AS [' + RolePlayingDimension + @SurrogateKeySuffix + ']'
									ELSE 'ISNULL([' + DimensionTable + '].[' + DimensionTable + @SurrogateKeySuffix + '],' + ErrorValue + ') AS ' + '[' + DimensionTable + @SurrogateKeySuffix + ']' 
								END  
				 	 
								+ @CRLF
	FROM 
		@Dimensions
	WHERE
			@Counter = OrdinalPosition 
		AND NewDimension = 'Yes' 
		AND IsSCD2Dimension = 'No'

	SET @IDMerge = CONCAT(@IDMerge,CASE WHEN ISNULL( CHARINDEX (REPLACE(@PlaceholderIDMerge,',','') , @IDMerge),0) <> 0 THEN '' ELSE @PlaceholderIDMerge END)

	SET @PlaceholderIDMerge = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1


/**********************************************************************************************************************************************************************
8. Create the the left join part for SCD dimensions
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderLeftJoinSCD NVARCHAR(MAX) 
DECLARE @LeftJoinSCD NVARCHAR(MAX) 

WHILE @Counter <= @MaxSCDJoinColumns

BEGIN

	SELECT @PlaceholderLeftJoinSCD = CASE
										WHEN NewDimension = 'Yes'
											THEN 'LEFT JOIN [' + @DatabaseNameDW + '].[dim].[' + SCDCombinedKeys.DimensionTable + '] ' + CASE 
																																			WHEN RolePlayingDimension IS NOT NULL 
																																				THEN ' AS [' + RolePlayingDimension + ']' 
																																			ELSE '' 
																																		 END + @CRLF + 'ON  ' + CASE 
																																									WHEN @HasCalendarKey = 1 AND SCDFromSource.DimensionTable IS NULL
																																										THEN '[' + @Table + '].[CalendarKey] BETWEEN [' + RolePlayingDimension + '].[DWValidFromDate] AND [' + RolePlayingDimension + '].[DWValidToDate]' 
																																									WHEN @HasCalendarKey = 1 AND SCDFromSource.DimensionTable IS NOT NULL
																																										THEN '[' +  @Table + '].[CalendarKey] BETWEEN [' + RolePlayingDimension + '].[' + SCDFromSource.DimensionTable + 'ValidFromDate] AND [' + RolePlayingDimension + '].[' + SCDFromSource.DimensionTable + 'ValidToDate]' 
																																									WHEN @HasCalendarKey = 0 AND SCDFromSource.DimensionTable IS NOT NULL
																																										THEN  '[' + RolePlayingDimension + '].[' + SCDFromSource.DimensionTable + 'IsCurrent] = 1 ' 
																																									ELSE  '[' + RolePlayingDimension + '].[DWIsCurrent] = 1 ' 
																																								 END +  @CRLF + 'AND [' + RolePlayingDimension + '].[' + ColumnMapping  + '] = [' + @Table + '].[' + ColumnName + ']' 
										ELSE 'AND [' + RolePlayingDimension + '].[' + ColumnMapping + '] = [' + @Table + '].[' + ColumnName + ']' 
									 END + @CRLF
	FROM
		@SCDCombinedKeys AS SCDCombinedKeys
	LEFT JOIN 
		@SCDFromSource AS SCDFromSource
			ON SCDFromSource.DimensionTable = SCDCombinedKeys.DimensionTable
	WHERE 
		@Counter = OrdinalPosition
	
	SET @LeftJoinSCD = CONCAT(@LeftJoinSCD,@PlaceholderLeftJoinSCD)

	SET @PlaceholderLeftJoinSCD = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
9. Create the left join part for non SCD dimensions
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderLeftJoin NVARCHAR(MAX)
DECLARE @LeftJoin NVARCHAR(MAX)

WHILE @Counter <= @MaxJoinColumns

BEGIN

	SELECT @PlaceholderLeftJoin = CASE 
										WHEN NewDimension = 'Yes'
											THEN 'LEFT JOIN [' + @DatabaseNameDW + '].[dim].[' + DimensionTable + '] ' + CASE 
																																WHEN RolePlayingDimension IS NOT NULL 
																																	THEN ' AS [' + RolePlayingDimension + ']' 
																																ELSE '' 
																														   END + @CRLF + 'ON [' + CASE 
																																					WHEN RolePlayingDimension IS NOT NULL 
																																						THEN RolePlayingDimension 
																																					ELSE DimensionTable 
																																				 END + '].[' + ColumnMapping  + '] = [' + @Table + '].[' + ColumnName + ']' 
										ELSE 'AND [' + CASE 
														 WHEN RolePlayingDimension IS NOT NULL 
															THEN RolePlayingDimension 
													     ELSE DimensionTable 
													  END + '].[' + ColumnMapping + '] = [' + @Table + '].[' + ColumnName + ']' 
								  END + @CRLF
	FROM 
		@Dimensions
	WHERE 
			@Counter = OrdinalPosition 
		AND IsSCD2Dimension = 'No'

	SET @LeftJoin = CONCAT(@LeftJoin,@PlaceholderLeftJoin)

	SET @PlaceholderLeftJoin = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
10. Create the key part of the merge join statement
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderKeys NVARCHAR(MAX) --Placeholder used in the loop generating the business keys used in the Merge Join script
DECLARE @Keys NVARCHAR(MAX) --Holds the value of @Keys for each loop

WHILE @Counter <= @MaxColumnsKeys

BEGIN

	SELECT @PlaceholderKeys = '[source].[' + ColumnName + '] = [target].[' + ColumnName + ']'  + CASE 
																									WHEN @Counter != @MaxColumnsKeys 
																										THEN ' AND ' 
																								    ELSE '' 
																								 END
	FROM 
		@InformationSchema 
	WHERE 
			PrimaryKey = 1 
		AND OrdinalPosition = @Counter 
		AND DatabaseName = 'DW'

	SET @Keys = CONCAT(@Keys,@PlaceholderKeys)

	SET @PlaceholderKeys = ''

	SET @Counter = @Counter + 1

END


SET @Counter = 1
	
/**********************************************************************************************************************************************************************
11. Create the columns from stage for the merge script
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderColumnNameFact NVARCHAR(MAX) --Placeholder for the match SCD1 part of the script
DECLARE @ColumnNameFact NVARCHAR(MAX) --Holds the value of @ColumnNameDim for each loop

WHILE @Counter <= @MaxColumnsFact

BEGIN 

	SELECT @PlaceholderColumnNameFact = ',[' + InformationSchema.ColumnName + ']' + @CRLF

	FROM 
		@InformationSchema AS InformationSchema	
	WHERE 
			InformationSchema.OrdinalPosition = @Counter 
		AND DatabaseName = 'DW'
		AND InformationSchema.ColumnName NOT LIKE '%ID'

	SET @ColumnNameFact = CONCAT(@ColumnNameFact,@PlaceholderColumnNameFact)

	SET @PlaceholderColumnNameFact = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
11. Create the columns from stage for the merge script
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderColumnNameIDFact NVARCHAR(MAX) --Placeholder for the match SCD1 part of the script
DECLARE @ColumnNameIDFact NVARCHAR(MAX) --Holds the value of @ColumnNameDim for each loop
DECLARE @FirstKey INT = (SELECT MIN(InformationSchema.OrdinalPosition) FROM @InformationSchema AS InformationSchema LEFT JOIN (SELECT RolePlayingDimension,SUM(OrdinalPosition) AS OrdinalPosition FROM @SCDCombinedKeys GROUP BY RolePlayingDimension) AS SCDColumns ON CONCAT(SCDColumns.RolePlayingDimension,'ID') = InformationSchema.ColumnName WHERE DatabaseName = 'DW'AND SCDColumns.RolePlayingDimension IS NULL AND InformationSchema.ColumnName LIKE '%ID')

WHILE @Counter <= @MaxColumnsFact

BEGIN 

	SELECT @PlaceholderColumnNameIDFact = CASE 
										WHEN @SCDExists = 0 AND @Counter = @FirstKey 
											THEN '' 
										ELSE ',' 
									END 	 

									+ '[' + InformationSchema.ColumnName + ']' + @CRLF

	FROM 
		@InformationSchema AS InformationSchema
	LEFT JOIN
		(SELECT RolePlayingDimension,SUM(OrdinalPosition) AS OrdinalPosition FROM @SCDCombinedKeys GROUP BY RolePlayingDimension) AS SCDColumns
			ON CONCAT(SCDColumns.RolePlayingDimension,'ID') = InformationSchema.ColumnName
	WHERE 
			InformationSchema.OrdinalPosition = @Counter 
		AND DatabaseName = 'DW'
		AND SCDColumns.RolePlayingDimension IS NULL
		AND InformationSchema.ColumnName LIKE '%ID'

	SET @ColumnNameIDFact = CONCAT(@ColumnNameIDFact,@PlaceholderColumnNameIDFact)

	SET @PlaceholderColumnNameIDFact = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1



/**********************************************************************************************************************************************************************
12. Create the match part and the update part for the merge script
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderUpdateSCD1 NVARCHAR(MAX) --Placeholder for the update SCD1 part of the script
DECLARE @UpdateSCD1 NVARCHAR(MAX) --Holds the value of @ColumnNameDim for each loop
DECLARE @PlaceholderMatchSCD1 NVARCHAR(MAX) --Placeholder for the match SCD1 part of the script
DECLARE @MatchSCD1 NVARCHAR(MAX) --Holds the value of @ColumnNameDim for each loop

WHILE @Counter <= @MaxColumnsFact

BEGIN 

	SELECT @PlaceholderMatchSCD1 =  '([target].[' + ColumnName + '] <> [source].[' + ColumnName + ']) OR ([target].[' + ColumnName + '] IS NULL AND [source].[' + ColumnName + '] IS NOT NULL) OR ([target].[' + ColumnName + '] IS NOT NULL AND [source].[' + ColumnName + '] IS NULL)' 
									+ CASE 
										  WHEN @Counter != @MaxColumnsFact 
											 THEN ' OR ' 
										  ELSE '' 
									  END + @CRLF 
		  ,@PlaceholderUpdateSCD1 = '[target].[' + ColumnName + '] = [source].[' + ColumnName + '],' + @CRLF
        
	FROM 
		@InformationSchema
	WHERE 
			OrdinalPosition = @Counter 
		AND DatabaseName = 'DW'

	SET @MatchSCD1 = CONCAT(@MatchSCD1,@PlaceholderMatchSCD1)

	SET @PlaceholderMatchSCD1 = ''

	SET @UpdateSCD1 = CONCAT(@UpdateSCD1,@PlaceholderUpdateSCD1)

	SET @PlaceholderUpdateSCD1 = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1

/**********************************************************************************************************************************************************************
13. Create the delta part of the source code
***********************************************************************************************************************************************************************/

DECLARE @PlaceholderSelectDelta NVARCHAR(MAX) = ''
DECLARE @SelectDelta NVARCHAR(MAX) = ''

WHILE @Counter <= @MaxColumns

BEGIN

	SELECT @PlaceholderSelectDelta  = IIF(@Counter = 1,'',',') + CASE 
																	WHEN ColumnName NOT LIKE '%ID' AND ColumnName NOT LIKE '%Code' AND ColumnName NOT LIKE '%Number' AND Datatype IN ('Decimal','Numeric','int','bigint') THEN '-'
																	ELSE ''
																 END + '[target].[' + InformationSchema.ColumnName + ']' + @CRLF
	FROM 
		@InformationSchema AS InformationSchema	
	WHERE 
		@Counter = InformationSchema.OrdinalPosition 
		AND InformationSchema.DatabaseName = 'DW'
		AND InformationSchema.ColumnName <> 'LastValueLoaded'

	SET @SelectDelta = CONCAT(@SelectDelta,@PlaceholderSelectDelta)

	SET @PlaceholderSelectDelta = ''

	SET @Counter = @Counter + 1

END

SET @Counter = 1


/**********************************************************************************************************************************************************************
14. Fill out dynamic SQL variables
***********************************************************************************************************************************************************************/

DECLARE @DeleteFromFact NVARCHAR(MAX) --Holds the SCD1 part of the Merge Join Script
DECLARE @SQLFullLoad NVARCHAR(MAX) --Holds the SCD1 part of the Merge Join Script
DECLARE @SQLDelta NVARCHAR(MAX)
DECLARE @SQLReplacement NVARCHAR(MAX)
DECLARE @SQLStandard NVARCHAR(MAX)
DECLARE @SQLAdd NVARCHAR(MAX)
DECLARE @SQLMergeJoin NVARCHAR(MAX) --Holds the SCD1 part of the Merge Join Script
DECLARE @SQL NVARCHAR(MAX) --Holds the SCD1 part of the Merge Join Script

SET @SQLMergeJoin =
IIF(@IsCloudFlag = 1 ,'','USE ' + @DatabaseNameDW) + @CRLF + @CRLF +
'DECLARE @CurrentDateTime datetime
DECLARE @MinDateTime datetime
DECLARE @MaxDateTime datetime
DECLARE @BooleanTrue bit
DECLARE @BooleanFalse bit
DECLARE @DateToDateTime datetime

SELECT
	@CurrentDateTime = cast(getdate() as datetime),
	@MinDateTime = cast(''1900-01-01'' as datetime),
	@MaxDateTime = cast(''9999-12-31'' as datetime),
	@BooleanTrue = cast(1 as bit),
	@BooleanFalse = cast(0 as bit),
	@DateToDateTime = dateadd(ms,-3,  getdate())

-- ==================================================
-- SCD1
-- ==================================================

MERGE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '] as [target] USING
	  [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].[' + @Table + '_Temp] as [source]

-- Selects source rows in order to compare them to [target]

ON
(
' + @Keys + '
)

WHEN NOT MATCHED BY TARGET THEN

INSERT 
(
' 
+ ISNULL(@IDSCDColumns,'') +
+ ISNULL(@ColumnNameIDFact,'') +
+ ISNULL(@ColumnNameFact,'') + 
',[DWCreatedDate]
,[DWModifiedDate]

)

VALUES 
(
'  
+ ISNULL(@IDSCDColumns,'') +
+ ISNULL(@ColumnNameIDFact,'') +
+ ISNULL(@ColumnNameFact,'') + 
',@CurrentDateTime
,@CurrentDateTime
)


WHEN MATCHED 

THEN UPDATE

SET 
'+  @UpdateSCD1 + '[target].[DWModifiedDate] = @CurrentDateTime

;'

SET @SQLFullLoad = 'TRUNCATE TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '] ' 
+ IIF(@IsIncrementalFact = 1,'TRUNCATE TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '_Temp]','') + '  

EXEC [' + @DatabaseNameMeta + '].meta.[MaintainDWFactIndexes] @Table = ''' + @Table + ''', @DestinationSchema = ''' + @DestinationSchema + ''',@DisableIndexes = 1, @PrintSQL = 0
 
DECLARE @UpdateDateTime datetime = GETDATE()

INSERT INTO [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '] WITH (TABLOCK)
(
'   + ISNULL(@IDSCDColumns,'') 
	+ ISNULL(@ColumnNameIDFact,'') 
	+ ISNULL(@ColumnNameFact,'') + '
	,DWCreatedDate
	,DWModifiedDate
)  

SELECT 
	' + ISNULL(@IDSCDMerge,'')
	  + ISNULL(@IDMerge,'')
	  + ISNULL(@Select ,'')
	  + ',@UpdateDateTime' + @CRLF + ',@UpdateDateTime
FROM [' + @DatabaseNameStage + '].[' + @StageSchema + '].['+ @Table + '] AS ' + @Table + ' ' + @CRLF +
ISNULL(@LeftJoinSCD,'') + 
ISNULL(@LeftJoin,'') + @CRLF + @CRLF +

'EXEC [' + @DatabaseNameMeta + '].meta.[MaintainDWFactIndexes] @Table = ''' + @Table + ''', @DestinationSchema = ''' + @DestinationSchema + ''', @DisableIndexes = 0, @PrintSQL = 0'

SET @SQLStandard = 'TRUNCATE TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '_Temp] 

DECLARE @UpdateDateTime datetime = GETDATE()

INSERT INTO [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '_Temp] WITH (TABLOCK)
(
'   + ISNULL(@IDSCDColumns,'') +
	+ ISNULL(@ColumnNameIDFact,'') 
	+ ISNULL(@ColumnNameFact,'') + '
	,DWCreatedDate
	,DWModifiedDate
)  

SELECT 
	' + ISNULL(@IDSCDMerge,'')
	  + ISNULL(@IDMerge,'')
	  + ISNULL(@Select ,'')
	  + ', @UpdateDateTime AS DWCreatedDate ' + @CRLF + ', @UpdateDateTime AS DWModifiedDate
FROM [' + @DatabaseNameStage + '].[' + @StageSchema + '].['+ @Table + '] AS ' + @Table + ' ' + @CRLF +
ISNULL(@LeftJoinSCD,'') + 
ISNULL(@LeftJoin,'') + @CRLF + @CRLF 

SET @SQLAdd = 'TRUNCATE TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '_Temp] 

BEGIN TRY
    BEGIN TRAN

DECLARE @UpdateDateTime datetime = GETDATE()

DROP TABLE IF EXISTS #TempRows

SELECT 
	' + ISNULL(@IDSCDMerge,'')
	  + ISNULL(@IDMerge,'')
	  + ISNULL(@Select ,'')
	  + ', @UpdateDateTime AS DWCreatedDate' + @CRLF + ', @UpdateDateTime AS DWModifiedDate
	  INTO 
		#TempRows
FROM [' + @DatabaseNameStage + '].[' + @StageSchema + '].['+ @Table + '] AS ' + @Table + ' ' + @CRLF +
ISNULL(@LeftJoinSCD,'') + 
ISNULL(@LeftJoin,'') + @CRLF + @CRLF +

'INSERT INTO [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '] WITH (TABLOCK)
(
'   + ISNULL(@IDSCDColumns,'') +
	+ ISNULL(@ColumnNameIDFact,'') 
	+ ISNULL(@ColumnNameFact,'') + '
	,DWCreatedDate
	,DWModifiedDate
)  

SELECT 
	'  + ISNULL(@IDSCDColumns,'') +
	+ ISNULL(@ColumnNameIDFact,'') 
	+ ISNULL(@ColumnNameFact,'') + '
	,DWCreatedDate
	,DWModifiedDate
FROM #TempRows ' + @CRLF + @CRLF +

IIF(@CleanUpPartitionsFlag = 0,
'INSERT INTO [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '_Temp] WITH (TABLOCK)
(
'   + ISNULL(@IDSCDColumns,'') +
	+ ISNULL(@ColumnNameIDFact,'') 
	+ ISNULL(@ColumnNameFact,'') + '
	,DWCreatedDate
	,DWModifiedDate
)  

SELECT 
	'  + ISNULL(@IDSCDColumns,'') +
	+ ISNULL(@ColumnNameIDFact,'') 
	+ ISNULL(@ColumnNameFact,'') + '
	,DWCreatedDate
	,DWModifiedDate
FROM #TempRows '
,'') + @CRLF + @CRLF +

'COMMIT TRAN
END TRY
BEGIN CATCH
		IF @@TRANCOUNT > 0		
			ROLLBACK TRAN; --RollBack in case of Error
		THROW;  
END CATCH'


SET @DeleteFromFact = '
DELETE [target] WITH (TABLOCK)
FROM
	[' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '] AS [target]'  + @CRLF +
'INNER JOIN
	[' + @DatabaseNameStage + '].[' + @StageSchema + '].['+ @Table + '] AS [source]' + @CRLF + 'ON ' +
	+ @Keys



SET @SQLDelta = 'TRUNCATE TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '_Temp] ' + @CRLF + @CRLF +

'BEGIN TRY
    BEGIN TRAN' + @CRLF + @CRLF +
		
IIF(@CleanUpPartitionsFlag = 0,' EXEC [' + @DatabaseNameMeta + '].meta.FactPatternsDelta @Table = ''' + @Table + ''', @DestinationSchema = ''' + @DestinationSchema + ''', @CleanUpPartitionsFlag = 0, @PrintSQL = 0','')  + @CRLF +
IIF(@CleanUpPartitionsFlag = 1,@DeleteFromFact,'') + @CRLF + @CRLF +  

'
DECLARE @UpdateDateTime datetime = GETDATE()

DROP TABLE IF EXISTS #TempRows

SELECT 
	' + ISNULL(@IDSCDMerge,'')
	  + ISNULL(@IDMerge,'')
	  + ISNULL(@Select ,'')
	  + ', @UpdateDateTime AS DWCreatedDate' + @CRLF + ', @UpdateDateTime AS DWModifiedDate
	  INTO 
		#TempRows
FROM [' + @DatabaseNameStage + '].[' + @StageSchema + '].['+ @Table + '] AS ' + @Table + ' ' + @CRLF +
ISNULL(@LeftJoinSCD,'') + 
ISNULL(@LeftJoin,'') + @CRLF + @CRLF +

'INSERT INTO [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '] WITH (TABLOCK)
(
'   + ISNULL(@IDSCDColumns,'') +
	+ ISNULL(@ColumnNameIDFact,'') 
	+ ISNULL(@ColumnNameFact,'') + '
	,DWCreatedDate
	,DWModifiedDate
)  

SELECT 
	'  + ISNULL(@IDSCDColumns,'') +
	+ ISNULL(@ColumnNameIDFact,'') 
	+ ISNULL(@ColumnNameFact,'') + '
	,DWCreatedDate
	,DWModifiedDate
FROM #TempRows ' + @CRLF + @CRLF +

IIF(@CleanUpPartitionsFlag = 0,
'INSERT INTO [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '_Temp] WITH (TABLOCK)
(
'   + ISNULL(@IDSCDColumns,'') +
	+ ISNULL(@ColumnNameIDFact,'') 
	+ ISNULL(@ColumnNameFact,'') + '
	,DWCreatedDate
	,DWModifiedDate
)  

SELECT 
	'  + ISNULL(@IDSCDColumns,'') +
	+ ISNULL(@ColumnNameIDFact,'') 
	+ ISNULL(@ColumnNameFact,'') + '
	,DWCreatedDate
	,DWModifiedDate
FROM #TempRows '
,'') + @CRLF + @CRLF +

'COMMIT TRAN
END TRY
BEGIN CATCH
		IF @@TRANCOUNT > 0		
			ROLLBACK TRAN; --RollBack in case of Error
		THROW;  
END CATCH'

SET @SQLReplacement = 'TRUNCATE TABLE [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '_Temp] ' + @CRLF + @CRLF +

'BEGIN TRY
    BEGIN TRAN' + @CRLF + @CRLF +
		
IIF(@CleanUpPartitionsFlag = 0,' EXEC [' + @DatabaseNameMeta + '].meta.FactPatternsReplacement @Table = ''' + @Table + ''', @DestinationSchema = ''' + @DestinationSchema + ''', @CleanUpPartitionsFlag = 0, @PrintSQL = 0','')  + @CRLF +
IIF(@CleanUpPartitionsFlag = 1,' EXEC [' + @DatabaseNameMeta + '].meta.FactPatternsReplacement @Table = ''' + @Table + ''', @DestinationSchema = ''' + @DestinationSchema + ''', @CleanUpPartitionsFlag = 1, @PrintSQL = 0','') + @CRLF + @CRLF +  

'DECLARE @UpdateDateTime datetime = GETDATE()

DROP TABLE IF EXISTS #TempRows

SELECT 
	' + ISNULL(@IDSCDMerge,'')
	  + ISNULL(@IDMerge,'')
	  + ISNULL(@Select ,'')
	  + ', @UpdateDateTime AS DWCreatedDate' + @CRLF + ', @UpdateDateTime AS DWModifiedDate
	  INTO 
		#TempRows
FROM [' + @DatabaseNameStage + '].[' + @StageSchema + '].['+ @Table + '] AS ' + @Table + ' ' + @CRLF +
ISNULL(@LeftJoinSCD,'') + 
ISNULL(@LeftJoin,'') + @CRLF + @CRLF +

'
INSERT INTO [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '] WITH (TABLOCK)
(
'   + ISNULL(@IDSCDColumns,'') +
	+ ISNULL(@ColumnNameIDFact,'') 
	+ ISNULL(@ColumnNameFact,'') + '
	,DWCreatedDate
	,DWModifiedDate
)  

SELECT 
	' + ISNULL(@IDSCDColumns,'') +
	+ ISNULL(@ColumnNameIDFact,'') 
	+ ISNULL(@ColumnNameFact,'') + '
	,DWCreatedDate
	,DWModifiedDate
FROM #TempRows ' + @CRLF + @CRLF +

IIF(@CleanUpPartitionsFlag = 0,
'INSERT INTO [' + @DatabaseNameDW + '].[' + @DestinationSchema + '].['+ @Table + '_Temp] WITH (TABLOCK)
(
'   + ISNULL(@IDSCDColumns,'') +
	+ ISNULL(@ColumnNameIDFact,'') 
	+ ISNULL(@ColumnNameFact,'') + '
	,DWCreatedDate
	,DWModifiedDate
)  


SELECT 
	'  + ISNULL(@IDSCDColumns,'') +
	+ ISNULL(@ColumnNameIDFact,'') 
	+ ISNULL(@ColumnNameFact,'') + '
	,DWCreatedDate
	,DWModifiedDate
FROM #TempRows '
,'') + @CRLF + @CRLF +

'COMMIT TRAN
END TRY
BEGIN CATCH
		IF @@TRANCOUNT > 0		
			ROLLBACK TRAN; --RollBack in case of Error
		THROW;  
END CATCH'

SET @SQL = CASE 
				WHEN @IncrementalFact = 0 AND @FactEngineIsSQLFlag = 1 THEN @SQLFullLoad
				WHEN @IncrementalFact = 1 AND @LoadPattern = 'Standard' AND @FactEngineIsSQLFlag = 0 THEN @SQLMergeJoin
				WHEN @IncrementalFact = 1 AND @LoadPattern = 'Standard' AND @FactEngineIsSQLFlag = 1 THEN CONCAT(@SQLStandard,@SQLMergeJoin)
				WHEN @IncrementalFact = 1 AND @LoadPattern = 'Add' AND @FactEngineIsSQLFlag = 1 THEN  @SQLAdd
				WHEN @IncrementalFact = 1 AND @LoadPattern = 'Delta' AND @FactEngineIsSQLFlag = 1 THEN  @SQLDelta
				WHEN @IncrementalFact = 1 AND @LoadPattern = 'Replacement' AND @FactEngineIsSQLFlag = 1 THEN  @SQLReplacement
		   END
		   
IF @PrintSQL = 0

	BEGIN
		
		EXEC(@SQL)

	END

ELSE

	BEGIN
		
		IF @IncrementalFact = 0 AND @FactEngineIsSQLFlag = 1 
			BEGIN 
				PRINT(LEFT(@SQLFullLoad,4000)) 
				PRINT(SUBSTRING(@SQLFullLoad,4001,8000)) 
				PRINT(SUBSTRING(@SQLFullLoad,8001,12000)) 
				PRINT(SUBSTRING(@SQLFullLoad,12001,16000)) 
				PRINT(SUBSTRING(@SQLFullLoad,16001,20000)) 
				PRINT(SUBSTRING(@SQLFullLoad,20001,24000)) 
				PRINT(SUBSTRING(@SQLFullLoad,24001,28000)) 
			END
		IF @IncrementalFact = 1 AND @LoadPattern = 'Standard' AND @FactEngineIsSQLFlag = 0 
			BEGIN
				PRINT(LEFT(@SQLMergeJoin,4000)) 
				PRINT(SUBSTRING(@SQLMergeJoin,4001,8000)) 
				PRINT(SUBSTRING(@SQLMergeJoin,8001,12000)) 
				PRINT(SUBSTRING(@SQLMergeJoin,12001,16000)) 
				PRINT(SUBSTRING(@SQLMergeJoin,16001,20000)) 
				PRINT(SUBSTRING(@SQLMergeJoin,20001,24000)) 
				PRINT(SUBSTRING(@SQLMergeJoin,24001,28000)) 
			END
		IF @IncrementalFact = 1 AND @LoadPattern = 'Standard' AND @FactEngineIsSQLFlag = 1 
			BEGIN
				PRINT(LEFT(@SQLStandard,4000)) 
				PRINT(SUBSTRING(@SQLStandard,4001,8000)) 
				PRINT(SUBSTRING(@SQLStandard,8001,12000)) 
				PRINT(SUBSTRING(@SQLStandard,12001,16000)) 
				PRINT(SUBSTRING(@SQLStandard,16001,20000)) 
				PRINT(SUBSTRING(@SQLStandard,20001,24000)) 
				PRINT(SUBSTRING(@SQLStandard,24001,28000)) 
				PRINT(LEFT(@SQLMergeJoin,4000)) 
				PRINT(SUBSTRING(@SQLMergeJoin,4001,8000)) 
				PRINT(SUBSTRING(@SQLMergeJoin,8001,12000)) 
				PRINT(SUBSTRING(@SQLMergeJoin,12001,16000)) 
				PRINT(SUBSTRING(@SQLMergeJoin,16001,20000)) 
				PRINT(SUBSTRING(@SQLMergeJoin,20001,24000)) 
				PRINT(SUBSTRING(@SQLMergeJoin,24001,28000)) 
			END
		IF @IncrementalFact = 1 AND @LoadPattern = 'Add' AND @FactEngineIsSQLFlag = 1 
			BEGIN
				PRINT(LEFT(@SQLAdd,4000)) 
				PRINT(SUBSTRING(@SQLAdd,4001,8000)) 
				PRINT(SUBSTRING(@SQLAdd,8001,12000)) 
				PRINT(SUBSTRING(@SQLAdd,12001,16000)) 
				PRINT(SUBSTRING(@SQLAdd,16001,20000)) 
				PRINT(SUBSTRING(@SQLAdd,20001,24000)) 
				PRINT(SUBSTRING(@SQLAdd,24001,28000)) 
			END
		IF @IncrementalFact = 1 AND @LoadPattern = 'Delta' AND @FactEngineIsSQLFlag = 1 
			BEGIN
				PRINT(LEFT(@SQLDelta,4000)) 
				PRINT(SUBSTRING(@SQLDelta,4001,8000)) 
				PRINT(SUBSTRING(@SQLDelta,8001,12000)) 
				PRINT(SUBSTRING(@SQLDelta,12001,16000)) 
				PRINT(SUBSTRING(@SQLDelta,16001,20000)) 
				PRINT(SUBSTRING(@SQLDelta,20001,24000)) 
				PRINT(SUBSTRING(@SQLDelta,24001,28000)) 
			END
		IF @IncrementalFact = 1 AND @LoadPattern = 'Replacement' AND @FactEngineIsSQLFlag = 1 
			BEGIN
				PRINT(LEFT(@SQLReplacement,4000)) 
				PRINT(SUBSTRING(@SQLReplacement,4001,8000)) 
				PRINT(SUBSTRING(@SQLReplacement,8001,12000)) 
				PRINT(SUBSTRING(@SQLReplacement,12001,16000)) 
				PRINT(SUBSTRING(@SQLReplacement,16001,20000)) 
				PRINT(SUBSTRING(@SQLReplacement,20001,24000)) 
				PRINT(SUBSTRING(@SQLReplacement,24001,28000)) 
			END
	END
					
			

DROP TABLE #Dimensions
DROP TABLE #DW
GO
PRINT N'Creating [BPFVersion]...';


GO
EXECUTE sp_addextendedproperty @name = N'BPFVersion', @value = N'2.0.17';


GO
PRINT N'Creating [BusinessKeySuffix]...';


GO
EXECUTE sp_addextendedproperty @name = N'BusinessKeySuffix', @value = N'Key';


GO
PRINT N'Creating [DatabaseNameDW]...';


GO
EXECUTE sp_addextendedproperty @name = N'DatabaseNameDW', @value = N'DataEstateMeta';


GO
PRINT N'Creating [DatabaseNameExtract]...';


GO
EXECUTE sp_addextendedproperty @name = N'DatabaseNameExtract', @value = N'DataEstateMeta';


GO
PRINT N'Creating [DatabaseNameHistory]...';


GO
EXECUTE sp_addextendedproperty @name = N'DatabaseNameHistory', @value = N'DataEstateMeta';


GO
PRINT N'Creating [DatabaseNameMeta]...';


GO
EXECUTE sp_addextendedproperty @name = N'DatabaseNameMeta', @value = N'DataEstateMeta';


GO
PRINT N'Creating [DatabaseNameStage]...';


GO
EXECUTE sp_addextendedproperty @name = N'DatabaseNameStage', @value = N'DataEstateMeta';


GO
PRINT N'Creating [DatabaseNameTabular]...';


GO
EXECUTE sp_addextendedproperty @name = N'DatabaseNameTabular', @value = N'BPFIntroDW';


GO
PRINT N'Creating [DefaultBit]...';


GO
EXECUTE sp_addextendedproperty @name = N'DefaultBit', @value = N'0';


GO
PRINT N'Creating [DefaultDate]...';


GO
EXECUTE sp_addextendedproperty @name = N'DefaultDate', @value = N'19000101';


GO
PRINT N'Creating [DefaultDimensionMemberID]...';


GO
EXECUTE sp_addextendedproperty @name = N'DefaultDimensionMemberID', @value = N'-1';


GO
PRINT N'Creating [DefaultMaxDop]...';


GO
EXECUTE sp_addextendedproperty @name = N'DefaultMaxDop', @value = N'5';


GO
PRINT N'Creating [DefaultNumber]...';


GO
EXECUTE sp_addextendedproperty @name = N'DefaultNumber', @value = N'0';


GO
PRINT N'Creating [DefaultString]...';


GO
EXECUTE sp_addextendedproperty @name = N'DefaultString', @value = N'?';


GO
PRINT N'Creating [EnableAutoPartitionFlag]...';


GO
EXECUTE sp_addextendedproperty @name = N'EnableAutoPartitionFlag', @value = N'0';


GO
PRINT N'Creating [EnterpriseEditionFlag]...';


GO
EXECUTE sp_addextendedproperty @name = N'EnterpriseEditionFlag', @value = N'1';


GO
PRINT N'Creating [ExtractCCIFlag]...';


GO
EXECUTE sp_addextendedproperty @name = N'ExtractCCIFlag', @value = N'0';


GO
PRINT N'Creating [ExtractCCIHistoryFlag]...';


GO
EXECUTE sp_addextendedproperty @name = N'ExtractCCIHistoryFlag', @value = N'1';


GO
PRINT N'Creating [ExtractControllerPattern]...';


GO
EXECUTE sp_addextendedproperty @name = N'ExtractControllerPattern', @value = N'Standard';


GO
PRINT N'Creating [FactCCIFlag]...';


GO
EXECUTE sp_addextendedproperty @name = N'FactCCIFlag', @value = N'1';


GO
PRINT N'Creating [FactInMemoryFlag]...';


GO
EXECUTE sp_addextendedproperty @name = N'FactInMemoryFlag', @value = N'1';


GO
PRINT N'Creating [FactLoadEngine]...';


GO
EXECUTE sp_addextendedproperty @name = N'FactLoadEngine', @value = N'SQL';


GO
PRINT N'Creating [IsCloudFlag]...';


GO
EXECUTE sp_addextendedproperty @name = N'IsCloudFlag', @value = N'1';


GO
PRINT N'Creating [LoadControllerPattern]...';


GO
EXECUTE sp_addextendedproperty @name = N'LoadControllerPattern', @value = N'Standard';


GO
PRINT N'Creating [MaintainDWDropTableFlag]...';


GO
EXECUTE sp_addextendedproperty @name = N'MaintainDWDropTableFlag', @value = N'0';


GO
PRINT N'Creating [MaintainDWDropViewFlag]...';


GO
EXECUTE sp_addextendedproperty @name = N'MaintainDWDropViewFlag', @value = N'0';


GO
PRINT N'Creating [MaintainDWUpdateViewFlag]...';


GO
EXECUTE sp_addextendedproperty @name = N'MaintainDWUpdateViewFlag', @value = N'1';


GO
PRINT N'Creating [SeparateHistoryLayerFlag]...';


GO
EXECUTE sp_addextendedproperty @name = N'SeparateHistoryLayerFlag', @value = N'0';


GO
PRINT N'Creating [SurrogateKeySuffix]...';


GO
EXECUTE sp_addextendedproperty @name = N'SurrogateKeySuffix', @value = N'ID';


GO
